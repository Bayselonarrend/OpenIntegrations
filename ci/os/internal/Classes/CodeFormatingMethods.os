#Использовать "./internal"

#Область СлужебныйПрограммныйИнтерфейс

Процедура ПриСозданииОбъекта(Знач ДанныеПроекта_ = Неопределено)

	Если ДанныеПроекта_ = Неопределено Тогда
		ДанныеПроекта = Новый ProjectData;
	Иначе
		ДанныеПроекта = ДанныеПроекта_;
	КонецЕсли;

	МассивФайлов = ДанныеПроекта.ОпределитьНаборФайловФорматирования();

	CommonTools.СообщитьПроцесс("Code formatting");
	
	Для Каждого Файл Из МассивФайлов Цикл
		ОтформатироватьМодуль(Файл.ПолноеИмя);
	КонецЦикла;

КонецПроцедуры

Процедура ОтформатироватьМодуль(Знач ПутьКМодулю) Экспорт

	ТекстовыйДокумент = Новый ТекстовыйДокумент();
	ТекстовыйДокумент.Прочитать(ПутьКМодулю, "UTF-8");

	БлокиКода  = РазобратьМодульНаБлоки(ТекстовыйДокумент);
	ТекстФайла = ОтформатироватьБлоки(БлокиКода);

	ТекстовыйДокумент.УстановитьТекст(ТекстФайла);
	ТекстовыйДокумент.Записать(ПутьКМодулю);

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция РазобратьМодульНаБлоки(Знач ТекстовыйДокумент)

	Для Н = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл

		ТекущаяСтрока = ТекстовыйДокумент.ПолучитьСтроку(Н);

		Если Не ЗначениеЗаполнено(СокрЛП(ТекущаяСтрока)) Тогда
			ТекстовыйДокумент.ЗаменитьСтроку(Н, "⣿");
		Иначе
			ТекстовыйДокумент.ЗаменитьСтроку(Н, СокрП(ТекущаяСтрока));
		КонецЕсли;

	КонецЦикла;

	ТекстФайла = ТекстовыйДокумент.ПолучитьТекст();
	БлокиФайла = СтрРазделить(ТекстФайла, "⣿");

	Возврат БлокиФайла;

КонецФункции

Функция ОтформатироватьБлоки(Знач БлокиКода)

	Для Н = 0 По БлокиКода.ВГраница() Цикл

		МассивСтрокБлока = СтрРазделить(БлокиКода[Н], Символы.ПС);

		Если МассивСтрокБлока.Количество() < 2 Тогда
			Продолжить;
		ИначеЕсли СтрНачинаетсяС(СокрЛП(МассивСтрокБлока[1]), "//") Тогда
			Продолжить;
		Иначе
			ВыровнятьЗнакиРавно(МассивСтрокБлока);
			ВыровнятьЗапятые(МассивСтрокБлока);
		КонецЕсли;

		БлокиКода[Н] = СтрСоединить(МассивСтрокБлока, Символы.ПС);

	КонецЦикла;

	ТекстФайла = СтрСоединить(БлокиКода, "");
	ТекстФайла = СтрЗаменить(ТекстФайла, Символы.Таб, "    ");

	Возврат ТекстФайла;

КонецФункции

Процедура ВыровнятьЗнакиРавно(МассивСтрокБлока)

	СоответствиеРасположений = Новый Соответствие();
	МаксимальноеРасположение = 0;
	ЧислоЗнаковРавно         = 0;

	МассивКонструкций = Новый Массив;
	МассивКонструкций.Добавить("Если ");
	МассивКонструкций.Добавить("Тогда ");
	МассивКонструкций.Добавить("Для ");
	МассивКонструкций.Добавить("Пока ");
	МассивКонструкций.Добавить("ИначеЕсли ");
	МассивКонструкций.Добавить("Функция ");
	МассивКонструкций.Добавить("Процедура ");
	МассивКонструкций.Добавить("Знач ");

	Для Н = 0 По МассивСтрокБлока.ВГраница() Цикл

		РасположениеРавно = СтрНайти(МассивСтрокБлока[Н], "=");

		Если Не РасположениеРавно = 0 Тогда
			
			МассивЧастей = СтрРазделить(МассивСтрокБлока[Н], "=");
			НеПроверять  = Ложь;
			
			Для А = 0 По МассивЧастей.ВГраница() - 1 Цикл
				
				ЧислоКавычек = СтрЧислоВхождений(МассивЧастей[А], """");
				
				Если ЧислоКавычек <> 0 И ЧислоКавычек % 2 <> 0 Тогда
					СоответствиеРасположений.Вставить(Н, 0);
					НеПроверять = Истина;
					Прервать;
				КонецЕсли;

			КонецЦикла;

			ТекущаяСтрока = СокрЛП(МассивСтрокБлока[Н]);

			Для Каждого Конструкция Из МассивКонструкций Цикл
				Если СтрНачинаетсяС(ТекущаяСтрока, Конструкция) Тогда

					Пока СтрНайти(МассивСтрокБлока[Н], "  =") > 0 Цикл
						МассивСтрокБлока[Н] = СтрЗаменить(МассивСтрокБлока[Н], "  =", " =");
					КонецЦикла;
					НеПроверять = Истина;
					Продолжить;
				КонецЕсли;
			КонецЦикла;
			
			Если НеПроверять Тогда
				Продолжить;
			Иначе
				Пока СтрНайти(МассивСтрокБлока[Н], "  =") > 0 Цикл
					МассивСтрокБлока[Н] = СтрЗаменить(МассивСтрокБлока[Н], "  =", " =");
				КонецЦикла;
				РасположениеРавно = СтрНайти(МассивСтрокБлока[Н], "=");
			КонецЕсли;

		КонецЕсли;

		СоответствиеРасположений.Вставить(Н, РасположениеРавно);
		МаксимальноеРасположение = ?(РасположениеРавно > МаксимальноеРасположение, РасположениеРавно, МаксимальноеРасположение);

		Если Не РасположениеРавно = 0 Тогда
			ЧислоЗнаковРавно = ЧислоЗнаковРавно + 1;
		КонецЕсли;

	КонецЦикла;

	Если МаксимальноеРасположение = 0 Или ЧислоЗнаковРавно < 2 Тогда
		Возврат;
	КонецЕсли;

	Для Каждого СтрокаБлока Из СоответствиеРасположений Цикл

		РасположениеРавно = СтрокаБлока.Значение;
		Индекс            = СтрокаБлока.Ключ;

		Если РасположениеРавно = 0 Тогда
			Продолжить;
		КонецЕсли;

		Для Н = РасположениеРавно По МаксимальноеРасположение - 1 Цикл
			МассивСтрокБлока[Индекс] = СтрЗаменитьПервый(МассивСтрокБлока[Индекс], "=", " =");
		КонецЦикла;

	КонецЦикла;

КонецПроцедуры

Процедура ВыровнятьЗапятые(МассивСтрокБлока, СоответствиеМаксимумов = "")

	ПолноеСоответствиеРасположений = Новый Соответствие();
	СтрокаСЗапятыми = 0;
	НачалоСтроки    = "";

	Для Н = 0 По МассивСтрокБлока.ВГраница() Цикл

		Если СтрНачинаетсяС(СокрЛП(МассивСтрокБлока[Н]), "|") Тогда
			Возврат;
		КонецЕсли;
		МассивУчастков   = СтрРазделить(МассивСтрокБлока[Н], ",");
		МассивУчастков_  = Новый Массив;
		Соединение       = Ложь;
		СтрокаСоединения = "";

		Для Каждого Участок Из МассивУчастков Цикл

			ЧислоКавычек = СтрЧислоВхождений(Участок, """");

			Если (ЧислоКавычек = 0 Или ЧислоКавычек % 2 = 0 ) И Не Соединение Тогда

				МассивУчастков_.Добавить(Участок);

			ИначеЕсли Соединение И ЧислоКавычек % 2 <> 0 Тогда
				МассивУчастков_.Добавить(СтрокаСоединения + "," + Участок);
				СтрокаСоединения = "";
				Соединение       = Ложь;

			Иначе
				СтрокаСоединения = ?(ЗначениеЗаполнено(СтрокаСоединения), СтрокаСоединения + "," + Участок, Участок);
				Соединение       = Истина;
			КонецЕсли;

		КонецЦикла;

		МассивУчастков = МассивУчастков_;

		Если МассивУчастков.Количество() < 2 Тогда
			Продолжить;
		Иначе
			СтрокаСЗапятыми = СтрокаСЗапятыми + 1;
		КонецЕсли;

		МассивНачалаСтроки = СтрРазделить(МассивУчастков[0], "(");

		Если МассивНачалаСтроки.Количество() < 2 Тогда
			Продолжить;
		КонецЕсли;

		НачалоСтроки             = МассивНачалаСтроки[0];
		СоответствиеРасположений = ПолноеСоответствиеРасположений[НачалоСтроки];

		Если Не ЗначениеЗаполнено(СоответствиеРасположений) Тогда
			СоответствиеРасположений = Новый Соответствие;
		КонецЕсли;

		Для Р = 0 По МассивУчастков.ВГраница() - 1 Цикл

			Если Не ЗначениеЗаполнено(СоответствиеМаксимумов) Тогда

				ДлинаУчастка = СтрДлина(МассивУчастков[Р]);

				ТекущийМаксимум = СоответствиеРасположений.Получить(Р);
				ТекущийМаксимум = ?(ЗначениеЗаполнено(ТекущийМаксимум), ТекущийМаксимум, 0);
				ТекущийМаксимум = ?(ДлинаУчастка > ТекущийМаксимум    , ДлинаУчастка   , ТекущийМаксимум);

				СоответствиеРасположений.Вставить(Р, ТекущийМаксимум);

			Иначе

				ТекущееСоответствиеМаксимумов = СоответствиеМаксимумов[НачалоСтроки];

				Если Не ЗначениеЗаполнено(ТекущееСоответствиеМаксимумов) Тогда
					Прервать;
				КонецЕсли;

				НеобходимаяДлина = ТекущееСоответствиеМаксимумов[Р];

				Если НеобходимаяДлина = Неопределено Тогда
					Продолжить;
				КонецЕсли;

				Пока СтрДлина(МассивУчастков[Р]) < НеобходимаяДлина Цикл
					МассивУчастков[Р] = МассивУчастков[Р] + " ";
				КонецЦикла;

			КонецЕсли;

		КонецЦикла;

		ПолноеСоответствиеРасположений.Вставить(НачалоСтроки, СоответствиеРасположений);

		МассивСтрокБлока[Н] = СтрСоединить(МассивУчастков, ",");

	КонецЦикла;

	Если Не ЗначениеЗаполнено(СоответствиеМаксимумов)
		И ЗначениеЗаполнено(ПолноеСоответствиеРасположений)
		И СтрокаСЗапятыми > 1 Тогда
		ВыровнятьЗапятые(МассивСтрокБлока, ПолноеСоответствиеРасположений);
	КонецЕсли;

КонецПроцедуры

Функция СтрЗаменитьПервый(Знач Значение, Знач СимволПоиска, Знач СимволЗамены)

	Возврат СтрЗаменить(Лев(Значение, СтрНайти(Значение, СимволПоиска)), СимволПоиска , СимволЗамены) + Сред(Значение, СтрНайти(Значение, СимволПоиска) + 1);

КонецФункции

#КонецОбласти