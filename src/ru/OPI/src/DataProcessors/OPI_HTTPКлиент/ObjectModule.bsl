// MIT License

// Copyright (c) 2023-2025 Anton Tsitavets

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// https://github.com/Bayselonarrend/OpenIntegrations

// BSLLS:Typo-off
// BSLLS:LatinAndCyrillicSymbolInWord-off
// BSLLS:IncorrectLineBreak-off
// BSLLS:NumberOfOptionalParams-off
// BSLLS:UsingServiceTag-off
// BSLLS:LineLength-off

//@skip-check module-structure-top-region
//@skip-check module-structure-method-in-regions
//@skip-check wrong-string-literal-content
//@skip-check method-too-many-params
//@skip-check constructor-function-return-section
//@skip-check doc-comment-collection-item-type

// Раскомментировать, если выполняется OneScript
// #Использовать "../../tools"

#Если Клиент Тогда
    ВызватьИсключение "Метод недоступен на клиенте!";
#Иначе
    
#Область ОписаниеПеременных

// Обработка

Перем Инициализирован;

Перем Ошибка Экспорт;
Перем Лог;

// Запрос

Перем Запрос;
Перем Соединение;
Перем Настройки;

Перем ЗапросURL;
Перем ЗапросСервер;
Перем ЗапросПорт;
Перем ЗапросАдрес;
Перем ЗапросЗащищенное;
Перем ЗапросДомен;

Перем ЗапросПараметрыURL;
Перем ЗапросТело;
Перем ЗапросЗаголовки;
Перем ЗапросПользователь;
Перем ЗапросПароль;
Перем ЗапросТаймаут;
Перем ЗапросПрокси;
Перем ЗапросВыходнойФайл;
Перем ЗапросФайлТела;
Перем ЗапросПотокТела;
Перем ЗапросЗаписьДанных;
Перем ЗапросТипДанных;
Перем ФайлТелаВременный;

// Ответ

Перем Ответ;
Перем ОтветКодСостояния; 
Перем ОтветТело;
Перем ОтветЗаголовки;

// Multipart

Перем Multipart;
Перем Boundary;
Перем РазделительСтрок;

#КонецОбласти

#Область ПрограммныйИнтерфейс

#Область Инициализация

// Инициализировать !NOCLI
// Инициализирует новый пустой запрос
// 
// Примечание:
// Функция обязательная для вызова первой при создании нового объекта обработки
// 
// Параметры:
//  URL - Строка - URL адрес для запроса
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция Инициализировать(Знач URL = "") Экспорт
            
    Инициализирован = Истина;
    Ошибка          = Ложь;  
    Лог             = Новый Массив;
    
    ЗапросПараметрыURL = Новый Массив;
    ЗапросТело         = Неопределено;
    ЗапросЗаголовки    = Новый Соответствие;
	ЗапросТаймаут      = 3600;
    
    ФайлТелаВременный = Ложь;
    
    ОтветКодСостояния = 0;
    ОтветТело         = Неопределено;
    ОтветЗаголовки    = Новый Соответствие;
    
    Multipart = Ложь;
    
    УстановитьСтандартныеНастройки();
    УстановитьURL(URL);
    
    Возврат ЭтотОбъект;    
    
КонецФункции

// Установить URL !NOCLI
// Устанавливает новый URL запроса
// 
// Параметры:
//  URL - Строка -  URL запроса - url
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьURL(Знач URL) Экспорт

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
               
            Если ЗначениеЗаполнено(URL) Тогда
                
                OPI_ПреобразованиеТипов.ПолучитьСтроку(URL);
                OPI_Инструменты.ВернутьУправляющиеПоследовательности(URL);
                
                ЗапросURL = URL;
                
                ДобавитьЛог("УстановитьURL: Разбиение запроса на составные части");     
                                
            Иначе
                
                ДобавитьЛог("УстановитьURL: URL пуст - пропуск");
                
            КонецЕсли;
            
            Возврат РазбитьURL();
            
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
    
КонецФункции

// Установить параметры URL !NOCLI
// Устанавливает коллекцию параметров URL
// 
// Параметры:
//  Значение - Произвольный - Стрктура или соответствие параметров URL - params
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьПараметрыURL(Знач Значение) Экспорт

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        Если Не ЗначениеЗаполнено(Значение) Тогда Значение = Новый Структура; КонецЕсли;
        
        ТекстОшибки = "УстановитьПараметрыURL: Переданные параметры не являются коллекцией ключ/значение";
        OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Значение, ТекстОшибки);
        ЗапросПараметрыURL = Значение;
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

// Установить объект запроса !NOCLI
// Позволяет установить заранее созданный объект HTTPЗапрос для дальнейшей работы
// 
// Примечание:
// Получить объект запроса можно при помощи функции `ВернутьЗапрос`
// 
// Параметры:
//  Значение - HTTPЗапрос - Объект запроса - obj
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьОбъектЗапроса(Знач Значение) Экспорт

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
        Если ТипЗнч(Значение) <> Тип("HTTPЗапрос") Тогда
            Возврат Ошибка("УстановитьОбъектЗапроса: Передан не запрос");
        Иначе
            ДобавитьЛог("УстановитьОбъектЗапроса: Установка значения");
            Запрос = Значение;
        КонецЕсли;
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

// Установить объект соединения !NOCLI
// Позволяет установить заранее созданный объект HTTPСоединение для дальнейшей работы
// 
// Примечание:
// Получить объект запроса можно при помощи функции `ВернутьЗапрос`
// 
// Параметры:
//  Значение - HTTPСоединение - Объект соединения - obj
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьОбъектСоединения(Знач Значение) Экспорт

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
        Если ТипЗнч(Значение) <> Тип("HTTPСоединение") Тогда
            Возврат Ошибка("УстановитьОбъектСоединения: Передано не соединение");
        Иначе
            ДобавитьЛог("УстановитьОбъектСоединения: Установка значения");
            Соединение = Значение;
        КонецЕсли;
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

// Установить файл ответа !NOCLI
// Устанавливает путь к файлу для сохранения результата запроса
// 
// Параметры:
//  Значение - Строка - Путь к файлу - filepath
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьФайлОтвета(Знач Значение) Экспорт

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        Если Не ЗначениеЗаполнено(Значение) Тогда 
            ЗапросВыходнойФайл = Неопределено;
            Возврат ЭтотОбъект; 
        КонецЕсли;
        
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
        ЗапросВыходнойФайл = Значение;
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

// Получить ошибки !NOCLI
// Получает лог выполнения
// 
// Параметры:
//  Строкой - Булево - Возврат лога в виде строки - string
// 
// Возвращаемое значение:
//  Строка, Массив - Лог выполнения
Функция ПолучитьЛог(Знач Строкой = Ложь) Экспорт
    
    OPI_ПреобразованиеТипов.ПолучитьБулево(Строкой);
    
    Если Не ЗначениеЗаполнено(Лог) Тогда
        Возврат ?(Строкой, "", Новый Массив);
    Иначе
        Возврат ?(Строкой, СтрСоединить(Лог, Символы.ПС), Лог);
    КонецЕсли;
    
КонецФункции

#КонецОбласти

#Область УстановкаТела

// Установить двоичное тело !NOCLI
// Устанавливает тело запрос из двоичных данных, файла или строки (с преобразованием в двоичные данные)
// 
// Параметры:
//  Данные - Строка, ДвоичныеДанные - Файл, строка или данные тела запроса - data
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьДвоичноеТело(Знач Данные) Экспорт
 
    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
        ОтменитьЗаписьMultipart();
		
		ЗапросТипДанных = "application/octet-stream";
        
        ДобавитьЛог("УстановитьДвоичноеТело: Начало установки тела");
        УстановитьТелоИзДвоичныхДанных(Данные);
        ДобавитьЛог(СтрШаблон("УстановитьДвоичноеТело: Тело установлено, размер %1", ЗапросТело.Размер()));
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
    
КонецФункции

// Установить строковое тело !NOCLI
// Устанавливает тело запроса из строки в указанной кодировке
// 
// Параметры:
//  Данные      - Строка - Данные тела запроса         - data
//  Кодировка   - Строка - Кодировка строки            - enc
//  ЗаписатьBOM - Булево - Истина > BOM будет добавлен - bom
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьСтроковоеТело(Знач Данные, Знач Кодировка = "UTF-8", Знач ЗаписатьBOM = Ложь) Экспорт

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
        ОтменитьЗаписьMultipart();
		
		ЗапросТипДанных  = "text/plain; charset=utf-8";
        
        ДобавитьЛог("УстановитьСтроковоеТело: Начало установки тела");
        УстановитьТелоИзСтроки(Данные, Кодировка, ЗаписатьBOM);
        ДобавитьЛог(СтрШаблон("УстановитьСтроковоеТело: Тело установлено, размер %1", ЗапросТело.Размер()));
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

// Установить JSON тело !NOCLI
// Устанавливает тело в формате JSON из подходящей коллекции или строки
// 
// Параметры:
//  Данные - Произвольный - Строка или коллекция для преобразования в JSON - data
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьJsonТело(Знач Данные) Экспорт

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
        ОтменитьЗаписьMultipart();
		
		ЗапросТипДанных  = "application/json; charset=utf-8";
        
        ДобавитьЛог("УстановитьJsonТело: Начало установки тела");
         
        OPI_ПреобразованиеТипов.ПолучитьКоллекцию(Данные);
        УстановитьТелоИзСтроки(Данные);
         
        ДобавитьЛог(СтрШаблон("УстановитьJsonТело: Тело установлено, размер %1", ЗапросТело.Размер()));
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

Функция УстановитьFormТело(Знач Данные) Экспорт
	
	Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
        ОтменитьЗаписьMultipart();
		
		ЗапросТипДанных  = "application/x-www-form-urlencoded; charset=utf-8";
        
        ДобавитьЛог("УстановитьFormТело: Начало установки тела");
         
        OPI_ПреобразованиеТипов.ПолучитьКоллекцию(Данные);
		
		Если ТипЗнч(Данные) = Тип("Массив") Тогда
			
			Данные = Данные[0];
			OPI_ПреобразованиеТипов.ПолучитьСтроку(Данные);
			
		Иначе
		
			Данные = ПараметрыЗапросаВСтроку(Данные);
	        Данные = Прав(Данные, СтрДлина(Данные) - 1);
			
		КонецЕсли;
		
        УстановитьТелоИзСтроки(Данные);
         
        ДобавитьЛог(СтрШаблон("УстановитьFormТело: Тело установлено, размер %1", ЗапросТело.Размер()));
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;

КонецФункции

// Начать запись тела multipart !NOCLI
// Инициализирует запись данных в тело в формате multipart form-data
// 
// Примечание:
// Для дальнейшего формирования тела используются методы `ДобавитьФайлMultipart` и `ДобавитьПолеMultipart`
// 
// Параметры:
//  ИспользоватьФайл - Булево -  Истина > использовать временный файл, Ложь - формирует тело в памяти - file
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция НачатьЗаписьТелаMultipart(ИспользоватьФайл = Истина) Экспорт
    
    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
        Multipart        = Истина;
        Boundary         = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
        РазделительСтрок = Символы.ВК + Символы.ПС;
        ЗапросТипДанных  = "multipart/form-data; boundary=" + Boundary;
        
        Если ИспользоватьФайл Тогда
            
            ДобавитьЛог("НачатьЗаписьТелаMultipart: Создание временного файла");
            
            ЗапросФайлТела     = ПолучитьИмяВременногоФайла();
            ФайлТелаВременный  = Истина;
            ЗапросЗаписьДанных = Новый ЗаписьДанных(ЗапросФайлТела
                , КодировкаТекста.UTF8
                , ПорядокБайтов.LittleEndian
                , ""
                , Ложь
                , ""
                , Ложь);
                           
        Иначе
            
            ДобавитьЛог("НачатьЗаписьТелаMultipart: Создание потока в памяти");
            
            ЗапросПотокТела = Новый ПотокВПамяти();
            
            ЗапросЗаписьДанных = Новый ЗаписьДанных(ЗапросПотокТела
                , КодировкаТекста.UTF8
                , ПорядокБайтов.LittleEndian
                , ""
                , ""
                , Ложь);
                
                                                           
        КонецЕсли;
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
    
КонецФункции

// Добавить файл multipart !NOCLI
// Добавляет блок файла в Multipart тело
// 
// Примечание:
// Запись Multipart предварительно должна быть инициализирована при помощи функции `НачатьЗаписьТелаMultipart`
// 
// Параметры:
//  ИмяПоля   - Строка                 - Имя поля формы               - field
//  ИмяФайла  - Строка                 - Имя файла с расширением      - filename
//  Данные    - ДвоичныеДанные, Строка - Данные файла для записи      - data
//  ТипДанных - Строка                 - Mime тип записываемых данных - mime
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьФайлMultipart(Знач ИмяПоля, Знач ИмяФайла, Знач Данные, Знач ТипДанных = "") Экспорт

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        Если Не Multipart Тогда Возврат Ошибка("ДобавитьФайлMultipart: Не инициализирована запись Multipart") КонецЕсли;
        
        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные);
        
        ДобавитьЛог("ДобавитьФайлMultipart: Запись шапки блока");
        
        Шапка = СтрШаблон("Content-Disposition: form-data; name=""%1""; filename=""%2""", ИмяПоля, ИмяФайла);
        
        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + Boundary + РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(Шапка);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        Если ЗначениеЗаполнено(ТипДанных) Тогда
            ЗапросЗаписьДанных.ЗаписатьСтроку("Content-Type: " + ТипДанных);
        КонецЕсли;

        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        
        ДобавитьЛог("ДобавитьФайлMultipart: Запись данных");
        
        ЗаписатьДвоичныеДанные(ЗапросЗаписьДанных, Данные);
        
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

// Добавить поле multipart !NOCLI
// Добавляет поле формы в Multipart тело
// 
// Примечание:
// Запись Multipart предварительно должна быть инициализирована при помощи функции `НачатьЗаписьТелаMultipart`
// 
// Параметры:
//  ИмяПоля   - Строка       - Имя поля формы     - field
//  Значение  - Произвольный - Значение поля      - data
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьПолеMultipart(Знач ИмяПоля, Знач Значение) Экспорт
 
    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        Если Не Multipart Тогда Возврат Ошибка("ДобавитьПолеMultipart: Не инициализирована запись Multipart") КонецЕсли;
        
        ТипЗначения = ТипЗнч(Значение);
        
        ДобавитьЛог("ДобавитьПолеMultipart: Запись шапки блока");
        
        Шапка       = СтрШаблон("Content-Disposition: form-data; name=""%1""", ИмяПоля);
        
        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + boundary + РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(Шапка);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        ДобавитьЛог("ДобавитьПолеMultipart: Запись данных");
        
        Если ТипЗначения = Тип("Булево") Тогда
            Значение = ?(Значение, "true", "false");
        Иначе 
            OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
        КонецЕсли;

        ЗапросЗаписьДанных.ЗаписатьСтроку(Значение);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

#КонецОбласти

#Область УстановкаЗаголовков

// Установить заголовки !NOCLI
// Устанавливает коллекцию заголовков запросов
// 
// Примечание:
// `ПолнаяЗамена` также очищает заголовки, установленные ранее другими способами (например, заголовки авторизации)
// 
// Параметры:
//  Значение     - Произвольный - Стрктура или соответствие заголовков запрос         - headers
//  ПолнаяЗамена - Булево       - Очищает все существующие заголовки перед установкой - replace 
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьЗаголовки(Знач Значение, Знач ПолнаяЗамена = Ложь) Экспорт

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        Если Не ЗначениеЗаполнено(Значение) Тогда Значение = Новый Соответствие КонецЕсли;
        
        ТекстОшибки = "УстановитьПараметрыURL: Переданные параметры не являются коллекцией ключ/значение";
        OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Значение, ТекстОшибки);
        OPI_ПреобразованиеТипов.ПолучитьБулево(ПолнаяЗамена);
        
        Если ПолнаяЗамена Тогда
            ЗапросЗаголовки = Значение;    
        Иначе
            Для Каждого Заголовок Из Значение Цикл
                ЗапросЗаголовки.Вставить(Заголовок.Ключ, Заголовок.Значение);
            КонецЦикла;
        КонецЕсли;
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

#КонецОбласти

#Область ОбработкаЗапроса

// Обработать запрос !NOCLI
// Создает запрос на основе введенных данных с выполнением или без
// 
// Примечание:
// `ВыполнитьСразу = Ложь` может быть использовано для получения готовых^^
// объектов HTTPЗапрос и HTTPСоединение без их выполнения. См. `ВернутьЗапрос` и `ВернутьСоединение`
// 
// Параметры:
//  Метод          - Строка - HTTP-метод запроса                        - method
//  ВыполнитьСразу - Булево - Выполняет запрос сразу после формирования - run 
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ОбработатьЗапрос(Знач Метод, Знач ВыполнитьСразу = Истина) Экспорт

    Попытка
        
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Метод);
        OPI_ПреобразованиеТипов.ПолучитьБулево(ВыполнитьСразу);
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
        ДобавитьЛог("ОбработатьЗапрос: Формирование запроса");
        Если СформироватьЗапрос().Ошибка Тогда Возврат ЭтотОбъект КонецЕсли;
        
        ДобавитьЛог("ОбработатьЗапрос: Установка тела запроса");
        Если УстановитьТелоЗапроса().Ошибка Тогда Возврат ЭтотОбъект КонецЕсли;
        
        Если ВыполнитьСразу Тогда
            ДобавитьЛог("ОбработатьЗапрос: Выполнение запроса");
            ВызватьМетод(Метод);
		КонецЕсли;
        
        Возврат ЭтотОбъект;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

// Выполнить запрос !NOCLI
// Выполняет запрос, если он был сформирован или установлен ранее
// 
// Параметры:
//  Метод - Строка - HTTP-метод запроса - method
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ВыполнитьЗапрос(Знач Метод) Экспорт

    Попытка
                
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Метод);
        
        ДобавитьЛог("ВыполнитьЗапрос: Выполнение запроса");

        Возврат ВызватьМетод(Метод);
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

// Вернуть запрос !NOCLI
// Возвращает объект текущего HTTP запроса
// 
// Параметры:
//  Принудительно - Булево -  Ложь > Вместо запроса будет возвращен объект обработки, если в ней были ошибки - force
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент, HTTPЗапрос, Неопределено -  Запрос или этот же объект обработки
Функция ВернутьЗапрос(Принудительно = Ложь) Экспорт
    
    Если ОстановитьРаботу() И Не Принудительно Тогда Возврат ЭтотОбъект КонецЕсли;
    
    Возврат Запрос;   
    
КонецФункции

// Вернуть соединение !NOCLI
// Возвращает объект текущего HTTP соединения
// 
// Параметры:
//  Принудительно - Булево -  Ложь > Вместо соединения будет возвращен объект обработки, если в ней были ошибки - force
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент, HTTPСоединение, Неопределено -  Соединение или этот же объект обработки
Функция ВернутьСоединение(Принудительно = Ложь) Экспорт
    
    Если ОстановитьРаботу() И Не Принудительно Тогда Возврат ЭтотОбъект КонецЕсли;
    
    Возврат Соединение;   
         
КонецФункции

#КонецОбласти

#Область ПолучениеОтвета

// Вернуть ответ !NOCLI
// Возвращает объект текущего HTTP ответа
// 
// Параметры:
//  Принудительно - Булево -  Ложь > Вместо ответа будет возвращен объект обработки, если в ней были ошибки - force
// 
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент, HTTPОтвет, Неопределено -  Ответ или этот же объект обработки
Функция ВернутьОтвет(Принудительно = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);
    
    Если ОстановитьРаботу() И Не Принудительно Тогда Возврат ЭтотОбъект КонецЕсли;
    
    Возврат Ответ;   
        
КонецФункции

// Вернуть ответ как JSON коллекцию !NOCLI
// Возвращает тело ответа как коллекцию, полученную из JSON
// 
// Параметры:
//  ВСоответствие - Булево -  Признак использования соответствия вместо структуру - map
// 
// Возвращаемое значение:
//  Произвольный -  Ответ или этот же объект обработки
Функция ВернутьОтветКакJSONКоллекцию(Знач ВСоответствие = Истина) Экспорт

    Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
    
    Попытка
        
        OPI_ПреобразованиеТипов.ПолучитьБулево(ВСоответствие);
        
        ТелоJSON = ПолучитьТелоОтвета();
		
		Попытка
			
			СтрокаJSON = ПолучитьСтрокуИзДвоичныхДанных(ТелоJSON);
			
			Если ЗначениеЗаполнено(СтрокаJSON) Тогда
	        	JSON = OPI_Инструменты.JsonВСтруктуру(ТелоJSON, ВСоответствие);
			Иначе
				JSON = Новый Соответствие;
			КонецЕсли;
			
		Исключение
			
			JSON = ТелоJSON;
			
		КонецПопытки;
    
        Возврат JSON;
    
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
          
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область HTTP
    
Функция ПреобразоватьПараметрВСтроку(Знач Значение)

    Если ТипЗнч(Значение) = Тип("Массив") Тогда

        Для Н = 0 По Значение.ВГраница() Цикл
            Значение[Н] = ПреобразоватьПараметрВСтроку(Значение[Н]);
        КонецЦикла;

        Значение = СтрСоединить(Значение, ",");
        Значение = КодироватьСтроку(Значение, СпособКодированияСтроки.URLВКодировкеURL);
        Значение = "[" + Значение + "]";

    ИначеЕсли ТипЗнч(Значение) = Тип("Соответствие") Или ТипЗнч(Значение) = Тип("Структура") Тогда

        ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет, "");

        ЗаписьJSON = Новый ЗаписьJSON;
        ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);

        ЗаписатьJSON(ЗаписьJSON, Значение);
        Значение = ЗаписьJSON.Закрыть();

    ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда

        Значение = ?(Значение, "true", "false");

    Иначе

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
        Значение = КодироватьСтроку(Значение, СпособКодированияСтроки.URLВКодировкеURL);

    КонецЕсли;

    Возврат Значение;

КонецФункции

Функция УстановитьТелоИзДвоичныхДанных(Знач Значение)

    OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Значение);
    ЗапросТело = Значение;
    
    Возврат ЭтотОбъект;
        
КонецФункции

Функция УстановитьТелоИзСтроки(Знач Значение, Знач Кодировка = "UTF-8", Знач ЗаписатьBOM = Ложь)
    
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Кодировка);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
    OPI_ПреобразованиеТипов.ПолучитьБулево(ЗаписатьBOM);
    
    ЗапросТело = ПолучитьДвоичныеДанныеИзСтроки(Значение, Кодировка, ЗаписатьBOM);
    
    Возврат ЭтотОбъект;
    
КонецФункции

Функция РазбитьURL()

    URL = ЗапросURL;

    ЗапросЗащищенное = Не СтрНачинаетсяС(ЗапросURL, "http://");

    URL = СтрЗаменить(URL, "https://", "");
    URL = СтрЗаменить(URL, "http://" , "");

    Если СтрНайти(URL, "/") = 0 Тогда
        ЗапросАдрес = "";
        ЗапросДомен = URL;
    Иначе
        ЗапросАдрес = Прав(URL, СтрДлина(URL) - СтрНайти(URL, "/", НаправлениеПоиска.СНачала) + 1);
        ЗапросДомен = Лев(URL, СтрНайти(URL, "/", НаправлениеПоиска.СНачала) - 1);
    КонецЕсли;

    Если СтрНайти(ЗапросДомен, ":") <> 0 Тогда

        ХостПорт = СтрРазделить(ЗапросДомен, ":");
        ЗапросДомен    = ХостПорт[0];
        ЗапросПорт     = ХостПорт[1];

        OPI_ПреобразованиеТипов.ПолучитьЧисло(ЗапросПорт);

    Иначе

        ЗапросПорт = ?(ЗапросЗащищенное, 443, 80);

    КонецЕсли;

    Если OPI_Инструменты.ЭтоOneScript() И ЗапросЗащищенное Тогда
        ЗапросСервер = "https://" + ЗапросДомен;
    Иначе
        ЗапросСервер = ЗапросДомен;
    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция СформироватьЗапрос()
   
    Если Не ЗначениеЗаполнено(ЗапросURL) Тогда
        Возврат Ошибка("Не установлен URL");
    КонецЕсли;
        
    ДобавитьЛог("СформироватьЗапрос: Добавление параметров");
    ЗапросАдрес = ЗапросАдрес + ПараметрыЗапросаВСтроку(ЗапросПараметрыURL);
    
    ДобавитьЛог("СформироватьЗапрос: Создание объекта запроса");   
    СоздатьЗапрос();
    
    ДобавитьЛог("СформироватьЗапрос: Создание объекта соединения");
    СоздатьСоединение();
	
	Возврат ЭтотОбъект;
 
КонецФункции

Функция СоздатьЗапрос()

    Заголовки = ПолучитьСтандартныеЗаголовки();
    
    Если ТипЗнч(ЗапросЗаголовки) = Тип("Соответствие") Тогда

        Для Каждого Заголовок Из ЗапросЗаголовки Цикл
            Заголовки.Вставить(Заголовок.Ключ, Заголовок.Значение);
        КонецЦикла;

    КонецЕсли;

    Запрос = Новый HTTPЗапрос(ЗапросАдрес, Заголовки);

    Возврат ЭтотОбъект;

КонецФункции

Функция СоздатьСоединение()

    Если Не ЗначениеЗаполнено(ЗапросПорт) Тогда
        ЗапросПорт = ?(ЗапросЗащищенное, 443, 80);
    КонецЕсли;

    Если ЗапросЗащищенное Тогда

        Если OPI_Инструменты.ЭтоOneScript() Тогда
                     
            Соединение = Новый HTTPСоединение(ЗапросСервер
                , ЗапросПорт
                , ЗапросПользователь
                , ЗапросПароль
                , ЗапросПрокси
                , ЗапросТаймаут);
                
        Иначе
            
            SSL        = Новый ЗащищенноеСоединениеOpenSSL;
            Соединение = Новый HTTPСоединение(ЗапросСервер
            , ЗапросПорт
            , ЗапросПользователь
            , ЗапросПароль
            , ЗапросПрокси
            , ЗапросТаймаут
            , SSL);
        
        КонецЕсли;

    Иначе

        Соединение = Новый HTTPСоединение(ЗапросСервер
            , ЗапросПорт
            , ЗапросПользователь
            , ЗапросПароль
            , ЗапросПрокси
            , ЗапросТаймаут);

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция ПараметрыЗапросаВСтроку(Знач Параметры, Знач Начало = Истина)

    Если Параметры.Количество() = 0 Тогда
        Возврат "";
    КонецЕсли;

    СтрокаПараметров = ?(Начало, "?", "&");

    Для Каждого Параметр Из Параметры Цикл

        ТекущееЗначение = Параметр.Значение;
        ТекущийКлюч     = Параметр.Ключ;

        Если Не ТипЗнч(ТекущееЗначение) = Тип("Массив") Или Не ПолучитьНастройку("ОтдельныеЭлементыМассивов") Тогда

            ЗначениеПараметра = ПреобразоватьПараметрВСтроку(ТекущееЗначение);

            СтрокаПараметров = СтрокаПараметров + Параметр.Ключ + "=" + ЗначениеПараметра + "&";

        Иначе

            ЗначениеПараметра = РазделитьМассивНаПараметрыURL(ТекущийКлюч, ТекущееЗначение);
            СтрокаПараметров  = СтрокаПараметров + ЗначениеПараметра + "&";

        КонецЕсли;

    КонецЦикла;

    СтрокаПараметров = Лев(СтрокаПараметров, СтрДлина(СтрокаПараметров) - 1);

    Возврат СтрокаПараметров;

КонецФункции

Функция РазделитьМассивНаПараметрыURL(Знач Ключ, Знач Значение)

    КлючМассив = Ключ + "=";

    Для Н = 0 По Значение.ВГраница() Цикл

        ТекущееЗначение = Значение[Н];

        OPI_ПреобразованиеТипов.ПолучитьСтроку(ТекущееЗначение);

        Значение.Установить(Н, КлючМассив + ТекущееЗначение);

    КонецЦикла;

    ПараметрСтрокой = СтрСоединить(Значение, "&");

    Возврат ПараметрСтрокой;

КонецФункции

Функция ПолучитьСтандартныеЗаголовки()

    Заголовки = Новый Соответствие;
	
	Заголовки.Вставить("Accept"         , "*/*");
    Заголовки.Вставить("Connection"     , "keep-alive");
    Заголовки.Вставить("Accept-Charset" , "utf-8");
    
    Если ПолучитьНастройку("gzip") Тогда
        Заголовки.Вставить("Accept-Encoding", "gzip");
    КонецЕсли;
    
    Если ЗначениеЗаполнено(ЗапросТипДанных) Тогда
        Заголовки.Вставить("Content-Type", ЗапросТипДанных);       
    КонецЕсли;
    
    Возврат Заголовки;
        
КонецФункции

Функция УстановитьТелоЗапроса()

    Если Multipart Тогда       
        ЗвершитьЗаписьMultipart();
    КонецЕсли;

    Если ЗначениеЗаполнено(ЗапросФайлТела) Тогда
        Запрос.УстановитьИмяФайлаТела(ЗапросФайлТела);
	Иначе
		
		Если ТипЗнч(ЗапросТело) = Тип("ДвоичныеДанные") Тогда			
        	Запрос.УстановитьТелоИзДвоичныхДанных(ЗапросТело);
		КонецЕсли;
		
    КонецЕсли;
    
    Возврат ЭтотОбъект;
        
КонецФункции

Функция ВызватьМетод(Знач Метод)
	
    Если ЗначениеЗаполнено(ЗапросВыходнойФайл) Тогда
        Ответ = Соединение.ВызватьHTTPМетод(Метод, Запрос, ЗапросВыходнойФайл);
    Иначе
        Ответ = Соединение.ВызватьHTTPМетод(Метод, Запрос);
    КонецЕсли;

    Если ЭтоПереадресация(Ответ) Тогда

        URL = Ответ.Заголовки["Location"];
		УстановитьURL(URL);
		
		ОбработатьЗапрос(Метод);
		
	КонецЕсли;
	
	Возврат ЭтотОбъект;
	
КонецФункции

Функция ПолучитьТелоОтвета()
	
	GZip = "gzip";

	Заголовок1 = Ответ.Заголовки.Получить("Content-Encoding");
	Заголовок2 = Ответ.Заголовки.Получить("content-encoding");
	
    НужнаРаспаковка = Заголовок1 = GZip Или Заголовок2 = GZip;

    Если НужнаРаспаковка Тогда
        Данные = РаспаковатьОтвет(Ответ);
	Иначе
		Данные = Ответ.ПолучитьТелоКакДвоичныеДанные();
	КонецЕсли;
	
	Данные = ?(ТипЗнч(Данные) = Тип("HTTPОтвет"), Данные.ПолучитьТелоКакДвоичныеДанные(), Данные);

	Если ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда

	    Если Данные.Размер() = 0 Тогда
	        Данные = ПолучитьДвоичныеДанныеИзСтроки("");
	    КонецЕсли;

	Иначе
		OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные);
	КонецЕсли;
	
	Возврат Данные;

КонецФункции

Функция ЭтоПереадресация(Знач Ответ)

    Переадресация = 300;
    ОшибкаЗапроса = 400;

    ЭтоПереадресация = Ответ.КодСостояния >= Переадресация И Ответ.КодСостояния < ОшибкаЗапроса И ЗначениеЗаполнено(
        Ответ.Заголовки["Location"]);

    Возврат ЭтоПереадресация;

КонецФункции

Процедура ОтменитьЗаписьMultipart()

    Если Multipart Тогда
    
        ДобавитьЛог("ОтменитьЗаписьMultipart: Удаление записанных данных");
        Multipart = Ложь;
        
       Попытка
            ЗапросЗаписьДанных.Закрыть();
        Исключение
            ДобавитьЛог("ОтменитьЗаписьMultipart: Не удалось закрыть запись. Возможно, она уже была закрыта");               
        КонецПопытки;
        
        Если ЗначениеЗаполнено(ЗапросФайлТела) Тогда
                        
            Попытка
                
                УдалитьФайлы(ЗапросФайлТела);
                ДобавитьЛог("ОтменитьЗаписьMultipart: Файл тела удален");
                
            Исключение
                ДобавитьЛог("ОтменитьЗаписьMultipart: Не удалось удалить файл тела. Возможно, он уже был удален");
            КонецПопытки;
            
        Иначе
            
            Если ТипЗнч(ЗапросПотокТела) = Тип("ПотокВПамяти") Тогда
                
                Попытка
                    ЗапросПотокТела.Закрыть();
                Исключение
                    ДобавитьЛог("ОтменитьЗаписьMultipart: Не удалось закрыть поток. Возможно, он уже был закрыт");
                КонецПопытки;
                
            КонецЕсли;
            
        КонецЕсли;
        
        ЗапросЗаписьДанных = Неопределено;
        ЗапросФайлТела     = Неопределено;
        
    КонецЕсли;    
    
КонецПроцедуры

Процедура ЗаписатьДвоичныеДанные(ЗаписьДанных, Знач ДвоичныеДанные)

    РазмерЧасти    = 268435456;
    ПрочитанноБайт = 0;
    ТекущаяПозиция = 0;
    ОбщийРазмер    = ДвоичныеДанные.Размер();

    Пока ПрочитанноБайт < ОбщийРазмер Цикл

        ЧтениеДанных   = Новый ЧтениеДанных(ДвоичныеДанные);
        ПрочитанноБайт = ЧтениеДанных.Пропустить(ТекущаяПозиция);
        Результат      = ЧтениеДанных.Прочитать(РазмерЧасти);
        ТекущиеДанные  = Результат.ПолучитьДвоичныеДанные();
        РазмерТекущих  = ТекущиеДанные.Размер();

        Если Не ЗначениеЗаполнено(ТекущиеДанные) Тогда
            Прервать;
        КонецЕсли;

        ЗаписьДанных.Записать(ТекущиеДанные);

        // !OInt ОсвободитьОбъект(ТекущиеДанные);
        // !OInt ВыполнитьСборкуМусора();

        ТекущаяПозиция = ТекущаяПозиция + РазмерТекущих;

    КонецЦикла;

КонецПроцедуры

Процедура ЗвершитьЗаписьMultipart()
    
	Попытка
		ЗапросЗаписьДанных.ЗаписатьСтроку("--" + Boundary + "--" + РазделительСтрок);
        ЗапросЗаписьДанных.Закрыть();
    Исключение
        ДобавитьЛог("ЗвершитьЗаписьMultipart: Не удалось закрыть запись. Возможно, она уже была закрыта");               
    КонецПопытки;

    Если ТипЗнч(ЗапросПотокТела) = Тип("ПотокВПамяти") Тогда
        ЗапросТело = ЗапросПотокТела.ЗакрытьИПолучитьДвоичныеДанные();
    КонецЕсли;
        
КонецПроцедуры

#КонецОбласти

#Область GZip

// Описание структур см. здесь https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
// Источник: https://github.com/vbondarevsky/Connector

// Коннектор: удобный HTTP-клиент для 1С:Предприятие 8
//
// Copyright 2017-2023 Vladimir Bondarevskiy
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//
// URL:    https://github.com/vbondarevsky/Connector
// e-mail: vbondarevsky@gmail.com
// Версия: 2.4.8
//
// Требования: платформа 1С версии 8.3.10 и выше

Функция РаспаковатьОтвет(Ответ)

    Попытка
        Возврат ПрочитатьGZip(Ответ.ПолучитьТелоКакДвоичныеДанные());
    Исключение
        Возврат Ответ;
    КонецПопытки;

КонецФункции

Функция ПрочитатьGZip(СжатыеДанные) Экспорт

    РазмерПрефиксаGZip  = 10;
    РазмерПостфиксаGZip = 8;

    РазмерДД  = ZipРазмерDD();
    РазмерСДХ = ZipРазмерCDH();
    РазмерЕСД = ZipРазмерEOCD();
    РазмерЛФХ = ZipРазмерLFH();

    ЧтениеДанных       = Новый ЧтениеДанных(СжатыеДанные);
    ЧтениеДанных.Пропустить(РазмерПрефиксаGZip);
    РазмерСжатыхДанных = ЧтениеДанных.ИсходныйПоток().Размер() - РазмерПрефиксаGZip - РазмерПостфиксаGZip;

    ПотокZip = Новый ПотокВПамяти(РазмерЛФХ + РазмерСжатыхДанных + РазмерДД + РазмерСДХ + РазмерЕСД);

    ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipLFH());
    ЧтениеДанных.КопироватьВ(ЗаписьДанных, РазмерСжатыхДанных);

    ЗаписьДанных.Закрыть();
    ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);

    CRC32                = ЧтениеДанных.ПрочитатьЦелое32();
    РазмерНесжатыхДанных = ЧтениеДанных.ПрочитатьЦелое32();
    ЧтениеДанных.Закрыть();

    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipDD(CRC32 , РазмерСжатыхДанных, РазмерНесжатыхДанных));
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipEOCD(РазмерСжатыхДанных));
    ЗаписьДанных.Закрыть();

    Возврат ПрочитатьZip(ПотокZip);

КонецФункции

Функция ПрочитатьZip(СжатыеДанные, ТекстОшибки = Неопределено)

    Каталог         = ПолучитьИмяВременногоФайла();
    ЧтениеZip       = Новый ЧтениеZipФайла(СжатыеДанные);
    ИмяФайла        = ЧтениеZip.Элементы[0].Имя;
    Попытка
        ЧтениеZip.Извлечь(ЧтениеZip.Элементы[0], Каталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
    Исключение
        // Игнорируем проверку целостности архива, просто читаем результат
        ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
    КонецПопытки;
    ЧтениеZip.Закрыть();

    Результат = Новый ДвоичныеДанные(Каталог + ПолучитьРазделительПути() + ИмяФайла);
    УдалитьФайлы(Каталог);

    Возврат Результат;

КонецФункции

Функция ZipРазмерLFH()

    Возврат 34;

КонецФункции

Функция ZipРазмерDD()

    Возврат 16;

КонецФункции

Функция ZipРазмерCDH()

    Возврат 50;

КонецФункции

Функция ZipРазмерEOCD()

    Возврат 22;

КонецФункции

Функция ZipLFH()

    // Local file header
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерLFH());
    Буфер.ЗаписатьЦелое32(0, 67324752); // signature 0x04034b50
    Буфер.ЗаписатьЦелое16(4, 20);       // version
    Буфер.ЗаписатьЦелое16(6, 10);       // bit flags
    Буфер.ЗаписатьЦелое16(8, 8);        // compression method
    Буфер.ЗаписатьЦелое16(10, 0);       // time
    Буфер.ЗаписатьЦелое16(12, 0);       // date
    Буфер.ЗаписатьЦелое32(14, 0);       // crc-32
    Буфер.ЗаписатьЦелое32(18, 0);       // compressed size
    Буфер.ЗаписатьЦелое32(22, 0);       // uncompressed size
    Буфер.ЗаписатьЦелое16(26, 4);       // filename legth - "data"
    Буфер.ЗаписатьЦелое16(28, 0);       // extra field length
    Буфер.Записать(30, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));

    Возврат Буфер;

КонецФункции

Функция ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

    // Data descriptor
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерDD());
    Буфер.ЗаписатьЦелое32(0, 134695760);
    Буфер.ЗаписатьЦелое32(4, CRC32);
    Буфер.ЗаписатьЦелое32(8, РазмерСжатыхДанных);
    Буфер.ЗаписатьЦелое32(12, РазмерНесжатыхДанных);

    Возврат Буфер;

КонецФункции

Функция ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

    // Central directory header
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерCDH());
    Буфер.ЗаписатьЦелое32(0, 33639248);              // signature 0x02014b50
    Буфер.ЗаписатьЦелое16(4, 798);                   // version made by
    Буфер.ЗаписатьЦелое16(6, 20);                    // version needed to extract
    Буфер.ЗаписатьЦелое16(8, 10);                    // bit flags
    Буфер.ЗаписатьЦелое16(10, 8);                    // compression method
    Буфер.ЗаписатьЦелое16(12, 0);                    // time
    Буфер.ЗаписатьЦелое16(14, 0);                    // date
    Буфер.ЗаписатьЦелое32(16, CRC32);                // crc-32
    Буфер.ЗаписатьЦелое32(20, РазмерСжатыхДанных);   // compressed size
    Буфер.ЗаписатьЦелое32(24, РазмерНесжатыхДанных); // uncompressed size
    Буфер.ЗаписатьЦелое16(28, 4);                    // file name length
    Буфер.ЗаписатьЦелое16(30, 0);                    // extra field length
    Буфер.ЗаписатьЦелое16(32, 0);                    // file comment length
    Буфер.ЗаписатьЦелое16(34, 0);                    // disk number start
    Буфер.ЗаписатьЦелое16(36, 0);                    // internal file attributes
    Буфер.ЗаписатьЦелое32(38, 2176057344);           // external file attributes
    Буфер.ЗаписатьЦелое32(42, 0);                    // relative offset of local header
    Буфер.Записать(46, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));

    Возврат Буфер;

КонецФункции

Функция ZipEOCD(РазмерСжатыхДанных)

    // End of central directory
    РазмерCDH = 50;
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерEOCD());
    Буфер.ЗаписатьЦелое32(0, 101010256); // signature 0x06054b50
    Буфер.ЗаписатьЦелое16(4, 0); // number of this disk
    Буфер.ЗаписатьЦелое16(6, 0); // number of the disk with the start of the central directory
    Буфер.ЗаписатьЦелое16(8, 1); // total number of entries in the central directory on this disk
    Буфер.ЗаписатьЦелое16(10, 1); // total number of entries in the central directory
    Буфер.ЗаписатьЦелое32(12, РазмерCDH); // size of the central directory
    // offset of start of central directory with respect to the starting disk number
    Буфер.ЗаписатьЦелое32(16, ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD());
    Буфер.ЗаписатьЦелое16(20, 0); // the starting disk number

    Возврат Буфер;

КонецФункции

#КонецОбласти

#Область Вспомогательные

Функция ОстановитьРаботу()
    
    Возврат ЗапросИнициализирован().Ошибка;
    
КонецФункции

Функция ЗапросИнициализирован()
    
    Возврат ?(ЗначениеЗаполнено(Инициализирован)
        , ЭтотОбъект
        , Ошибка("Запрос не инициализирован. Необходимо вызвать функцию Инициализировать() перед началом работы"));
        
КонецФункции

Функция Ошибка(Знач ТекстОшибки)
      
    Ошибка = Истина;
    
    Если ФайлТелаВременный И ЗначениеЗаполнено(ЗапросФайлТела) Тогда
        
        Попытка
            УдалитьФайлы(ЗапросФайлТела);
            ЗапросФайлТела    = Неопределено;
            ФайлТелаВременный = Ложь;
        Исключение
            ДобавитьЛог("Ошибка: Не удалось удалить временный файл при исключении");                
        КонецПопытки;
        
    КонецЕсли;
    
    Возврат ДобавитьЛог(ТекстОшибки);
     
КонецФункции

Функция ДобавитьЛог(Знач Текст)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Текст);
    
    Лог.Добавить(Текст);
    
    Возврат ЭтотОбъект;
        
КонецФункции

Функция ПолучитьНастройку(Знач КлючНастройки)
    Возврат Настройки[КлючНастройки];    
КонецФункции

Процедура УстановитьСтандартныеНастройки()
    
    Настройки = Новый Структура;
    Настройки.Вставить("gzip", Истина);
    Настройки.Вставить("ОтдельныеЭлементыМассивов", Ложь);
    
КонецПроцедуры

Функция ШаблонФункции()

    Попытка
        
        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект КонецЕсли;
        
    Исключение           
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   
    КонецПопытки;
        
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецЕсли