// OneScript: ./OInt/tools/Modules/internal/Classes/OPI_HTTPКлиент.os
// Lib: HTTP-клиент
// CLI: none
// Keywords: http, https

// MIT License

// Copyright (c) 2023-2025 Anton Tsitavets

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// https://github.com/Bayselonarrend/OpenIntegrations

// BSLLS:Typo-off
// BSLLS:LatinAndCyrillicSymbolInWord-off
// BSLLS:IncorrectLineBreak-off
// BSLLS:NumberOfOptionalParams-off
// BSLLS:UsingServiceTag-off
// BSLLS:LineLength-off
// BSLLS:ExportVariables-off
// BSLLS:OneStatementPerLine-off
// BSLLS:MagicNumber-off

//@skip-check module-structure-top-region
//@skip-check module-structure-method-in-regions
//@skip-check wrong-string-literal-content
//@skip-check method-too-many-params
//@skip-check constructor-function-return-section
//@skip-check doc-comment-collection-item-type
//@skip-check object-module-export-variable

#Если Не Клиент Тогда

#Область ОписаниеПеременных

// Обработка

Перем Инициализирован; // Признак, что обязательная функция Инициализировать() была вызвана
Перем Ошибка Экспорт;  // Признак ошибки выполнения для пропуска оставшихся действий в цепочке
Перем Лог;             // Массив сообщений о действиях внутри обработки

// Запрос

Перем Запрос;     // Объект HTTPЗапрос
Перем Соединение; // Объект HTTPСоединение
Перем Настройки;  // Структура дополнительных настроек
Перем Повторов;   // Число повторов при ошибке в комплексных запросах

Перем ЗапросURL;          // URL запроса
Перем ЗапросСервер;       // Сервер из URL запроса
Перем ЗапросПорт;         // Порт из URL запроса или по умолчанию
Перем ЗапросАдрес;        // Путь из URL запроса
Перем ЗапросАдресПолный;  // Путь с параметрами и секцией из URL запроса
Перем ЗапросСекция;       // Секция в URL, если присутствует
Перем ЗапросЗащищенное;   // Признак использования HTTPS
Перем ЗапросДомен;        // Домен из URL запроса

Перем ЗапросМетод;                 // Используемый метод HTTP
Перем ЗапросПараметрыURL;          // Структура параметров URL
Перем ЗапросТело;                  // Данные тела запроса
Перем ЗапросТелоКоллекция;         // Данные тела в виде коллекции, если возможно
Перем ЗапросТелоТекущейОтправки;   // Часть данных общего тела для текущей отправки
Перем ЗапросЗаголовки;             // Соответствие заголовков запроса
Перем ЗапросПользователь;          // Пользователь для базовой авторизации
Перем ЗапросПароль;                // Пароль для базовой авторизации
Перем ЗапросТаймаут;               // Таймаут запроса
Перем ЗапросПрокси;                // Настройки прокси запроса
Перем ЗапросВыходнойФайл;          // Путь к файлу для сохранения результата запроса
Перем ЗапросФайлТела;              // Путь к файлу с телом запроса
Перем ЗапросПотокТела;             // Поток тела запроса
Перем ЗапросПотокЧтенияТела;       // Поток чтения двоичных данных тела
Перем ЗапросЗаписьДанных;          // Запись данных тела запроса
Перем ЗапросЧтениеДанных;          // Чтение данных тела запроса
Перем ЗапросТипДанных;             // MIME тип для Content-Type
Перем ЗапросТипУстановленВручную;  // Признак отключения автоматического определения Content-Type
Перем ЗапросРазмерЧасти;           // Размер части для загрузки по частям
Перем ФайлТелаВременный;           // Признак удаления файла тела, если он был создан автоматически

// Авторизация

Перем AuthВид;     // Вид авторизации
Перем AuthДанные;  // Структура учетных данных

// Ответ

Перем Ответ;             // Объект HTTPОтвет
Перем ОтветКодСостояния; // Код состояния ответа
Перем ОтветЗаголовки;    // Соответствие заголовков ответа

// Multipart

Перем Multipart;        // Признак установки тела в формате Multipart
Перем Boundary;         // Boundary для разделения частей тела
Перем РазделительСтрок; // Разделитель строк тела

#КонецОбласти

#Область ПрограммныйИнтерфейс

#Область Инициализация

// Инициализировать !NOCLI
// Инициализирует новый пустой запрос
//
// Примечание:
// Функция обязательная для вызова первой при создании нового объекта обработки
// URL может быть установлен позднее при помощи функции `УстановитьURL`
//
// Параметры:
//  URL - Строка - URL адрес для запроса - url
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция Инициализировать(Знач URL = "") Экспорт

    Лог = Новый Массив;

    ДобавитьЛог("Инициализировать: установка стандартных значений");

    Инициализирован = Истина;
    Ошибка          = Ложь;

    ЗапросПараметрыURL  = Новый Структура;
    ЗапросТело          = Неопределено;
    ЗапросТелоКоллекция = Новый Структура;
    ЗапросЗаголовки     = Новый Соответствие;
    ЗапросТаймаут       = 3600;
    ЗапросРазмерЧасти   = 5242880;
    Повторов            = 0;

    ЗапросТипУстановленВручную = Ложь;

    ФайлТелаВременный = Ложь;

    ОтветКодСостояния = 0;
    ОтветТело         = Неопределено;
    ОтветЗаголовки    = Новый Соответствие;

    Multipart = Ложь;

    УстановитьСтандартныеНастройки();
    УстановитьURL(URL);

    Возврат ЭтотОбъект;

КонецФункции

// Установить URL !NOCLI
// Устанавливает новый URL запроса
//
// Параметры:
//  URL - Строка -  URL запроса - url
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьURL(Знач URL) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Если ЗначениеЗаполнено(URL) Тогда

            ДобавитьЛог("УстановитьURL: установка значения");

            OPI_ПреобразованиеТипов.ПолучитьСтроку(URL);
            OPI_Инструменты.ВернутьУправляющиеПоследовательности(URL);

            Если ПолучитьНастройку("КодировкаURL") Тогда
                КодироватьURLВURL(URL);
            КонецЕсли;

            ЗапросURL = URL;

        Иначе

            ДобавитьЛог("УстановитьURL: URL пуст - пропуск");

        КонецЕсли;

        Возврат РазбитьURL();

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить параметры URL !NOCLI
// Устанавливает коллекцию параметров URL
//
// Параметры:
//  Значение - Произвольный - Стрктура или соответствие параметров URL - params
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьПараметрыURL(Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не ЗначениеЗаполнено(Значение) Тогда Значение = Новый Структура; КонецЕсли;

        ДобавитьЛог("УстановитьПараметрыURL: установка параметров");

        ТекстОшибки = "УстановитьПараметрыURL: переданные параметры не являются коллекцией ключ/значение";
        OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Значение, ТекстОшибки);

        ЗапросПараметрыURL = OPI_Инструменты.КопироватьКоллекцию(Значение);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить файл ответа !NOCLI
// Устанавливает путь к файлу для сохранения результата запроса
//
// Параметры:
//  Значение - Строка - Путь к файлу - filepath
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьФайлОтвета(Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Если Не ЗначениеЗаполнено(Значение) Тогда
            ЗапросВыходнойФайл = Неопределено;
            ДобавитьЛог("УстановитьФайлОтвета: файл ответа не указан - пропуск");
            Возврат ЭтотОбъект;
        КонецЕсли;

        ДобавитьЛог("УстановитьФайлОтвета: установка значения");

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
        ЗапросВыходнойФайл = Значение;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить тип данных !NOCLI
// Устанавливает Content-Type запроса
//
// Примечание:
// Если тип данных не установлен вручную, то он будет подобран в процессе установки тела запроса
//
// Параметры:
//  Значение - Строка - Значение заголовка ContentType - type
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьТипДанных(Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("УстановитьТипДанных: установка значения");
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);

        ЗапросТипДанных            = Значение;
        ЗапросТипУстановленВручную = Истина;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить прокси !NOCLI
// Устанавливает настройки прокси для соединения
//
// Параметры:
//  Настройки - ИнтернетПрокси - Настройки прокси - proxy
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьПрокси(Знач Настройки) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Если ТипЗнч(Настройки) = Тип("ИнтернетПрокси") Тогда

            ДобавитьЛог("УстановитьПрокси: установка значения");
            ЗапросПрокси = Настройки;

        Иначе
            Ошибка("УстановитьПрокси: переданные настройки не являются объектом типа ИнтернетПрокси");
        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить таймаут !NOCLI
// Устанавливает таймаут соединения
//
// Примечание:
// Таймаут по умолчанию равен 3600 секунд
//
// Параметры:
//  Значение - Число - Таймаут соединения - value
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьТаймаут(Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьЧисло(Значение);

        Если Значение = 0 Тогда
            ДобавитьЛог("УстановитьТаймаут: переданно некорректное значение, таймаут не изменен");
        Иначе
            ДобавитьЛог("УстановитьТаймаут: установка значения");
            ЗапросТаймаут = Значение;
        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Получить лог !NOCLI
// Получает лог выполнения
//
// Параметры:
//  Строкой - Булево - Возврат лога в виде строки - string
//
// Возвращаемое значение:
//  Строка, Массив - Лог выполнения
Функция ПолучитьЛог(Знач Строкой = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Строкой);

    Если Не ЗначениеЗаполнено(Лог) Тогда
        Возврат ?(Строкой, ""              , Новый Массив);
    Иначе
        Возврат ?(Строкой, СтрСоединить(Лог, Символы.ПС), Лог);
    КонецЕсли;

КонецФункции

#КонецОбласти

#Область Настройки

// Использовать кодировку !NOCLI
// Устанавливает кодировку тела запроса
//
// Примечание:
// По умолчанию используется UTF-8
//
// Параметры:
//  Кодировка - Строка - Название кодировки - enc
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ИспользоватьКодировку(Знач Кодировка) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("ИспользоватьКодировку: установка значения");
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Кодировка);

        УстановитьНастройку("КодировкаТелаЗапроса", Кодировка);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Использовать сжатие gzip !NOCLI
// Включает или отключает заголовок получения данных от сервера в сжатом виде
//
// Примечание:
// По умлчанию ответ от сервера запрашивается со сжатием gzip
//
// Параметры:
//  Флаг - Булево - Признак использования gzip - gzip
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ИспользоватьСжатиеGzip(Знач Флаг) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("ИспользоватьСжатиеGzip: установка значения");
        OPI_ПреобразованиеТипов.ПолучитьБулево(Флаг);

        УстановитьНастройку("gzip", Флаг);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Использовать поля тела в OAuth !NOCLI
// Включает или исключает поля тела при расчете подписи OAuth в зависимости от требований сервера
//
// Примечание:
// По умолчанию данные тела используются при расчете подписи, если оно было установлено при помощи функции `УстановитьFormТело`
//
// Параметры:
//  Флаг - Булево - Признак использования полей тела в расчете подписи OAuth - use
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ИспользоватьПоляТелаВOAuth(Знач Флаг) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("ИспользоватьПоляТелаВOAuth: установка значения");
        OPI_ПреобразованиеТипов.ПолучитьБулево(Флаг);

        УстановитьНастройку("ПоляТелаВOAuth", Флаг);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Использовать кодирование URL !NOCLI
// Включает или отключает стандартное кодирование спец. символов в URL
//
// Примечание:
// По умолчанию кодирование URL включено
//
// Параметры:
//  Флаг - Булево - Признак использования кодирования URL - enc
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ИспользоватьКодированиеURL(Знач Флаг) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("ИспользоватьКодированиеURL: установка значения");
        OPI_ПреобразованиеТипов.ПолучитьБулево(Флаг);

        УстановитьНастройку("КодировкаURL", Флаг);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Разделять массивы в URL !NOCLI
// Определяет представление массивов в параметрах URL: как цельный JSON массив или отдельные параметры для каждого элемента
//
// Примечание:
// По умолчанию массивы интерпретируются как единый параметр с JSON массивом в значении
// По умолчанию квадратные скобки к ключам параметров при разделении массива не устанавливаются
//
// Параметры:
//  Флаг             - Булево - Признак деления массива на отдельные параметры URL                             - split
//  КвадратныеСкобки - Булево - Добавлять к ключам пустые скобки в стиле PHP (key[]=value), если Флаг = Истина - php
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция РазделятьМассивыВURL(Знач Флаг, Знач КвадратныеСкобки = Неопределено) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("РазделятьМассивыВURL: установка значения");
        OPI_ПреобразованиеТипов.ПолучитьБулево(Флаг);

        Если КвадратныеСкобки <> Неопределено Тогда

            ДобавитьЛог("РазделятьМассивыВURL: установка настройки использованя квадратных скобок");
            OPI_ПреобразованиеТипов.ПолучитьБулево(КвадратныеСкобки);

            УстановитьНастройку("КвадратныеСкобкиМассивов", КвадратныеСкобки);

        КонецЕсли;

        УстановитьНастройку("ОтдельныеЭлементыМассивов", Флаг);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

#КонецОбласти

#Область УстановкаТела

// Установить двоичное тело !NOCLI
// Устанавливает тело запрос из двоичных данных, файла или строки (с преобразованием в двоичные данные)
//
// Параметры:
//  Данные              - Строка, ДвоичныеДанные - Файл, строка или данные тела запроса               - data
//  УстанавливатьПустое - Булево                 - Устанавливает тело даже при передаче пустых данных - empty
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьДвоичноеТело(Знач Данные, Знач УстанавливатьПустое = Ложь) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ОтменитьЗаписьMultipart();

        Если Не ЗапросТипУстановленВручную Тогда
            ЗапросТипДанных = "application/octet-stream";
        КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные, Истина, Ложь);
        OPI_ПреобразованиеТипов.ПолучитьБулево(УстанавливатьПустое);

        Данные     = ?(Данные = Неопределено, ПолучитьДвоичныеДанныеИзСтроки(""), Данные);
        ЕстьДанные = Данные.Размер() > 0;

        Если ЕстьДанные Или УстанавливатьПустое Тогда

            Если Не ЕстьДанные Тогда
                Данные = ПолучитьДвоичныеДанныеИзСтроки("");
            КонецЕсли;

            ДобавитьЛог("УстановитьДвоичноеТело: начало установки тела");
            УстановитьТелоИзДвоичныхДанных(Данные);
            ДобавитьЛог(СтрШаблон("УстановитьДвоичноеТело: тело установлено, размер %1", ЗапросТело.Размер()));

        Иначе
            ДобавитьЛог("УстановитьДвоичноеТело: передано пустое тело - пропуск");
        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить строковое тело !NOCLI
// Устанавливает тело запроса из строки
//
// Параметры:
//  Данные      - Строка - Данные тела запроса         - data
//  ЗаписатьBOM - Булево - Истина > BOM будет добавлен - bom
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьСтроковоеТело(Знач Данные, Знач ЗаписатьBOM = Ложь) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ОтменитьЗаписьMultipart();

        Если Не ЗначениеЗаполнено(Данные) Тогда
            ДобавитьЛог("УстановитьСтроковоеТело: нет данных - пропуск");
            Возврат ЭтотОбъект;
        КонецЕсли;

        Кодировка = ПолучитьНастройку("КодировкаТелаЗапроса");

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Кодировка);

        Если Не ЗапросТипУстановленВручную Тогда
          ЗапросТипДанных  = СтрШаблон("text/plain; charset=%1", Кодировка);
        КонецЕсли;

        ДобавитьЛог("УстановитьСтроковоеТело: начало установки тела");
        УстановитьТелоИзСтроки(Данные, ЗаписатьBOM);
        ДобавитьЛог(СтрШаблон("УстановитьСтроковоеТело: тело установлено, размер %1", ЗапросТело.Размер()));

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить JSON тело !NOCLI
// Устанавливает тело в формате JSON из подходящей коллекции или строки
//
// Параметры:
//  Данные - Произвольный - Строка или коллекция для преобразования в JSON - data
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьJsonТело(Знач Данные) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ОтменитьЗаписьMultipart();

        Если Не ЗначениеЗаполнено(Данные) Тогда
            ДобавитьЛог("УстановитьJsonТело: нет данных - пропуск");
            Возврат ЭтотОбъект;
        КонецЕсли;

        Если Не ЗапросТипУстановленВручную Тогда
          ЗапросТипДанных  = "application/json; charset=utf-8";
        КонецЕсли;

        ДобавитьЛог("УстановитьJsonТело: начало установки тела");

        Если Не ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда

            OPI_ПреобразованиеТипов.ПолучитьКоллекцию(Данные);

            Если Не ТипЗнч(Данные) = Тип("Массив") Тогда
                ЗапросТелоКоллекция = OPI_Инструменты.КопироватьКоллекцию(Данные);
            КонецЕсли;

        КонецЕсли;

        УстановитьТелоИзСтроки(Данные);

        ДобавитьЛог(СтрШаблон("УстановитьJsonТело: тело установлено, размер %1", ЗапросТело.Размер()));

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить Form тело !NOCLI
// Устанавливает тело в формате x-www-form-urlencoded из коллекции значений полей
//
// Параметры:
//  Данные - Произвольный - Коллекция КлючЗначение с параметрами формы - data
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Установить form тело
Функция УстановитьFormТело(Знач Данные) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ОтменитьЗаписьMultipart();

        Если Не ЗначениеЗаполнено(Данные) Тогда
            ДобавитьЛог("УстановитьFormТело: нет данных - пропуск");
            Возврат ЭтотОбъект;
        КонецЕсли;

        Если Не ЗапросТипУстановленВручную Тогда
          ЗапросТипДанных  = "application/x-www-form-urlencoded; charset=utf-8";
        КонецЕсли;

        ДобавитьЛог("УстановитьFormТело: начало установки тела");

        OPI_ПреобразованиеТипов.ПолучитьКоллекцию(Данные);

        Если ТипЗнч(Данные) = Тип("Массив") Тогда

            Данные = Данные[0];

            Если Не ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
                OPI_ПреобразованиеТипов.ПолучитьСтроку(Данные);
            КонецЕсли;

        Иначе

            ЗапросТелоКоллекция = OPI_Инструменты.КопироватьКоллекцию(Данные);
            Данные              = ПараметрыЗапросаВСтроку(Данные);

        КонецЕсли;

        УстановитьТелоИзСтроки(Данные);
        УстановитьНастройку("ПоляТелаВOAuth", Истина);

        ДобавитьЛог(СтрШаблон("УстановитьFormТело: тело установлено, размер %1", ЗапросТело.Размер()));

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Начать запись тела multipart !NOCLI
// Инициализирует запись данных в тело в формате multipart
//
// Примечание:
// Для дальнейшего формирования тела используются методы `ДобавитьФайлMultipart` и `ДобавитьПолеMultipart`
//
// Параметры:
//  ИспользоватьФайл - Булево - Истина > использовать временный файл, Ложь > формирует тело в памяти - file
//  Вид              - Строка - Вид multipart загрузки: form data, related                           - type
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция НачатьЗаписьТелаMultipart(ИспользоватьФайл = Истина, Знач Вид = "form-data") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьБулево(ИспользоватьФайл);
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Вид);

        Multipart        = Истина;
        Boundary         = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
        РазделительСтрок = Символы.ВК + Символы.ПС;
        Кодировка        = ПолучитьНастройку("КодировкаТелаЗапроса");
        ЗапросТипДанных  = СтрШаблон("multipart/%1; boundary=%2", Вид, Boundary);

        ЗапросТелоКоллекция = Новый Структура;

        Если ИспользоватьФайл Тогда

            ДобавитьЛог("НачатьЗаписьТелаMultipart: создание временного файла");

            // BSLLS:MissingTemporaryFileDeletion-off

            //@skip-check missing-temporary-file-deletion
            ЗапросФайлТела     = ПолучитьИмяВременногоФайла();

            // BSLLS:MissingTemporaryFileDeletion-on

            ФайлТелаВременный  = Истина;
            ЗапросЗаписьДанных = Новый ЗаписьДанных(ЗапросФайлТела
                , Кодировка
                , ПорядокБайтов.LittleEndian
                , ""
                , Ложь
                , ""
                , Ложь);

        Иначе

            ДобавитьЛог("НачатьЗаписьТелаMultipart: создание потока в памяти");

            ЗапросПотокТела = Новый ПотокВПамяти();

            ЗапросЗаписьДанных = Новый ЗаписьДанных(ЗапросПотокТела
                , Кодировка
                , ПорядокБайтов.LittleEndian
                , ""
                , ""
                , Ложь);

        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить файл multipart !NOCLI
// Добавляет блок файла в multipart/form-data тело
//
// Примечание:
// Запись Multipart предварительно должна быть инициализирована при помощи функции `НачатьЗаписьТелаMultipart`
//
// Параметры:
//  ИмяПоля   - Строка                 - Имя поля формы               - field
//  ИмяФайла  - Строка                 - Имя файла с расширением      - filename
//  Данные    - ДвоичныеДанные, Строка - Данные файла для записи      - data
//  ТипДанных - Строка                 - Mime тип записываемых данных - mime
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьФайлMultipartFormData(Знач ИмяПоля, Знач ИмяФайла, Знач Данные, Знач ТипДанных = "") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не Multipart Тогда Возврат Ошибка("ДобавитьФайлMultipart: не инициализирована запись Multipart"); КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные);
        OPI_ПреобразованиеТипов.ПолучитьСтроку(ИмяПоля);
        OPI_ПреобразованиеТипов.ПолучитьСтроку(ИмяФайла);

        ДобавитьЛог("ДобавитьФайлMultipart: запись шапки блока");

        Шапка = СтрШаблон("Content-Disposition: form-data; name=""%1""; filename=""%2""", ИмяПоля, ИмяФайла);

        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + Boundary + РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(Шапка);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        Если ЗначениеЗаполнено(ТипДанных) Тогда
            ЗапросЗаписьДанных.ЗаписатьСтроку("Content-Type: " + ТипДанных);
        КонецЕсли;

        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        ДобавитьЛог("ДобавитьФайлMultipart: запись данных");

        ЗаписатьДвоичныеДанные(ЗапросЗаписьДанных, Данные);

        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить поле multipart !NOCLI
// Добавляет поле формы в multipart/form-data тело
//
// Примечание:
// Запись Multipart предварительно должна быть инициализирована при помощи функции `НачатьЗаписьТелаMultipart`
//
// Параметры:
//  ИмяПоля   - Строка       - Имя поля формы     - field
//  Значение  - Произвольный - Значение поля      - data
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьПолеMultipartFormData(Знач ИмяПоля, Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не Multipart Тогда Возврат Ошибка("ДобавитьПолеMultipart: не инициализирована запись Multipart"); КонецЕсли;

        ТипЗначения = ТипЗнч(Значение);

        ДобавитьЛог("ДобавитьПолеMultipart: запись шапки блока");

        Шапка       = СтрШаблон("Content-Disposition: form-data; name=""%1""", ИмяПоля);

        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + boundary + РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(Шапка);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        ДобавитьЛог("ДобавитьПолеMultipart: запись данных");

        Если ТипЗначения = Тип("Булево") Тогда

            Значение = ?(Значение, "true", "false");
            ЗапросЗаписьДанных.ЗаписатьСтроку(Значение);
            ЗапросТелоКоллекция.Вставить(ИмяПоля, Значение);

        ИначеЕсли ТипЗначения = Тип("ДвоичныеДанные") Тогда

            ЗаписатьДвоичныеДанные(ЗапросЗаписьДанных, Значение);

        Иначе

            OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
            ЗапросЗаписьДанных.ЗаписатьСтроку(Значение);
            ЗапросТелоКоллекция.Вставить(ИмяПоля, Значение);

        КонецЕсли;

        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить данные Related !NOCLI
// Добавляет данные в multipart/related тело
//
// Примечание:
// Запись Multipart предварительно должна быть инициализирована при помощи функции `НачатьЗаписьТелаMultipart`
//
// Параметры:
//  Данные    - Произвольный - Данные для записи            - data
//  ТипДанных - Строка       - MIME тип записываемых данных - mime
//  IDЧасти   - Строка       - Content ID, если необходим   - cid
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьДанныеRelated(Знач Данные, Знач ТипДанных, Знач IDЧасти = "") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не Multipart Тогда Возврат Ошибка("ДобавитьФайлRelated: не инициализирована запись Multipart"); КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(ТипДанных);
        OPI_ПреобразованиеТипов.ПолучитьСтроку(IDЧасти);
        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные, Истина, Ложь);

        ДобавитьЛог("ДобавитьФайлRelated: запись шапки блока");
        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + Boundary + РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку("Content-Type: " + ТипДанных);

        Если ЗначениеЗаполнено(IDЧасти) Тогда
            ЗапросЗаписьДанных.ЗаписатьСтроку("Content-ID: " + IDЧасти);
        КонецЕсли;

        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        ДобавитьЛог("ДобавитьФайлRelated: запись данных");
        ЗаписатьДвоичныеДанные(ЗапросЗаписьДанных, Данные);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

#КонецОбласти

#Область УстановкаЗаголовков

// Установить заголовки !NOCLI
// Устанавливает коллекцию заголовков запросов
//
// Параметры:
//  Значение     - Произвольный - Стрктура или соответствие заголовков запрос              - headers
//  ПолнаяЗамена - Булево       - Очищает все добавленные ранее заголовки перед установкой - replace
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьЗаголовки(Знач Значение, Знач ПолнаяЗамена = Ложь) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не ЗначениеЗаполнено(Значение) Тогда Значение = Новый Соответствие; КонецЕсли;

        ТекстОшибки = "УстановитьЗаголовки: переданные параметры не являются коллекцией ключ/значение";
        OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Значение, ТекстОшибки);
        OPI_ПреобразованиеТипов.ПолучитьБулево(ПолнаяЗамена);

        ДобавитьЛог("УстановитьЗаголовки: установка заголовков запроса");

        Если ПолнаяЗамена Тогда
            ЗапросЗаголовки = Значение;
        Иначе
            Для Каждого Заголовок Из Значение Цикл
                ЗапросЗаголовки.Вставить(Заголовок.Ключ, Заголовок.Значение);
            КонецЦикла;
        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить заголовок !NOCLI
// Добавляет заголовок в набор заголовков запроса
//
// Параметры:
//  Имя      - Строка - Ключ заголовка     - header
//  Значение - Строка - Значение заголовка - value
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьЗаголовок(Знач Имя, Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не ЗначениеЗаполнено(Значение) Тогда Значение = Новый Соответствие; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Имя);
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);

        ДобавитьЛог("ДобавитьЗаголовок: установка заголовков запроса");

        ЗапросЗаголовки.Вставить(Имя, Значение);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;
КонецФункции

#КонецОбласти

#Область Авторизация

// Добавить Basic авторизацию !NOCLI
// Добавляет стандартную авторизацю по пользователю и паролю
//
// Параметры:
//  Пользователь - Строка - Имя пользователя - user
//  Пароль       - Строка - Пароль           - pwd
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьBasicАвторизацию(Знач Пользователь, Знач Пароль) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Пользователь);
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Пароль);

        ЗапросПользователь = Пользователь;
        ЗапросПароль       = Пароль;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить Bearer авторизацию !NOCLI
// Добавляет заголовок запроса для Bearer авторизации
//
// Параметры:
//  Токен - Строка - Значение Bearer токена - token
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьBearerАвторизацию(Знач Токен) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Токен);

        AuthВид    = "bearer";
        AuthДанные = Токен;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить AWS4 авторизацию !NOCLI
// Добавляет данные для AWS4 авторизации
//
// Параметры:
//  AccessKey - Строка - Access key для авторизации       - access
//  SecretKey - Строка - Secret key для авторизации       - secret
//  Region    - Строка - Регион сервиса                   - region
//  Service   - Строка - Вид сервиса, если отличен от s3  - service
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьAWS4Авторизацию(Знач AccessKey, Знач SecretKey, Знач Region, Знач Service = "s3") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Строка_ = "Строка";
        AuthВид = "aws4";

        AuthДанные = Новый Структура;
        OPI_Инструменты.ДобавитьПоле("AccessKey", AccessKey, Строка_, AuthДанные);
        OPI_Инструменты.ДобавитьПоле("SecretKey", SecretKey, Строка_, AuthДанные);
        OPI_Инструменты.ДобавитьПоле("Region"   , Region   , Строка_, AuthДанные);
        OPI_Инструменты.ДобавитьПоле("Service"  , Service  , Строка_, AuthДанные);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить OAuth v1 авторизацию !NOCLI
// Добавляет данные для OAuth v1 авторизации
//
// Примечание:
// По умолчанию, для создания подписи используется HMAC-SHA256. Для изменения алгоритма можно восопользоваться функцией^^
// `УстановитьАлгоритмOAuthV1`
//
// Параметры:
//  Token          - Строка - Token для авторизации            - token
//  Secret         - Строка - Secret для авторизации           - secret
//  ConsumerKey    - Строка - Consumer key для авторизации     - ck
//  ConsumerSecret - Строка - Consumer secret для авторизации  - cs
//  Версия         - Строка - Версия API                       - ver
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьOAuthV1Авторизацию(Знач Token, Знач Secret, Знач ConsumerKey, Знач ConsumerSecret, Знач Версия) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Строка_ = "Строка";
        AuthВид = "oauth1";

        AuthДанные = Новый Структура;
        OPI_Инструменты.ДобавитьПоле("OAuthToken"         , Token          , Строка_, AuthДанные);
        OPI_Инструменты.ДобавитьПоле("OAuthSecret"        , Secret         , Строка_, AuthДанные);
        OPI_Инструменты.ДобавитьПоле("OAuthConsumerKey"   , ConsumerKey    , Строка_, AuthДанные);
        OPI_Инструменты.ДобавитьПоле("OAuthConsumerSecret", ConsumerSecret , Строка_, AuthДанные);
        OPI_Инструменты.ДобавитьПоле("OAuthАлгоритм"      , "HMAC"         , Строка_, AuthДанные);
        OPI_Инструменты.ДобавитьПоле("OAuthХешФункция"    , "SHA256"       , Строка_, AuthДанные);
        OPI_Инструменты.ДобавитьПоле("OAuthВерсияAPI"     , Версия         , Строка_, AuthДанные);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить алгоритм OAuth V1 !NOCLI
// Изменяет алгоритм для подписи OAuth
//
// Параметры:
//  Алгоритм   - Строка - Алгоритм шифрования: HMAC, RSA          - alg
//  ХешФункция - Строка - Хеш функция для сигнатуры: SHA1, SHA256 - hash
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент - Этот же объект обработки
Функция УстановитьАлгоритмOAuthV1(Знач Алгоритм, Знач ХешФункция) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Если AuthВид <> "oauth1" Тогда
            Возврат Ошибка("УстановитьАлгоритмOAuthV1: перед установкой алгоритма авторизация OAuth v1 должна быть инициализирована");
        КонецЕсли;

        OPI_Инструменты.ДобавитьПоле("OAuthАлгоритм"  , Алгоритм  , "Строка", AuthДанные);
        OPI_Инструменты.ДобавитьПоле("OAuthХешФункция", ХешФункция, "Строка", AuthДанные);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

#КонецОбласти

#Область ОбработкаЗапроса

// Обработать запрос !NOCLI
// Создает запрос на основе введенных данных с выполнением или без
//
// Примечание:
// `ВыполнитьСразу = Ложь` может быть использовано для получения готовых^^
// объектов HTTPЗапрос и HTTPСоединение без их выполнения. См. `ВернутьЗапрос` и `ВернутьСоединение`
//
// Параметры:
//  Метод          - Строка - HTTP метод запроса                        - method
//  ВыполнитьСразу - Булево - Выполняет запрос сразу после формирования - run
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ОбработатьЗапрос(Знач Метод, Знач ВыполнитьСразу = Истина) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Метод);
        OPI_ПреобразованиеТипов.ПолучитьБулево(ВыполнитьСразу);
        ЗапросМетод = Метод;

        ДобавитьЛог("ОбработатьЗапрос: формирование объекта HTTPЗапроса");
        Если СформироватьЗапрос().Ошибка Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("ОбработатьЗапрос: перенос тела в объект HTTPЗапроса");
        Если УстановитьТелоЗапроса().Ошибка Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДополнитьЗаголовки();

        Если ВыполнитьСразу Тогда
            ВызватьМетод();
        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Выполнить запрос !NOCLI
// Выполняет запрос, если он был сформирован ранее
//
// Параметры:
// Принудительно - Булево - Попытка выполнения без дополнительных проверовк - force
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ВыполнитьЗапрос(Принудительно = Ложь) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("ВыполнитьЗапрос: выполнение запроса");

        Возврат ВызватьМетод(0, Принудительно);

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Отправить данные частями !NOCLI
// Отправляет тело несколькми запросами с заголовком Content-Range
//
// Параметры:
//  РазмерЧасти - Число  - Размер одной части для отправки - part
//  Метод       - Строка - HTTP метод запроса              - method
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ОтправитьДанныеЧастями(Знач РазмерЧасти = 5242880, Знач Метод = "PUT") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Если ТипЗнч(ЗапросТело) <> Тип("ДвоичныеДанные") Тогда
            ВызватьИсключение "Тело не установлено";
        КонецЕсли;

        Повторов    = 0;
        ОбщийРазмер = ЗапросТело.Размер();

        ЗапросПотокТела    = ЗапросТело.ОткрытьПотокДляЧтения();
        ЗапросЧтениеДанных = Новый ЧтениеДанных(ЗапросПотокТела);

        КБайт = 1024;
        МБайт = КБайт * КБайт;

        Пока ЗапросПотокТела.ТекущаяПозиция() < ОбщийРазмер Цикл

            ОтправитьЧасть(ЗапросПотокТела.ТекущаяПозиция(), РазмерЧасти, Метод);
            Проверка = ПроверитьЗагрузкуЧасти();

            Если Проверка <> Неопределено Тогда
                Возврат Проверка;
            КонецЕсли;

            OPI_Инструменты.ИнформацияОПрогрессе(ЗапросПотокТела.ТекущаяПозиция(), ОбщийРазмер, "МБ", МБайт);

            // !OInt ВыполнитьСборкуМусора();

        КонецЦикла;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Отправить часть !NOCLI
// Отправляет запрос с указанной частью тела и заголовком Content-Range
//
// Параметры:
//  ПозицияНачала  - Число  - Позиция начала в теле запроса                            - start
//  КоличествоБайт - Число  - Количество байт от указанной позиции начала для отправки - bytes
//  Метод          - Строка - HTTP метод запроса                                       - method
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ОтправитьЧасть(Знач ПозицияНачала, Знач КоличествоБайт, Знач Метод = "PUT") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Если ТипЗнч(ЗапросТело) <> Тип("ДвоичныеДанные") Тогда
            ВызватьИсключение "Тело не установлено";
        КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Метод);

        ЗапросПотокЧтенияТела = ?(ЗапросПотокЧтенияТела = Неопределено, ЗапросТело.ОткрытьПотокДляЧтения(), ЗапросПотокЧтенияТела);
        ЗапросЧтениеДанных    = ?(ЗапросЧтениеДанных = Неопределено, Новый ЧтениеДанных(ЗапросПотокЧтенияТела), ЗапросЧтениеДанных);

        Если Не ЗапросПотокЧтенияТела.ТекущаяПозиция() = ПозицияНачала Тогда
            ЗапросПотокЧтенияТела.Перейти(ПозицияНачала, ПозицияВПотоке.Начало);
        КонецЕсли;

        Результат = ЗапросЧтениеДанных.Прочитать(КоличествоБайт);

        ЗапросТелоТекущейОтправки = Результат.ПолучитьДвоичныеДанные();
        РазмерТекущих             = ЗапросТелоТекущейОтправки.Размер();

        Если Не ЗначениеЗаполнено(ЗапросТелоТекущейОтправки) Или РазмерТекущих = 0 Тогда
            Возврат ЭтотОбъект;
        КонецЕсли;

        ПозицияОкончания = ПозицияНачала + РазмерТекущих - 1;

        ЗаголовокПотока = "bytes "
            + OPI_Инструменты.ЧислоВСтроку(ПозицияНачала)
            + "-"
            + OPI_Инструменты.ЧислоВСтроку(ПозицияОкончания)
            + "/"
            + OPI_Инструменты.ЧислоВСтроку(ЗапросТело.Размер());

        ДопЗаголовки = Новый Соответствие;
        ДопЗаголовки.Вставить("Content-Length", OPI_Инструменты.ЧислоВСтроку(РазмерТекущих));
        ДопЗаголовки.Вставить("Content-Range" , ЗаголовокПотока);

        УстановитьЗаголовки(ДопЗаголовки).ОбработатьЗапрос(Метод, Истина);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Вернуть запрос !NOCLI
// Возвращает объект текущего HTTP запроса
//
// Параметры:
//  Принудительно - Булево -  Ложь > Вместо запроса будет возвращен объект обработки, если в ней были ошибки - force
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент, HTTPЗапрос, Неопределено -  Запрос или этот же объект обработки
Функция ВернутьЗапрос(Принудительно = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу() И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    Возврат Запрос;

КонецФункции

// Вернуть соединение !NOCLI
// Возвращает объект текущего HTTP соединения
//
// Параметры:
//  Принудительно - Булево -  Ложь > Вместо соединения будет возвращен объект обработки, если в ней были ошибки - force
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент, HTTPСоединение, Неопределено -  Соединение или этот же объект обработки
Функция ВернутьСоединение(Принудительно = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу() И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    Возврат Соединение;

КонецФункции

#КонецОбласти

#Область ПолучениеОтвета

// Вернуть ответ !NOCLI
// Возвращает объект текущего HTTP ответа
//
// Параметры:
//  Принудительно       - Булево - Ложь > Вместо ответа будет возвращен объект обработки, если в ней были ошибки - force
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки              - ex
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент, HTTPОтвет, Неопределено -  Ответ или этот же объект обработки
Функция ВернутьОтвет(Знач Принудительно = Ложь, Знач ИсключениеПриОшибке = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    Возврат Ответ;

КонецФункции

// Вернуть ответ как JSON коллекцию !NOCLI
// Возвращает тело ответа как коллекцию, полученную из JSON
//
// Примечание:
// При невозможности получения коллекции из тела будут возвращены двоичные данные
//
// Параметры:
//  ВСоответствие       - Булево -  Признак использования соответствия вместо структуры             - map
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки - ex
//
// Возвращаемое значение:
//  Произвольный -  Ответ или этот же объект обработки
Функция ВернутьОтветКакJSONКоллекцию(Знач ВСоответствие = Истина, Знач ИсключениеПриОшибке = Ложь) Экспорт

    Если ОстановитьРаботу(ИсключениеПриОшибке) Тогда Возврат ЭтотОбъект; КонецЕсли;

    Попытка

        OPI_ПреобразованиеТипов.ПолучитьБулево(ВСоответствие);
        ТелоОтвета = ПолучитьТелоОтвета();

        Попытка

            Если ТелоОтвета.Размер() > 0 Тогда
                JSON = OPI_Инструменты.JsonВСтруктуру(ТелоОтвета, ВСоответствие);
            Иначе
                JSON = Новый Соответствие;
            КонецЕсли;

        Исключение

            JSON = ТелоОтвета;

        КонецПопытки;

        Возврат JSON;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Вернуть ответ как двоичные данные !NOCLI
// Возвращает тело ответа как двоичные данные
//
// Параметры:
//  Принудительно       - Булево - Ложь > Вместо ответа будет возвращен объект обработки, если в ней были ошибки - force
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки - ex
//
// Возвращаемое значение:
//  Произвольный -  Ответ или этот же объект обработки
Функция ВернутьОтветКакДвоичныеДанные(Знач Принудительно = Ложь, Знач ИсключениеПриОшибке = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    Попытка
        ТелоДвоичные = Неопределено;
        ТелоДвоичные = ПолучитьТелоОтвета();
    Исключение

        Ошибка = Истина;

        Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда
            ТелоДвоичные = ЭтотОбъект;
        КонецЕсли;

    КонецПопытки;

    Возврат ТелоДвоичные;

КонецФункции

// Вернуть ответ как строку !NOCLI
// Возвращает тело ответа как строку
//
// Параметры:
//  Принудительно       - Булево - Ложь > Вместо ответа будет возвращен объект обработки, если в ней были ошибки - force
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки - ex
//
// Возвращаемое значение:
//  Произвольный -  Ответ или этот же объект обработки
Функция ВернутьОтветКакСтроку(Знач Принудительно = Ложь, Знач ИсключениеПриОшибке = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    Попытка
        ТелоСтрокой = Неопределено;
        ТелоСтрокой = ПолучитьСтрокуИзДвоичныхДанных(ПолучитьТелоОтвета());
    Исключение

        Ошибка = Истина;

        Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда
            ТелоСтрокой = ЭтотОбъект;
        КонецЕсли;

    КонецПопытки;

    Возврат ТелоСтрокой;

КонецФункции

// Вернуть имя файла тела ответа !NOCLI
// Возвращает путь к файлу тела ответа
//
// Параметры:
//  Принудительно       - Булево - Ложь > Вместо ответа будет возвращен объект обработки, если в ней были ошибки - force
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки - ex
//
// Возвращаемое значение:
//  Произвольный -  Ответ или этот же объект обработки
Функция ВернутьИмяФайлаТелаОтвета(Знач Принудительно = Ложь, Знач ИсключениеПриОшибке = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    Попытка
        ИмяФайлаТела = Неопределено;
        ИмяФайлаТела = Ответ.ПолучитьИмяФайлаТела();
    Исключение

        Ошибка = Истина;

        Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда
            ИмяФайлаТела = ЭтотОбъект;
        КонецЕсли;

    КонецПопытки;

    Возврат ИмяФайлаТела;

КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область HTTP

Функция ПреобразоватьПараметрВСтроку(Знач Значение)

    КодироватьURL = ПолучитьНастройку("КодировкаURL");

    Если ТипЗнч(Значение) = Тип("Массив") Тогда

        Значение = OPI_Инструменты.КопироватьКоллекцию(Значение);

        Для Н = 0 По Значение.ВГраница() Цикл
            Значение[Н] = ПреобразоватьПараметрВСтроку(Значение[Н]);
        КонецЦикла;

        Значение = СтрСоединить(Значение, ",");

        Если КодироватьURL Тогда
            Значение = КодироватьСтроку(Значение, СпособКодированияСтроки.URLВКодировкеURL);
        КонецЕсли;

        Значение = "[" + Значение + "]";

    ИначеЕсли ТипЗнч(Значение) = Тип("Соответствие") Или ТипЗнч(Значение) = Тип("Структура") Тогда

        Значение      = OPI_Инструменты.КопироватьКоллекцию(Значение);
        ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет, "");

        ЗаписьJSON = Новый ЗаписьJSON;
        ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);

        ЗаписатьJSON(ЗаписьJSON, Значение);
        Значение = ЗаписьJSON.Закрыть();

    ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда

        Значение = ?(Значение, "true", "false");

    Иначе

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);

        Если КодироватьURL Тогда
            Значение = КодироватьСтроку(Значение, СпособКодированияСтроки.КодировкаURL);
        КонецЕсли;

    КонецЕсли;

    Возврат Значение;

КонецФункции

Функция УстановитьТелоИзДвоичныхДанных(Знач Значение)

    OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Значение, Истина, Ложь);

    ЗапросТело            = Значение;
    ЗапросПотокТела       = Неопределено;
    ЗапросПотокЧтенияТела = Неопределено;
    ЗапросЧтениеДанных    = Неопределено;
    ЗапросЗаписьДанных    = Неопределено;

    Возврат ЭтотОбъект;

КонецФункции

Функция УстановитьТелоИзСтроки(Знач Значение, Знач ЗаписатьBOM = Ложь)

    Если ТипЗнч(Значение) = Тип("ДвоичныеДанные") Тогда

        ЗапросТело            = Значение;
        ЗапросПотокТела       = Неопределено;
        ЗапросПотокЧтенияТела = Неопределено;
        ЗапросЧтениеДанных    = Неопределено;
        ЗапросЗаписьДанных    = Неопределено;

    Иначе

        Кодировка = ПолучитьНастройку("КодировкаТелаЗапроса");

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
        OPI_ПреобразованиеТипов.ПолучитьБулево(ЗаписатьBOM);

        ЗапросТело            = ПолучитьДвоичныеДанныеИзСтроки(Значение, Кодировка, ЗаписатьBOM);
        ЗапросПотокТела       = Неопределено;
        ЗапросПотокЧтенияТела = Неопределено;
        ЗапросЧтениеДанных    = Неопределено;
        ЗапросЗаписьДанных    = Неопределено;

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция РазбитьURL()

    ДобавитьЛог("РазбитьURL: разбиение запроса на составные части");

    URL = ЗапросURL;

    ЗапросЗащищенное = Не СтрНачинаетсяС(ЗапросURL, "http://");

    ДобавитьЛог("РазбитьURL: Защищенное = " + Строка(ЗапросЗащищенное));

    URL = СтрЗаменить(URL, "https://", "");
    URL = СтрЗаменить(URL, "http://" , "");

    Секция = СтрНайти(URL, "#");

    Если Секция > 0 Тогда

        ЗапросСекция = Прав(URL, СтрДлина(URL) - Секция + 1);
        ДобавитьЛог("РазбитьURL: Секция = " + ЗапросСекция);

        URL = Лев(URL, Секция - 1);

    КонецЕсли;

    Если СтрНайти(URL, "/") = 0 Тогда
        ЗапросАдрес = "";
        ЗапросДомен = URL;
    Иначе
        ЗапросАдрес = Прав(URL, СтрДлина(URL) - СтрНайти(URL, "/", НаправлениеПоиска.СНачала) + 1);
        ЗапросДомен = Лев(URL, СтрНайти(URL, "/", НаправлениеПоиска.СНачала) - 1);
    КонецЕсли;

    ДобавитьЛог("РазбитьURL: Адрес = " + ЗапросАдрес);
    ДобавитьЛог("РазбитьURL: Домен = " + ЗапросДомен);

    Если СтрНайти(ЗапросДомен, ":") <> 0 Тогда

        ХостПорт    = СтрРазделить(ЗапросДомен, ":");
        ЗапросДомен = ХостПорт[0];
        ЗапросПорт  = ХостПорт[1];

        OPI_ПреобразованиеТипов.ПолучитьЧисло(ЗапросПорт);

    Иначе

        ЗапросПорт = ?(ЗапросЗащищенное, 443, 80);

    КонецЕсли;

    ДобавитьЛог("РазбитьURL: Порт = " + OPI_Инструменты.ЧислоВСтроку(ЗапросПорт));

    Если OPI_Инструменты.ЭтоOneScript() И ЗапросЗащищенное Тогда
        ЗапросСервер = "https://" + ЗапросДомен;
    Иначе
        ЗапросСервер = ЗапросДомен;
    КонецЕсли;

    ДобавитьЛог("РазбитьURL: Сервер = " + ЗапросСервер);

    Возврат ЭтотОбъект;

КонецФункции

Функция СформироватьЗапрос()

    Если Не ЗначениеЗаполнено(ЗапросURL) Тогда
        Возврат Ошибка("Не установлен URL");
    КонецЕсли;

    ДобавитьЛог("СформироватьЗапрос: Добавление параметров");
    ДополнитьURLПараметрами();

    ДобавитьЛог("СформироватьЗапрос: Создание объекта запроса");
    СоздатьЗапрос();

    ДобавитьЛог("СформироватьЗапрос: Создание объекта соединения");
    СоздатьСоединение();

    Возврат ЭтотОбъект;

КонецФункции

Функция СоздатьЗапрос()

    Заголовки = ПолучитьСтандартныеЗаголовки();
    Запрос    = Новый HTTPЗапрос(ЗапросАдресПолный, Заголовки);

    Возврат ЭтотОбъект;

КонецФункции

Функция СоздатьСоединение()

    Если Не ЗначениеЗаполнено(ЗапросПорт) Тогда
        ЗапросПорт = ?(ЗапросЗащищенное, 443, 80);
    КонецЕсли;

    Если ЗапросЗащищенное Тогда

        Если OPI_Инструменты.ЭтоOneScript() Тогда

            Соединение = Новый HTTPСоединение(ЗапросСервер
                , ЗапросПорт
                , ЗапросПользователь
                , ЗапросПароль
                , ЗапросПрокси
                , ЗапросТаймаут);

        Иначе

            SSL        = Новый ЗащищенноеСоединениеOpenSSL;
            Соединение = Новый HTTPСоединение(ЗапросСервер
            , ЗапросПорт
            , ЗапросПользователь
            , ЗапросПароль
            , ЗапросПрокси
            , ЗапросТаймаут
            , SSL);

        КонецЕсли;

    Иначе

        Соединение = Новый HTTPСоединение(ЗапросСервер
            , ЗапросПорт
            , ЗапросПользователь
            , ЗапросПароль
            , ЗапросПрокси
            , ЗапросТаймаут);

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция ДополнитьURLПараметрами()

    Если СтрЗаканчиваетсяНа(ЗапросАдрес, "?") Или Не ЗначениеЗаполнено(ЗапросПараметрыURL) Тогда
        ЗнакНачала = "";
    ИначеЕсли СтрНайти(ЗапросАдрес, "?") <> 0 Тогда
        ЗнакНачала = "&";
    Иначе
        ЗнакНачала = "?";
    КонецЕсли;

    ЗапросАдресПолный = ЗапросАдрес + ЗнакНачала + ПараметрыЗапросаВСтроку(ЗапросПараметрыURL) + ЗапросСекция;

    Возврат ЭтотОбъект;

КонецФункции

Функция ПараметрыЗапросаВСтроку(Знач Параметры)

    Если Не ЗначениеЗаполнено(Параметры) Тогда
        Возврат "";
    КонецЕсли;

    ДобавитьЛог("ПараметрыЗапросаВСтроку: Получение коллекции КлючЗначение");
    OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Параметры);

    СтрокаПараметров = "";

    ДобавитьЛог("ПараметрыЗапросаВСтроку: Добавление параметров");
    Для Каждого Параметр Из Параметры Цикл

        ТекущееЗначение = Параметр.Значение;
        ТекущийКлюч     = Параметр.Ключ;

        Если Не ТипЗнч(ТекущееЗначение) = Тип("Массив") Или Не ПолучитьНастройку("ОтдельныеЭлементыМассивов") Тогда

            ЗначениеПараметра = ПреобразоватьПараметрВСтроку(ТекущееЗначение);
            СтрокаПараметров = СтрокаПараметров + Параметр.Ключ + "=" + ЗначениеПараметра + "&";

        Иначе

            ЗначениеПараметра = РазделитьМассивНаПараметрыURL(ТекущийКлюч, ТекущееЗначение);
            СтрокаПараметров  = СтрокаПараметров + ЗначениеПараметра + "&";

        КонецЕсли;

    КонецЦикла;

    СтрокаПараметров = Лев(СтрокаПараметров, СтрДлина(СтрокаПараметров) - 1);

    Возврат СтрокаПараметров;

КонецФункции

Функция РазделитьМассивНаПараметрыURL(Знач Ключ, Знач Значение)

    КлючМассив = СтрШаблон("%1%2=", Ключ, ?(ПолучитьНастройку("КвадратныеСкобкиМассивов"), "[]", ""));
    Значение = OPI_Инструменты.КопироватьКоллекцию(Значение);

    Для Н = 0 По Значение.ВГраница() Цикл

        ТекущееЗначение = Значение[Н];

        OPI_ПреобразованиеТипов.ПолучитьСтроку(ТекущееЗначение);

        Если ПолучитьНастройку("КодировкаURL") Тогда
            ТекущееЗначение = КодироватьСтроку(ТекущееЗначение, СпособКодированияСтроки.URLВКодировкеURL);
        КонецЕсли;

        Значение.Установить(Н, КлючМассив + ТекущееЗначение);

    КонецЦикла;

    ПараметрСтрокой = СтрСоединить(Значение, "&");

    Возврат ПараметрСтрокой;

КонецФункции

Функция ПолучитьСтандартныеЗаголовки()

    Заголовки = Новый Соответствие;

    Заголовки.Вставить("Accept"         , "*/*");
    Заголовки.Вставить("Connection"     , "keep-alive");
    Заголовки.Вставить("Accept-Charset" , "utf-8");

    Возврат Заголовки;

КонецФункции

Функция ДополнитьЗаголовки()

    Если Запрос.Заголовки.Получить("Content-Length") = Неопределено Тогда

        ДобавитьЛог("ДополнитьЗаголовки: установка Content-Length");

        Если ЗапросФайлТела = Неопределено Тогда

            Если ЗапросТело = Неопределено Тогда
                РазмерТела = 0;
            Иначе
                РазмерТела = ЗапросТело.Размер();
            КонецЕсли;

        Иначе

            ФайлТела   = Новый Файл(ЗапросФайлТела);
            РазмерТела = ФайлТела.Размер();

        КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(РазмерТела);
        Запрос.Заголовки.Вставить("Content-Length" , РазмерТела);

    КонецЕсли;

    ДополнитьЗаголовкиАвторизации();

    Если ПолучитьНастройку("gzip") Тогда
        ДобавитьЛог("ДополнитьЗаголовки: установка заголовка ожидания gzip");
        Запрос.Заголовки.Вставить("Accept-Encoding", "gzip");
    КонецЕсли;

    Если ЗначениеЗаполнено(ЗапросТипДанных) Тогда
        Запрос.Заголовки.Вставить("Content-Type", ЗапросТипДанных);
    КонецЕсли;

    Если ТипЗнч(ЗапросЗаголовки) = Тип("Соответствие") Тогда

        Для Каждого Заголовок Из ЗапросЗаголовки Цикл
            Запрос.Заголовки.Вставить(Заголовок.Ключ, Заголовок.Значение);
        КонецЦикла;

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция ДополнитьЗаголовкиАвторизации()

    Если Не ЗначениеЗаполнено(AuthВид) Тогда
        Возврат ЭтотОбъект;
    КонецЕсли;

    Если AuthВид = "aws4" Тогда

        ДобавитьЛог("ДополнитьЗаголовкиАвторизации: формирование заголовка AWS4 авторизации");
        ДобавитьAWS4();

    ИначеЕсли AuthВид = "oauth1" Тогда

        ДобавитьЛог("ДополнитьЗаголовкиАвторизации: формирование заголовка OAuth V1 авторизации");
        ДобавитьЗаголовокOAuthV1();

    Иначе

        ДобавитьЛог("ДополнитьЗаголовкиАвторизации: формирование заголовка Bearer авторизации");
        Запрос.Заголовки.Вставить("Authorization", СтрШаблон("Bearer %1", AuthДанные));

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция УстановитьТелоЗапроса()

    Если Multipart Тогда
        ЗвершитьЗаписьMultipart();
    КонецЕсли;

    Если ЗначениеЗаполнено(ЗапросФайлТела) Тогда
        Запрос.УстановитьИмяФайлаТела(ЗапросФайлТела);
    Иначе

        ЗапросТелоТекущий = ?(ЗапросТелоТекущейОтправки = Неопределено, ЗапросТело, ЗапросТелоТекущейОтправки);

        Если ТипЗнч(ЗапросТело) = Тип("ДвоичныеДанные") Тогда
            Запрос.УстановитьТелоИзДвоичныхДанных(ЗапросТелоТекущий);
        КонецЕсли;

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция ВызватьМетод(Знач ЧислоПереадресаций = 0, Знач Принудительно = Ложь)

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если (Запрос = Неопределено Или Соединение = Неопределено) И Не Принудительно Тогда
        Возврат Ошибка("ВызватьМетод: запрос не был сформирован перед выполнением");
    КонецЕсли;

    Если ЗначениеЗаполнено(ЗапросВыходнойФайл) Тогда
        Ответ = Соединение.ВызватьHTTPМетод(ЗапросМетод, Запрос, ЗапросВыходнойФайл);
    Иначе
        Ответ = Соединение.ВызватьHTTPМетод(ЗапросМетод, Запрос);
    КонецЕсли;

    Если ЭтоПереадресация(Ответ) Тогда

        МаксимальноеЧислоПереадресаций = 5;

        Если ЧислоПереадресаций = МаксимальноеЧислоПереадресаций Тогда
            Ошибка("ВызватьМетод: превышено число переадресаций");
            Возврат ЭтотОбъект;
        КонецЕсли;

        URL = Ответ.Заголовки["Location"];
        УстановитьURL(URL);

        СоздатьСоединение();
        Запрос.АдресРесурса = ЗапросАдрес;

        ВызватьМетод(ЧислоПереадресаций + 1, Принудительно);

    КонецЕсли;

    ОтветКодСостояния = Ответ.КодСостояния;
    ОтветЗаголовки    = Ответ.Заголовки;

    Возврат ЭтотОбъект;

КонецФункции

Функция ПолучитьТелоОтвета()

    НужнаРаспаковка = Ложь;

    Для Каждого ЗаголовокОтвета Из Ответ.Заголовки Цикл

        КлючЗаголовка     = ЗаголовокОтвета.Ключ;
        ЗначениеЗаголовка = ЗаголовокОтвета.Значение;

        Если нРег(КлючЗаголовка) = "content-encoding" Тогда
            Если нРег(ЗначениеЗаголовка) = "gzip" Тогда
                НужнаРаспаковка = Истина;
                Прервать;
            КонецЕсли;
        КонецЕсли;

    КонецЦикла;

    Если НужнаРаспаковка Тогда
        Данные = РаспаковатьОтвет(Ответ);
    Иначе
        Данные = ПолучитьТелоОтветаКакДвоичныеДанные();
    КонецЕсли;

    Данные = ?(ТипЗнч(Данные) = Тип("HTTPОтвет"), ПолучитьТелоОтветаКакДвоичныеДанные(), Данные);

    Если Не ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные);
    КонецЕсли;

    Возврат Данные;

КонецФункции

Функция ЭтоПереадресация(Знач Ответ)

    Переадресация = 300;
    ОшибкаЗапроса = 400;

    ЭтоПереадресация = Ответ.КодСостояния >= Переадресация И Ответ.КодСостояния < ОшибкаЗапроса И ЗначениеЗаполнено(
        Ответ.Заголовки["Location"]);

    Возврат ЭтоПереадресация;

КонецФункции

Функция ПолучитьТелоОтветаКакДвоичныеДанные()

    ПотокТела = Ответ.ПолучитьТелоКакПоток();

    Если ПотокТела = Неопределено Тогда
        Возврат ПолучитьДвоичныеДанныеИзСтроки("");
    КонецЕсли;

    ЧтениеДанных    = Новый ЧтениеДанных(ПотокТела);
    РезультатЧтения = ЧтениеДанных.Прочитать();
    Данные          = РезультатЧтения.ПолучитьДвоичныеДанные();

    ЧтениеДанных.Закрыть();
    ПотокТела.Закрыть();

    Возврат Данные;

КонецФункции

Функция ПолучитьТелоОтветаКакДанныеИлиПуть()

    ИмяФайлаТела = Ответ.ПолучитьИмяФайлаТела();

    Если Не ЗначениеЗаполнено(ИмяФайлаТела) Тогда
        Возврат ПолучитьТелоОтветаКакДвоичныеДанные();
    Иначе
        Возврат ИмяФайлаТела;
    КонецЕсли;

КонецФункции

Функция ПолучитьТелоЗапросаКакДвоичныеДанные()

    Если ЗначениеЗаполнено(ЗапросФайлТела) Тогда
        Данные = Новый ДвоичныеДанные(ЗапросФайлТела);
    Иначе
        Данные = ЗапросТело;
    КонецЕсли;

    Если Данные = Неопределено Тогда
        Данные = ПолучитьДвоичныеДанныеИзСтроки("");
    КонецЕсли;

    Возврат Данные;

КонецФункции

Функция ПроверитьЗагрузкуЧасти()

    КодУспеха        = 200;
    КодОшибкиЗапроса = 400;
    КодОшибкиСервера = 500;

    Если ОтветКодСостояния >= КодУспеха И ОтветКодСостояния < КодОшибкиЗапроса Тогда

        ЗагруженныеДанные = ОтветЗаголовки.Получить("Range");

        Если ЗначениеЗаполнено(ЗагруженныеДанные) Тогда

            ЗагруженныеДанные = СтрЗаменить(ЗагруженныеДанные, "bytes=", "");
            МассивИнформации = СтрРазделить(ЗагруженныеДанные, "-", Ложь);
            НеобходимоЧастей = 2;

            Если МассивИнформации.Количество() = НеобходимоЧастей Тогда
                ЗапросПотокЧтенияТела.Перейти(Число(МассивИнформации[1]) + 1    , ПозицияВПотоке.Начало);
            Иначе
                ЗапросПотокЧтенияТела.Перейти(ЗапросТелоТекущейОтправки.Размер(), ПозицияВПотоке.Текущая);
            КонецЕсли;

        Иначе

            ЗапросПотокЧтенияТела.Перейти(ЗапросТелоТекущейОтправки.Размер(), ПозицияВПотоке.Текущая);

        КонецЕсли;

    ИначеЕсли ОтветКодСостояния >= КодОшибкиСервера Тогда

        Если Повторов < 3 Тогда
            Повторов = Повторов + 1;
        Иначе
            Возврат ЭтотОбъект;
        КонецЕсли;

    Иначе
        Возврат ЭтотОбъект;
    КонецЕсли;

    Возврат Неопределено;

КонецФункции

Процедура ОтменитьЗаписьMultipart()

    Если Не Multipart Тогда
        Возврат;
    КонецЕсли;

    ДобавитьЛог("ОтменитьЗаписьMultipart: Удаление записанных данных");
    Multipart = Ложь;

    Попытка
        ЗапросЗаписьДанных.Закрыть();
    Исключение
        ДобавитьЛог("ОтменитьЗаписьMultipart: Не удалось закрыть запись. Возможно, она уже была закрыта");
    КонецПопытки;

    Если ЗначениеЗаполнено(ЗапросФайлТела) Тогда

        Попытка

            УдалитьФайлы(ЗапросФайлТела);
            ДобавитьЛог("ОтменитьЗаписьMultipart: Файл тела удален");

        Исключение
            ДобавитьЛог("ОтменитьЗаписьMultipart: Не удалось удалить файл тела. Возможно, он уже был удален");
        КонецПопытки;

    Иначе

        Если ТипЗнч(ЗапросПотокТела) = Тип("ПотокВПамяти") Тогда

            Попытка
                ЗапросПотокТела.Закрыть();
            Исключение
                ДобавитьЛог("ОтменитьЗаписьMultipart: Не удалось закрыть поток. Возможно, он уже был закрыт");
            КонецПопытки;

        КонецЕсли;

    КонецЕсли;

    ЗапросЗаписьДанных = Неопределено;
    ЗапросФайлТела     = Неопределено;

КонецПроцедуры

Процедура ЗаписатьДвоичныеДанные(ЗаписьДанных, Знач ДвоичныеДанные)

    РазмерЧасти    = 268435456;
    ПрочитанноБайт = 0;
    ТекущаяПозиция = 0;
    ОбщийРазмер    = ДвоичныеДанные.Размер();

    Пока ПрочитанноБайт < ОбщийРазмер Цикл

        ЧтениеДанных   = Новый ЧтениеДанных(ДвоичныеДанные);
        ПрочитанноБайт = ЧтениеДанных.Пропустить(ТекущаяПозиция);
        Результат      = ЧтениеДанных.Прочитать(РазмерЧасти);
        ТекущиеДанные  = Результат.ПолучитьДвоичныеДанные();
        РазмерТекущих  = ТекущиеДанные.Размер();

        Если Не ЗначениеЗаполнено(ТекущиеДанные) Тогда
            Прервать;
        КонецЕсли;

        ЗаписьДанных.Записать(ТекущиеДанные);

        // !OInt ОсвободитьОбъект(ТекущиеДанные);
        // !OInt ВыполнитьСборкуМусора();

        ТекущаяПозиция = ТекущаяПозиция + РазмерТекущих;

    КонецЦикла;

КонецПроцедуры

Процедура ЗвершитьЗаписьMultipart()

    Попытка
        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + Boundary + "--" + РазделительСтрок);
        ЗапросЗаписьДанных.Закрыть();
    Исключение
        ДобавитьЛог("ЗвершитьЗаписьMultipart: Не удалось закрыть запись. Возможно, она уже была закрыта");
    КонецПопытки;

    Если ТипЗнч(ЗапросПотокТела) = Тип("ПотокВПамяти") Тогда
        ЗапросТело = ЗапросПотокТела.ЗакрытьИПолучитьДвоичныеДанные();
    КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область GZip

// Описание структур см. здесь https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
// Источник: https://github.com/vbondarevsky/Connector

// Коннектор: удобный HTTP-клиент для 1С:Предприятие 8
//
// Copyright 2017-2023 Vladimir Bondarevskiy
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//
// URL:    https://github.com/vbondarevsky/Connector
// e-mail: vbondarevsky@gmail.com
// Версия: 2.4.8
//
// Требования: платформа 1С версии 8.3.10 и выше

// BSLLS:MagicNumber-off

Функция РаспаковатьОтвет(Ответ)

    Попытка
        Возврат ПрочитатьGZip(ПолучитьТелоОтветаКакДанныеИлиПуть());
    Исключение
        Возврат Ответ;
    КонецПопытки;

КонецФункции

Функция ПрочитатьGZip(СжатыеДанные)

    РазмерПрефиксаGZip  = 10;
    РазмерПостфиксаGZip = 8;

    РазмерДД  = ZipРазмерDD();
    РазмерСДХ = ZipРазмерCDH();
    РазмерЕСД = ZipРазмерEOCD();
    РазмерЛФХ = ZipРазмерLFH();

    ЧтениеДанных       = Новый ЧтениеДанных(СжатыеДанные);
    ЧтениеДанных.Пропустить(РазмерПрефиксаGZip);
    РазмерСжатыхДанных = ЧтениеДанных.ИсходныйПоток().Размер() - РазмерПрефиксаGZip - РазмерПостфиксаGZip;

    ПотокZip = Новый ПотокВПамяти(РазмерЛФХ + РазмерСжатыхДанных + РазмерДД + РазмерСДХ + РазмерЕСД);

    ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipLFH());
    ЧтениеДанных.КопироватьВ(ЗаписьДанных, РазмерСжатыхДанных);

    ЗаписьДанных.Закрыть();
    ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);

    CRC32                = ЧтениеДанных.ПрочитатьЦелое32();
    РазмерНесжатыхДанных = ЧтениеДанных.ПрочитатьЦелое32();
    ЧтениеДанных.Закрыть();

    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipDD(CRC32 , РазмерСжатыхДанных, РазмерНесжатыхДанных));
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipEOCD(РазмерСжатыхДанных));
    ЗаписьДанных.Закрыть();

    Возврат ПрочитатьZip(ПотокZip);

КонецФункции

Функция ПрочитатьZip(СжатыеДанные, ТекстОшибки = Неопределено)

    Каталог         = ПолучитьИмяВременногоФайла();
    ЧтениеZip       = Новый ЧтениеZipФайла(СжатыеДанные);
    ИмяФайла        = ЧтениеZip.Элементы[0].Имя;
    Попытка
        ЧтениеZip.Извлечь(ЧтениеZip.Элементы[0], Каталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
    Исключение
        // Игнорируем проверку целостности архива, просто читаем результат
        ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
    КонецПопытки;
    ЧтениеZip.Закрыть();

    Результат = Новый ДвоичныеДанные(Каталог + ПолучитьРазделительПути() + ИмяФайла);
    УдалитьФайлы(Каталог);

    Возврат Результат;

КонецФункции

Функция ZipРазмерLFH()

    Возврат 34;

КонецФункции

Функция ZipРазмерDD()

    Возврат 16;

КонецФункции

Функция ZipРазмерCDH()

    Возврат 50;

КонецФункции

Функция ZipРазмерEOCD()

    Возврат 22;

КонецФункции

Функция ZipLFH()

    // Local file header
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерLFH());
    Буфер.ЗаписатьЦелое32(0, 67324752); // signature 0x04034b50
    Буфер.ЗаписатьЦелое16(4, 20);       // version
    Буфер.ЗаписатьЦелое16(6, 10);       // bit flags
    Буфер.ЗаписатьЦелое16(8, 8);        // compression method
    Буфер.ЗаписатьЦелое16(10, 0);       // time
    Буфер.ЗаписатьЦелое16(12, 0);       // date
    Буфер.ЗаписатьЦелое32(14, 0);       // crc-32
    Буфер.ЗаписатьЦелое32(18, 0);       // compressed size
    Буфер.ЗаписатьЦелое32(22, 0);       // uncompressed size
    Буфер.ЗаписатьЦелое16(26, 4);       // filename legth - "data"
    Буфер.ЗаписатьЦелое16(28, 0);       // extra field length
    Буфер.Записать(30, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));

    Возврат Буфер;

КонецФункции

Функция ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

    // Data descriptor
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерDD());
    Буфер.ЗаписатьЦелое32(0, 134695760);
    Буфер.ЗаписатьЦелое32(4, CRC32);
    Буфер.ЗаписатьЦелое32(8, РазмерСжатыхДанных);
    Буфер.ЗаписатьЦелое32(12, РазмерНесжатыхДанных);

    Возврат Буфер;

КонецФункции

Функция ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

    // Central directory header
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерCDH());
    Буфер.ЗаписатьЦелое32(0, 33639248);              // signature 0x02014b50
    Буфер.ЗаписатьЦелое16(4, 798);                   // version made by
    Буфер.ЗаписатьЦелое16(6, 20);                    // version needed to extract
    Буфер.ЗаписатьЦелое16(8, 10);                    // bit flags
    Буфер.ЗаписатьЦелое16(10, 8);                    // compression method
    Буфер.ЗаписатьЦелое16(12, 0);                    // time
    Буфер.ЗаписатьЦелое16(14, 0);                    // date
    Буфер.ЗаписатьЦелое32(16, CRC32);                // crc-32
    Буфер.ЗаписатьЦелое32(20, РазмерСжатыхДанных);   // compressed size
    Буфер.ЗаписатьЦелое32(24, РазмерНесжатыхДанных); // uncompressed size
    Буфер.ЗаписатьЦелое16(28, 4);                    // file name length
    Буфер.ЗаписатьЦелое16(30, 0);                    // extra field length
    Буфер.ЗаписатьЦелое16(32, 0);                    // file comment length
    Буфер.ЗаписатьЦелое16(34, 0);                    // disk number start
    Буфер.ЗаписатьЦелое16(36, 0);                    // internal file attributes
    Буфер.ЗаписатьЦелое32(38, 2176057344);           // external file attributes
    Буфер.ЗаписатьЦелое32(42, 0);                    // relative offset of local header
    Буфер.Записать(46, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));

    Возврат Буфер;

КонецФункции

Функция ZipEOCD(РазмерСжатыхДанных)

    // End of central directory
    РазмерCDH = 50;
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерEOCD());
    Буфер.ЗаписатьЦелое32(0, 101010256); // signature 0x06054b50
    Буфер.ЗаписатьЦелое16(4, 0); // number of this disk
    Буфер.ЗаписатьЦелое16(6, 0); // number of the disk with the start of the central directory
    Буфер.ЗаписатьЦелое16(8, 1); // total number of entries in the central directory on this disk
    Буфер.ЗаписатьЦелое16(10, 1); // total number of entries in the central directory
    Буфер.ЗаписатьЦелое32(12, РазмерCDH); // size of the central directory
    // offset of start of central directory with respect to the starting disk number
    Буфер.ЗаписатьЦелое32(16, ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD());
    Буфер.ЗаписатьЦелое16(20, 0); // the starting disk number

    Возврат Буфер;

КонецФункции

// BSLLS:MagicNumber-on

#КонецОбласти

#Область AWS4

Функция ДобавитьAWS4()

    ЗаголовокАвторизации = СоздатьЗаголовокАвторизации();

    Запрос.Заголовки.Вставить("Authorization", ЗаголовокАвторизации);

    Возврат ЭтотОбъект;

КонецФункции

Функция СоздатьЗаголовокАвторизации()

    AccessKey   = AuthДанные["AccessKey"];
    ТекущаяДата = ТекущаяУниверсальнаяДата();

    Запрос.Заголовки.Вставить("x-amz-date", OPI_Инструменты.ВременнаяМеткаISO(ТекущаяДата));
    Запрос.Заголовки.Вставить("Host"      , Соединение.Сервер);

    ОсновныеЧасти = ПолучитьОсновныеСоставляющиеПодписи(ТекущаяДата);

    Скоуп           = ОсновныеЧасти["Скоуп"];
    Сигнатура       = ОсновныеЧасти["Сигнатура"];
    КлючиЗаголовков = ОсновныеЧасти["КлючиЗаголовков"];

    ЗаголовокАвторизации = СформироватьЗаголовокАвторизации(AccessKey, Скоуп, Сигнатура, КлючиЗаголовков);

    Возврат ЗаголовокАвторизации;

КонецФункции

Функция ПолучитьОсновныеСоставляющиеПодписи(Знач ТекущаяДата)

    SecretKey = AuthДанные["SecretKey"];
    Region    = AuthДанные["Region"];
    Service   = AuthДанные["Service"];

    КлючПодписи        = ПолучитьКлючПодписи(SecretKey, Region, Service, ТекущаяДата);
    КаноническийЗапрос = СоздатьКаноническийЗапрос();
    Скоуп              = СоздатьСкоуп(Region, Service, ТекущаяДата);
    СтрокаДляПодписи   = СоздатьСтрокуПодписи(КаноническийЗапрос, Скоуп, ТекущаяДата);

    Сигнатура = OPI_Криптография.HMAC(КлючПодписи, СтрокаДляПодписи, "SHA256");
    Сигнатура = нРег(ПолучитьHexСтрокуИзДвоичныхДанных(Сигнатура));

    КлючиЗаголовков = ПолучитьСтрокуКлючейЗаголовков();

    СтруктураЧастей = Новый Структура;

    СтруктураЧастей.Вставить("Скоуп"          , Скоуп);
    СтруктураЧастей.Вставить("Сигнатура"      , Сигнатура);
    СтруктураЧастей.Вставить("КлючиЗаголовков", КлючиЗаголовков);

    Возврат СтруктураЧастей;

КонецФункции

Функция СформироватьЗаголовокАвторизации(Знач AccessKey, Знач Скоуп, Знач Сигнатура, Знач КлючиЗаголовков)

    ШаблонЗаголовка = "AWS4-HMAC-SHA256 "
        + "Credential=%1/%2, "
        + "SignedHeaders=%3, "
        + "Signature=%4";

    ЗаголовокАвторизации = СтрШаблон(ШаблонЗаголовка, AccessKey, Скоуп, КлючиЗаголовков, Сигнатура);

    Возврат ЗаголовокАвторизации;

КонецФункции

Функция ПолучитьКлючПодписи(Знач СекретныйКлюч, Знач Регион, Знач Сервис, Знач ТекущаяДата)

    СекретныйКлюч = ПолучитьДвоичныеДанныеИзСтроки("AWS4" + СекретныйКлюч);
    ДанныеДата    = ПолучитьДвоичныеДанныеИзСтроки(Формат(ТекущаяДата, "ДФ=yyyyMMdd;"));
    Регион        = ПолучитьДвоичныеДанныеИзСтроки(Регион);
    Сервис        = ПолучитьДвоичныеДанныеИзСтроки(Сервис);
    AWSЗапрос     = ПолучитьДвоичныеДанныеИзСтроки("aws4_request");
    SHA256_       = "SHA256";

    КлючДанных  = OPI_Криптография.HMAC(СекретныйКлюч, ДанныеДата, SHA256_);
    КлючРегиона = OPI_Криптография.HMAC(КлючДанных, Регион, SHA256_);
    КлючСервиса = OPI_Криптография.HMAC(КлючРегиона, Сервис, SHA256_);

    ФинальныйКлюч = OPI_Криптография.HMAC(КлючСервиса, AWSЗапрос, SHA256_);

    Возврат ФинальныйКлюч;

КонецФункции

Функция СоздатьКаноническийЗапрос()

    ШаблонЗапроса = "";
    ТелоЗапроса   = ПолучитьТелоЗапросаКакДвоичныеДанные();
    ХешСумма      = OPI_Криптография.Хеш(ТелоЗапроса, ХешФункция.SHA256);
    ЧислоЧастей   = 6;

    Запрос.Заголовки.Вставить("x-amz-content-sha256", нРег(ПолучитьHexСтрокуИзДвоичныхДанных(ХешСумма)));

    Для Н = 1 По ЧислоЧастей Цикл

        ШаблонЗапроса = ШаблонЗапроса + "%" + Строка(Н) + ?(Н = ЧислоЧастей, "", Символы.ПС);

    КонецЦикла;

    Метод            = вРег(ЗапросМетод);
    СтрокаURI        = ПолучитьСтрокуURI();
    СтрокаПараметров = ПолучитьСтрокуПараметров();
    СтрокаЗаголовков = ПолучитьСтрокуЗаголовков();
    СтрокаКлючей     = ПолучитьСтрокуКлючейЗаголовков();

    СтрокаХэша = нРег(ПолучитьHexСтрокуИзДвоичныхДанных(ХешСумма));

    КаноническийЗапрос = СтрШаблон(ШаблонЗапроса
        , Метод
        , СтрокаURI
        , СтрокаПараметров
        , СтрокаЗаголовков
        , СтрокаКлючей
        , СтрокаХэша);

    Возврат КаноническийЗапрос;

КонецФункции

Функция СоздатьСкоуп(Знач Регион, Знач Сервис, Знач ТекущаяДата)

    ДатаОбычная = Формат(ТекущаяДата, "ДФ=yyyyMMdd;");

    Скоуп = Новый Массив;
    Скоуп.Добавить(ДатаОбычная);
    Скоуп.Добавить(Регион);
    Скоуп.Добавить(Сервис);
    Скоуп.Добавить("aws4_request");

    СкоупСтрокой = СтрСоединить(Скоуп, "/");

    Возврат СкоупСтрокой;

КонецФункции

Функция СоздатьСтрокуПодписи(Знач КаноническийЗапрос, Знач Скоуп, Знач ТекущаяДата)

    ШаблонСтроки = "";
    Алгоритм     = "AWS4-HMAC-SHA256";
    ДатаISO      = OPI_Инструменты.ВременнаяМеткаISO(ТекущаяДата);
    ЧислоЧастей  = 4;

    КаноническийЗапрос = ПолучитьДвоичныеДанныеИзСтроки(КаноническийЗапрос);
    КаноническийЗапрос = OPI_Криптография.Хеш(КаноническийЗапрос, ХешФункция.SHA256);
    КаноническийЗапрос = нРег(ПолучитьHexСтрокуИзДвоичныхДанных(КаноническийЗапрос));

    Для Н = 1 По ЧислоЧастей Цикл

        ШаблонСтроки = ШаблонСтроки + "%" + Строка(Н) + ?(Н = ЧислоЧастей, "", Символы.ПС);

    КонецЦикла;

    СтрокаПодписи = СтрШаблон(ШаблонСтроки, Алгоритм, ДатаISO, Скоуп, КаноническийЗапрос);
    СтрокаПодписи = ПолучитьДвоичныеДанныеИзСтроки(СтрокаПодписи);

    Возврат СтрокаПодписи;

КонецФункции

Функция ПолучитьСтрокуКлючейЗаголовков()

    СписокЗаголовков = Новый СписокЗначений;

    Для Каждого Заголовок Из Запрос.Заголовки Цикл

        ТекущийКлюч  = Заголовок.Ключ;
        ТекущийКлючН = нРег(ТекущийКлюч);

        Если Не СтрНачинаетсяС(ТекущийКлючН, "host") И Не СтрНачинаетсяС(ТекущийКлючН, "x-amz") Тогда
            Продолжить;
        КонецЕсли;

        СтрокаЗаголовка = нРег(ТекущийКлюч);
        СписокЗаголовков.Добавить(СтрокаЗаголовка);

    КонецЦикла;

    СписокЗаголовков.СортироватьПоЗначению();

    СтрокаЗаголовков = СтрСоединить(СписокЗаголовков.ВыгрузитьЗначения(), ";");

    Возврат СтрокаЗаголовков;

КонецФункции

Функция ПолучитьСтрокуURI()

    URI = Запрос.АдресРесурса;
    URI = ?(СтрНачинаетсяС(URI, "/"), URI, "/" + URI);

    НачалоПараметров = СтрНайти(URI, "?");

    Если НачалоПараметров <> 0 Тогда
        URI = Лев(URI, НачалоПараметров - 1);
    КонецЕсли;

    Возврат URI;

КонецФункции

Функция ПолучитьСтрокуПараметров()

    URI              = Запрос.АдресРесурса;
    НачалоПараметров = СтрНайти(URI, "?");

    Если НачалоПараметров = 0 Тогда

        СтрокаПараметров = "";

    Иначе

        ДлинаURI         = СтрДлина(URI);
        СтрокаПараметров = Прав(URI, ДлинаURI - НачалоПараметров);
        ОбработатьСтрокуПараметровЗапроса(СтрокаПараметров);

    КонецЕсли;

    Возврат СтрокаПараметров;

КонецФункции

Функция ПолучитьСтрокуЗаголовков()

    СписокЗаголовков = Новый СписокЗначений;

    Для Каждого Заголовок Из Запрос.Заголовки Цикл

        ТекущийКлюч  = Заголовок.Ключ;
        ТекущийКлючН = нРег(ТекущийКлюч);

        Если Не СтрНачинаетсяС(ТекущийКлючН, "host") И Не СтрНачинаетсяС(ТекущийКлючН, "x-amz") Тогда
            Продолжить;
        КонецЕсли;

        СтрокаЗаголовка = нРег(ТекущийКлюч) + ":" + Заголовок.Значение;
        СписокЗаголовков.Добавить(СтрокаЗаголовка);

    КонецЦикла;

    СписокЗаголовков.СортироватьПоЗначению();

    СтрокаЗаголовков = СтрСоединить(СписокЗаголовков.ВыгрузитьЗначения(), Символы.ПС);
    СтрокаЗаголовков = СтрокаЗаголовков + Символы.ПС;

    Возврат СтрокаЗаголовков;

КонецФункции

Процедура ОбработатьСтрокуПараметровЗапроса(СтрокаПараметров)

    МассивПараметров = СтрРазделить(СтрокаПараметров, "&");
    СписокПараметров = Новый СписокЗначений();
    СписокПараметров.ЗагрузитьЗначения(МассивПараметров);

    СписокПараметров.СортироватьПоЗначению();
    МассивПараметров = СписокПараметров.ВыгрузитьЗначения();

    Для Н = 0 По МассивПараметров.ВГраница() Цикл

        ПараметрЗапроса = МассивПараметров[Н];

        Если СтрНайти(ПараметрЗапроса, "=") = 0 Тогда
            МассивПараметров[Н] = ПараметрЗапроса + "=";
        КонецЕсли;

    КонецЦикла;

    СтрокаПараметров = СтрСоединить(МассивПараметров, "&");

КонецПроцедуры

#КонецОбласти

#Область OAuth

Функция ДобавитьЗаголовокOAuthV1()

    ДобавитьЛог("ДобавитьЗаголовокOAuthV1: начало формирования заголовка");

    OAuthАлгоритм       = AuthДанные["OAuthАлгоритм"];
    OAuthХешФункция     = AuthДанные["OAuthХешФункция"];
    OAuthToken          = AuthДанные["OAuthToken"];
    OAuthSecret         = AuthДанные["OAuthSecret"];
    OAuthConsumerKey    = AuthДанные["OAuthConsumerKey"];
    OAuthConsumerSecret = AuthДанные["OAuthConsumerSecret"];
    OAuthВерсияAPI      = AuthДанные["OAuthВерсияAPI"];

    МетодХэширования     = OAuthАлгоритм + "-" + OAuthХешФункция;
    ТекущаяДата          = OPI_Инструменты.ПолучитьТекущуюДату();
    ЗаголовокАвторизации = "";
    СтрокаСигнатуры      = "";
    Подпись              = "";

    ТекущаяДатаUNIX = OPI_Инструменты.UNIXTime(ТекущаяДата);
    ТекущаяДатаUNIX = OPI_Инструменты.ЧислоВСтроку(ТекущаяДатаUNIX);

    ТаблицаПараметров = Новый ТаблицаЗначений;
    ТаблицаПараметров.Колонки.Добавить("Ключ");
    ТаблицаПараметров.Колонки.Добавить("Значение");

    Если ПолучитьНастройку("ПоляТелаВOAuth") Тогда

        ДобавитьЛог("ДобавитьЗаголовокOAuthV1: добавление полей тела в строку для подписи");

        ГарантироватьТелоКоллекцию();

        Для Каждого Поле Из ЗапросТелоКоллекция Цикл

            ТекущееЗначение = Поле.Значение;

            Если ТипЗнч(ТекущееЗначение) = Тип("ДвоичныеДанные") Тогда
                Продолжить;
            Иначе
                OPI_ПреобразованиеТипов.ПолучитьСтроку(ТекущееЗначение);
            КонецЕсли;

            НоваяСтрока          = ТаблицаПараметров.Добавить();
            НоваяСтрока.Ключ     = Поле.Ключ;
            НоваяСтрока.Значение = ТекущееЗначение;

        КонецЦикла;
    КонецЕсли;

    Если ЗначениеЗаполнено(ЗапросПараметрыURL) Тогда

        ДобавитьЛог("ДобавитьЗаголовокOAuthV1: добавление параметров URL в строку для подписи");

        Для Каждого ПараметрURL Из ЗапросПараметрыURL Цикл

            НоваяСтрока          = ТаблицаПараметров.Добавить();
            НоваяСтрока.Ключ     = ПараметрURL.Ключ;
            НоваяСтрока.Значение = ПараметрURL.Значение;

        КонецЦикла;

    КонецЕсли;

    ДобавитьЛог("ДобавитьЗаголовокOAuthV1: дополнение строки для подписи учетными данными");

    НоваяСтрока          = ТаблицаПараметров.Добавить();
    НоваяСтрока.Ключ     = "oauth_consumer_key";
    НоваяСтрока.Значение = OAuthConsumerKey;

    НоваяСтрока          = ТаблицаПараметров.Добавить();
    НоваяСтрока.Ключ     = "oauth_token";
    НоваяСтрока.Значение = OAuthToken;

    НоваяСтрока          = ТаблицаПараметров.Добавить();
    НоваяСтрока.Ключ     = "oauth_version";
    НоваяСтрока.Значение = OAuthВерсияAPI;

    НоваяСтрока          = ТаблицаПараметров.Добавить();
    НоваяСтрока.Ключ     = "oauth_signature_method";
    НоваяСтрока.Значение = МетодХэширования;

    НоваяСтрока          = ТаблицаПараметров.Добавить();
    НоваяСтрока.Ключ     = "oauth_timestamp";
    НоваяСтрока.Значение = ТекущаяДатаUNIX;

    НоваяСтрока          = ТаблицаПараметров.Добавить();
    НоваяСтрока.Ключ     = "oauth_nonce";
    НоваяСтрока.Значение = ТекущаяДатаUNIX;

    Для Каждого СтрокаТаблицы Из ТаблицаПараметров Цикл

        СтрокаТаблицы.Ключ     = КодироватьСтроку(СтрокаТаблицы.Ключ, СпособКодированияСтроки.КодировкаURL);
        СтрокаТаблицы.Значение = КодироватьСтроку(СтрокаТаблицы.Значение, СпособКодированияСтроки.КодировкаURL);

    КонецЦикла;

    ТаблицаПараметров.Сортировать("Ключ");

    Для Каждого СтрокаТаблицы Из ТаблицаПараметров Цикл

        СтрокаСигнатуры = СтрокаСигнатуры
            + СтрокаТаблицы.Ключ

            + "="
            + СтрокаТаблицы.Значение
            + "&";

    КонецЦикла;

    СтрокаСигнатуры = Лев(СтрокаСигнатуры, СтрДлина(СтрокаСигнатуры) - 1);
    СтрокаСигнатуры = вРег(ЗапросМетод)
        + "&"
        + КодироватьСтроку(ЗапросURL      , СпособКодированияСтроки.КодировкаURL)
        + "&"
        + КодироватьСтроку(СтрокаСигнатуры, СпособКодированияСтроки.КодировкаURL);

    Подпись = КодироватьСтроку(OAuthConsumerSecret, СпособКодированияСтроки.КодировкаURL)
        + "&"
        + КодироватьСтроку(OAuthSecret, СпособКодированияСтроки.КодировкаURL);

    ПодписьДД   = ПолучитьДвоичныеДанныеИзСтроки(Подпись);
    СигнатураДД = ПолучитьДвоичныеДанныеИзСтроки(СтрокаСигнатуры);

    ДобавитьЛог("ДобавитьЗаголовокOAuthV1: создание подписи");

    Сигнатура = OPI_Криптография.СоздатьПодпись(ПодписьДД, СигнатураДД, OAuthАлгоритм, OAuthХешФункция);
    Сигнатура = КодироватьСтроку(Base64Строка(Сигнатура), СпособКодированияСтроки.КодировкаURL);

    Разделитель = """,";

    ДобавитьЛог("ДобавитьЗаголовокOAuthV1: создание заголовка авторизации");

    ЗаголовокАвторизации = ЗаголовокАвторизации
        + "OAuth "
        + "oauth_consumer_key="""      + OAuthConsumerKey      + Разделитель

        + "oauth_token="""             + OAuthToken            + Разделитель

        + "oauth_signature_method="""  + МетодХэширования      + Разделитель

        + "oauth_timestamp="""         + ТекущаяДатаUNIX       + Разделитель

        + "oauth_nonce="""             + ТекущаяДатаUNIX       + Разделитель

        + "oauth_version="""           + OAuthВерсияAPI        + Разделитель

        + "oauth_signature="           + Сигнатура;

    Запрос.Заголовки.Вставить("Authorization", ЗаголовокАвторизации);

    Возврат ЭтотОбъект;

КонецФункции

#КонецОбласти

#Область Вспомогательные

Функция ОстановитьРаботу(Знач ИсключениеПриОшибке = Ложь)

    OPI_ПреобразованиеТипов.ПолучитьБулево(ИсключениеПриОшибке);

    ЕстьОшибка = ЗапросИнициализирован().Ошибка;

    Если ЕстьОшибка И ИсключениеПриОшибке Тогда
        ВызватьИсключение ПолучитьЛог(Истина);
    Иначе
        Возврат ЕстьОшибка;
    КонецЕсли;

КонецФункции

Функция ЗапросИнициализирован()

    Возврат ?(ЗначениеЗаполнено(Инициализирован)
        , ЭтотОбъект
        , Ошибка("Запрос не инициализирован. Необходимо вызвать функцию Инициализировать() перед началом работы"));

КонецФункции

Функция Ошибка(Знач ТекстОшибки)

    Ошибка = Истина;

    Если ФайлТелаВременный И ЗначениеЗаполнено(ЗапросФайлТела) Тогда

        Попытка
            УдалитьФайлы(ЗапросФайлТела);
            ЗапросФайлТела    = Неопределено;
            ФайлТелаВременный = Ложь;
        Исключение
            ДобавитьЛог("Ошибка: Не удалось удалить временный файл при исключении");
        КонецПопытки;

    КонецЕсли;

    Возврат ДобавитьЛог(ТекстОшибки);

КонецФункции

Функция ДобавитьЛог(Знач Текст)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Текст);

    Лог.Добавить(Текст);

    OPI_Инструменты.ОтладочнаяИнформация(Текст);

    Возврат ЭтотОбъект;

КонецФункции

Функция ПолучитьНастройку(Знач КлючНастройки)
    Возврат Настройки[КлючНастройки];
КонецФункции

Процедура УстановитьНастройку(Знач КлючНастройки, Знач Значение)
    Настройки[КлючНастройки] = Значение;
КонецПроцедуры

Процедура УстановитьСтандартныеНастройки()

    ДобавитьЛог("УстановитьСтандартныеНастройки: установка настроек");

    Настройки = Новый Структура;
    Настройки.Вставить("gzip"                     , Истина);
    Настройки.Вставить("ОтдельныеЭлементыМассивов", Ложь);
    Настройки.Вставить("КвадратныеСкобкиМассивов" , Ложь);
    Настройки.Вставить("КодировкаURL"             , Истина);
    Настройки.Вставить("КодировкаТелаЗапроса"     , "UTF-8");
    Настройки.Вставить("ПоляТелаВOAuth"           , Ложь);

КонецПроцедуры

Процедура КодироватьURLВURL(URL) Экспорт

    Заглушка = СтрШаблон("@#%1#@", Строка(Новый УникальныйИдентификатор));

    URL = СтрЗаменить(URL, "&"     , Заглушка);
    URL = КодироватьСтроку(URL, СпособКодированияСтроки.URLВКодировкеURL);
    URL = СтрЗаменить(URL, Заглушка, "&");

КонецПроцедуры

Процедура ГарантироватьТелоКоллекцию()

    Если Не ЗначениеЗаполнено(ЗапросТелоКоллекция)
        Или Не OPI_Инструменты.ЭтоКоллекция(ЗапросТелоКоллекция, Истина) Тогда

        Попытка
            ЗапросТелоКоллекция = ЗапросТело;
            OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(ЗапросТелоКоллекция);
        Исключение
            ЗапросТелоКоллекция = Новый Структура;
        КонецПопытки;

        ЗапросТелоКоллекция = ?(ЗначениеЗаполнено(ЗапросТелоКоллекция), ЗапросТелоКоллекция, Новый Структура);

    КонецЕсли;

КонецПроцедуры

#КонецОбласти

#КонецОбласти

#КонецЕсли
