
#Область Ссылки

// https://github.com/tporadowski/redis           - Redis 5.0.14 for Windows
// https://github.com/tporadowski/rejson          - JSON module 1.0.6 for Windows

// https://github.com/zkteco-home/redis-windows   - Redis 8.4.0 for Windows
// https://github.com/zkteco-home/RedisJson       - JSON module 2.8.0 for Windows

#КонецОбласти

#Область ПрограммныйИнтерфейс

// TODO: В случае если массив с таким ключом уже существует, то метод RPUSH в
//       функции УстановитьЗначение не создаст новое значение, а добавт элементы
//       в существующий массив. Мне представляется это некорректным поведением. Исправить!

// Устанавливает новое или изменяет существующее значение на сервере Redis с заданным ключом
// При совпадении ключей, данные с типом "Строка" перетирают массивы и хэш-таблицы (структуры
// и соответствия). Но при попытке записать хэш-таблицу поверх строки будет вызвано исключение.
// Это задокументированное поведение Redis.
//
// Параметры:
//  АдресСервераRedis - Строка      - Адрес и порт для подключения
//  Ключ              - Строка      - Ключ с которым будет схранено значение на сервере
//  Данные            - Строка      - Строковые данные для помещения в Redis
//                    - Массив      - Массив строк
//                    - Структура   - Где:
//                        * Ключ - Строка - Имя поля хэш-таблицы
//                        * Значение - Строка - Значение поля хэш-таблицы
//                    - Соответствие - Где:
//                        * Ключ - Строка - Имя поля хэш-таблицы
//                        * Значение - Строка - Значение поля хэш-таблицы
//
// Возвращаемое значение:
//  Булево - Истина если помещение данных произведено успешно, ложь - значение не было сохранено
//
Функция УстановитьЗначение(АдресСервераRedis, Ключ, Данные) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда
		Возврат УстановитьСтроку(АдресСервераRedis, Ключ, Данные);
	ИначеЕсли ТипЗнч(Данные) = Тип("Массив") Тогда
		Возврат ДобавитьЭлементыВМассив(АдресСервераRedis, Ключ, Данные);
	КонецЕсли;
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ сохраняемого значения не может быть пустым.";
	КонецЕсли;
	Если Не ВозможнаСериализация(Данные) Тогда
		ВызватьИсключение "Переданные данные невозможно поместиь в Redis.";
	КонецЕсли;
	
	Маркер = Маркер();
	Если Данные.Количество() = 0 Тогда
		ВызватьИсключение ?(ТипЗнч(Данные) = Тип("Структура"), "Структура должна", "Соответствие должно") +
			" содержать хотя бы одно значение.";
	КонецЕсли;

	Команда = СтрШаблон("*%1%4$4%4HSET%4$%3%4%2%4",
		Формат(Данные.Количество() * 2 + 2, "ЧН=; ЧГ=0"),
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);

	Для каждого КлючЗначение Из Данные Цикл
		Команда = Команда + СтрШаблон("$%2%5%1%5$%4%5%3%5",
			КлючЗначение.Ключ, СтрДлинаВБайтах(КлючЗначение.Ключ),
			КлючЗначение.Значение, СтрДлинаВБайтах(КлючЗначение.Значение),
			Маркер);
	КонецЦикла;

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
	Если Не СтрНачинаетсяС(ПерваяСтрокаОтвета, "-")
		// Здесь поставил условием любое число. Даже ноль. Т.к. элементы в хэшах могут
		// не только добавляться, но и обновляться. А возвращается количество новых (добавленных)
		И Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", "")) >= 0 Тогда 
			
		Возврат Истина;
		
	КонецЕсли;

	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Возвращает значение с сервера Redis по ключу
// Если читается хэш-таблица, то имена полей будут проверены на возможность использования в
// структуре и при корректных значениях будет возвращена Структура. В противном случае - Соответствие.
// Для принудительного чтения значения в Соответствие можно использовать функцию ПолучитьХэшТаблицу
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ по которому будет запрашиваться значение с сервера
//
// Возвращаемое значение:
//  Строка, Массив, Структура, Соответствие - Значение полученное из сервера Redis.
//
Функция ПолучитьЗначение(АдресСервераRedis, Ключ) Экспорт
	
	Значение = Неопределено;
	
	Попытка
		ТипДанных = ТипДанных(АдресСервераRedis, Ключ);
		Если ТипДанных = "string" Тогда
			Значение = ПолучитьСтроку(АдресСервераRedis, Ключ);
		ИначеЕсли ТипДанных = "list" Тогда
			Значение = ПолучитьМассив(АдресСервераRedis, Ключ);
		ИначеЕсли ТипДанных = "hash" Тогда
			Значение = ПолучитьХэшТаблицу(АдресСервераRedis, Ключ);
		Иначе // none
		КонецЕсли;
	Исключение
		// TODO:
	КонецПопытки;
	
	Возврат Значение;
	
КонецФункции

// Проверяет существование на сервере Redis записи с опреденным ключом
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ по которому будет осуществляться проверка наличия записи
//
// Возвращаемое значение:
//  Булево - Истина если запись с таким ключом существкет, ложь - запись отсутствует
//
Функция ПроверитьСуществованиеКлюча(АдресСервераRedis, Ключ) Экспорт
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ для проверки наличия записи не может быть пустым.";
	КонецЕсли;
	Если Не СтрНайти(Ключ, " ") = 0 Тогда
		ВызватьИсключение "Ключ для проверки наличия записи не может содержать пробелы.";
	КонецЕсли;

	Маркер = Маркер();
	Команда = СтрШаблон("*2%3$6%3EXISTS%3$%2%3%1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, ":") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", "")) = 1;
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Находит все ключи на сервере Redis по заданному шаблону
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  ШаблонКлюча       - Строка - Шаблон по которому будет осуществляться поиск ключей. Пример шаблона "user:*"
//  Асинхронно        - Булево - Флаг используемой команды. Истина - SCAN, Ложь - KEYS
//
// Возвращаемое значение:
//  Массив - найденные ключи удовлетворяющие переданному шаблону
//
Функция НайтиКлючиПоШаблону(АдресСервераRedis, ШаблонКлюча, Асинхронно = Истина) Экспорт

	Если ПустаяСтрока(ШаблонКлюча) Тогда
		ВызватьИсключение "Шаблон для поиска ключей значений не может быть пустым.";
	КонецЕсли;
	
	Маркер = Маркер();
	Если Асинхронно Тогда
		Команда = СтрШаблон("*4%4$4%4SCAN%4$1%4%3%4$5%4MATCH%4$%2%4%1%4",
			ШаблонКлюча, СтрДлинаВБайтах(ШаблонКлюча), 0, Маркер);
	Иначе
		Команда = СтрШаблон("*2%3$4%3KEYS%3$%2%3%1%3",
			ШаблонКлюча, СтрДлинаВБайтах(ШаблонКлюча), Маркер);
	КонецЕсли;

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "*") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		ЧислоКлючей = Число(СтрЗаменить(ПерваяСтрокаОтвета, "*", ""));
		
		МассивКлючей = Новый Массив;
		Для Сч = 1 По ЧислоКлючей Цикл
			МассивКлючей.Добавить(СтрПолучитьСтроку(РезультатВызова, Сч * 2 + 1));
		КонецЦикла;
		
		Возврат МассивКлючей;
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Удаляет значение с сервера Redis по ключу
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ по которому будет осуществляться удаление значения
//  Асинхронно        - Булево - Флаг используемой команды. Истина - UNLINK, Ложь - DEL
//
// Возвращаемое значение:
//  Булево - Истина если удаление произведено успешно, ложь - значение с таким ключом не найдено
//
Функция УдалитьЗначение(АдресСервераRedis, Ключ, Асинхронно = Истина) Экспорт
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ удаляемого значения не может быть пустым.";
	КонецЕсли;

	Маркер = Маркер();
	Команда = СтрШаблон("*2%3$" + ?(Асинхронно, "6%3UNLINK", "3%3DEL") + "%3$%2%3%1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, ":") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", "")) = 1;
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Возвращает тип данных на сервере Redis по ключу
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ по которому будет запрашиваться значение с сервера
//
// Возвращаемое значение:
//  Строка - Тип данных на сервере Redis по данному ключу. Возможные значения: "string", "list", "hash", "json", "none"
//
Функция ТипДанных(АдресСервераRedis, Ключ) Экспорт
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ для проверки типа записи не может быть пустым.";
	КонецЕсли;
	
	Маркер = Маркер();
	Команда = СтрШаблон("*2%3$4%3TYPE%3$%2%3%1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "+") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат СтрЗаменить(ПерваяСтрокаОтвета, "+", "");
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Удаляет все ключи из всех баз данных Redis
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//
// Возвращаемое значение:
//  Булево - Истина если команда выполнена успешно, ложь - ключи не были удалены
//
Функция ОчиститьВсе(АдресСервераRedis, Асинхронно = Истина) Экспорт
	
	Маркер = Маркер();
	Если Асинхронно Тогда
		Команда = СтрШаблон("*2%1$8%1FLUSHALL%1$5%1ASYNC%1", Маркер);
	Иначе
		// Флаг SYNC для синхронного режима появился только в версии 6.2.0. Потому для совместимости не использую
		Команда = СтрШаблон("*1%1$8%1FLUSHALL%1", Маркер);
	КонецЕсли;

	// На этой команде периодически происходит подвисание сервера Redis. Моё предположение это связано
	// с операцией с файлом БД. Он пересоздаётся и записывается заново. Потому вот такой костыль.
	СчПопыток = 0;
	Пока Истина Цикл
		Попытка
			РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
			Если СтрНачинаетсяС(РезультатВызова, "+") Тогда
				ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
				Возврат ПерваяСтрокаОтвета = "+OK";
			КонецЕсли;
			
			ВызватьИсключение РезультатВызова;
		Исключение
			СчПопыток = СчПопыток + 1;
			Если СчПопыток > 5 Тогда
				Прервать;
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Если СчПопыток > 5 Тогда
		ВызватьИсключение "Не удалось выполнить действие очистки БД Redis";
	КонецЕсли;

КонецФункции

// Возвращает оставшееся время жизни (ttl) значения на сервере Redis
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ для которого будет получено оставшееся время жизни значения на сервере
//
// Возвращаемое значение:
//  Число, Неопределено - Оставшееся время жизни значения на сервере Redis в секундах. 0 - время жизни для значения не установлено.
//
Функция ПолучитьВремяЖизни(АдресСервераRedis, Ключ) Экспорт
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ для получения оставшегося времени жизни записи не может быть пустым.";
	КонецЕсли;
	
	Маркер = Маркер();
	Команда = СтрШаблон("*2%3$3%3TTL%3$%2%3%1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, ":-1") Тогда
		Возврат 0;
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, ":-2") Тогда
		Возврат Неопределено;
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, ":") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", ""));
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Устанавливает время жизни (ttl) значения на сервере Redis
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ для которого будет установлено время жизни значения в секундах
//  ВремяЖизни        - Число  - Время жизни значения на сервере Redis в секундах
//
// Возвращаемое значение:
//  Булево - Истина если обновление времени жизни значения произведено успешно, ложь - время жизни не было обновлено
//
Функция УстановитьВремяЖизни(АдресСервераRedis, Ключ, ВремяЖизни) Экспорт
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ для установки времени жизни записи не может быть пустым.";
	КонецЕсли;

	Если ВремяЖизни < 0 Тогда
		_ВремяЖизни = "0";
	Иначе
		_ВремяЖизни = Формат(ВремяЖизни, "ЧН=; ЧГ=0");
	КонецЕсли;
	
	Маркер = Маркер();
	Команда = СтрШаблон("*3%5$6%5EXPIRE%5$%2%5%1%5$%4%5%3%5",
		Ключ, СтрДлинаВБайтах(Ключ),
		_ВремяЖизни, СтрДлина(_ВремяЖизни),
		Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, ":") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", "")) = 1;
	КонецЕсли;

	ВызватьИсключение РезультатВызова;

КонецФункции

#Область РаботаСоСтрокой

// Устанавливает новое или изменят существующее значение строкового типа на сервере Redis
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ с которым будет схранено значение на сервере
//  Данные            - Строка - Строковые данные для помещения в Redis
//  ВремяЖизни        - Число  - Время жизни значения на сервере Redis в секундах
//
// Возвращаемое значение:
//  Булево - Истина если помещение данных произведено успешно, ложь - значение не было сохранено
//
Функция УстановитьСтроку(АдресСервераRedis, Ключ, Данные, ВремяЖизни = 0) Экспорт
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ сохраняемого значения не может быть пустым.";
	КонецЕсли;
	
	Если ВремяЖизни < 0 Тогда
		_ВремяЖизни = "0";
	Иначе
		_ВремяЖизни = Формат(ВремяЖизни, "ЧН=; ЧГ=0");
	КонецЕсли;

	Маркер = Маркер();
	Если _ВремяЖизни = "0" Тогда
		Команда = СтрШаблон("*3%5$3%5SET%5$%2%5%1%5$%4%5%3%5",
			Ключ, СтрДлинаВБайтах(Ключ), Данные, СтрДлинаВБайтах(Данные),
			Маркер);
	Иначе
		Команда = СтрШаблон("*4%7$3%7SET%7$%2%7%1%7$%4%7%3%7$2%7EX%7%6%7%5%7",
			Ключ, СтрДлинаВБайтах(Ключ),
			Данные, СтрДлинаВБайтах(Данные),
			_ВремяЖизни, СтрДлина(_ВремяЖизни),
			Маркер);
	КонецЕсли;

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "+") Тогда 
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат ПерваяСтрокаОтвета = "+OK";
	КонецЕсли;

	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Получает строковое значение с сервера Redis по ключу
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ по которому будет запрашиваться значение с сервера
//
// Возвращаемое значение:
//  Строка - Значение полученное из сервера Redis
//
Функция ПолучитьСтроку(АдресСервераRedis, Ключ) Экспорт
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ получаемой строки не может быть пустым.";
	КонецЕсли;

	Маркер = Маркер();
	Команда = СтрШаблон("*2%3$3%3GET%3$%2%3%1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "$") Тогда
		Если СтрНачинаетсяС(РезультатВызова, "$-1") Тогда
			Возврат Неопределено;
		Иначе
			Результат = "";
			ЧислоСтрок = СтрЧислоСтрок(РезультатВызова);
			Для Сч = 2 По ЧислоСтрок Цикл
				Результат = Результат + СтрПолучитьСтроку(РезультатВызова, Сч) +
					?(Сч < ЧислоСтрок, Маркер, "");
			КонецЦикла;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;

КонецФункции

#КонецОбласти

#Область РаботаСМассивом

// Добавляет элементы в массив на сервере Redis. В случае если массива с таким ключом не существует,
// то создаёт новое значение
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ по которому будет запрашиваться значение с сервера
//  Данные            - Массив - Данные для помещения в Redis
//  МестоДобавления   - Строка - Признак, добавляются элементы "ВНачало" массива или "ВКонец"
//
// Возвращаемое значение:
//  Булево - Истина если помещение данных произведено успешно, ложь - значение не было сохранено
//
Функция ДобавитьЭлементыВМассив(АдресСервераRedis, Ключ, Данные, МестоДобавления = "ВКонец") Экспорт

	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ сохраняемого значения не может быть пустым.";
	КонецЕсли;
	Если Не ВозможнаСериализация(Данные) Тогда
		ВызватьИсключение "Переданные данные невозможно поместиь в Redis.";
	КонецЕсли;
	Если Данные.Количество() = 0 Тогда
		ВызватьИсключение "Массив должен содержать хотя бы одну строку.";
	КонецЕсли;
		
	Маркер = Маркер();
	Команда = СтрШаблон("*%1%4$5%4" + ?(МестоДобавления = "ВКонец", "RPUSH", "LPUSH") + "%4$%3%4%2%4",
		Формат(Данные.Количество() + 2, "ЧН=; ЧГ=0"),
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);
		
	Для каждого ЭлементМассива Из Данные Цикл
		Команда = Команда + СтрШаблон("$%2%3%1%3",
			ЭлементМассива, СтрДлинаВБайтах(ЭлементМассива), Маркер);
	КонецЦикла;

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
	Если СтрНачинаетсяС(ПерваяСтрокаОтвета, ":")
		И Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", "")) = Данные.Количество() Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Возвращает массив строк с сервера Redis по ключу
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ по которому будет запрашиваться значение с сервера
//
// Возвращаемое значение:
//  Массив - Значение полученное из сервера Redis
//
Функция ПолучитьМассив(АдресСервераRedis, Ключ) Экспорт
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ получаемого массива не может быть пустым.";
	КонецЕсли;
	
	Маркер = Маркер();
	Команда = СтрШаблон("*4%3$6%3LRANGE%3$%2%3%1%3$1%3%4%3$2%3-1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер, 0);
		
	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);

	Если СтрНачинаетсяС(РезультатВызова, "*") Тогда
		
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		КоличествоЭлементов = Число(СтрЗаменить(ПерваяСтрокаОтвета, "*", ""));
		
		Результат = Новый Массив;
		НомерСледующейСтроки = 2;
		Для Сч = 1 По КоличествоЭлементов Цикл
			// TODO: Алгоритм разбора многострочных значений выглядит несколько коряво. Придумать лучше?
			
			СтрокаСДлинойЗначения = СтрПолучитьСтроку(РезультатВызова, НомерСледующейСтроки);
			Если СтрНачинаетсяС(СтрокаСДлинойЗначения, "$") Тогда
				ДлинаЗначения = Число(СтрЗаменить(СтрокаСДлинойЗначения, "$", ""));
				
				ЗначениеЭлементаМассива = "";
				
				ПрочитаноБайтов = 0;
				НомерСледующейСтроки = НомерСледующейСтроки + 1;
				Пока ПрочитаноБайтов < ДлинаЗначения Цикл
					ОчереднаяСтрока = СтрПолучитьСтроку(РезультатВызова, НомерСледующейСтроки);
					ЗначениеЭлементаМассива = ЗначениеЭлементаМассива + ОчереднаяСтрока;
					
					ПрочитаноБайтов = ПрочитаноБайтов + СтрДлинаВБайтах(ОчереднаяСтрока);
					Если ПрочитаноБайтов < ДлинаЗначения Тогда
						ЗначениеЭлементаМассива = ЗначениеЭлементаМассива + Символы.ПС;
						ПрочитаноБайтов = ПрочитаноБайтов + 1;
					КонецЕсли;
					
					НомерСледующейСтроки = НомерСледующейСтроки + 1;
				КонецЦикла;
				
				Результат.Добавить(ЗначениеЭлементаМассива);
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Результат;
		
	КонецЕсли;

	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Возвращает количество строк в массиве БД Redis
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ по которому будет запрашиваться значение с сервера
//
// Возвращаемое значение:
//  Число, Неопределено - 
//
Функция КоличествоСтрокМассива(АдресСервераRedis, Ключ) Экспорт
	
	Маркер = Маркер();
	Команда = СтрШаблон("*2%3$4%3LLEN%3$%2%3%1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "-WRONGTYPE") Тогда
		// Если значение для ключа не массив это не нормальная ситуация. Будет вызвано исключение
		// только с более вменяемым текстом
		ВызватьИсключение СтрШаблон("Значение в БД Redis для ключа ""%1"" не являеся массивом", Ключ);
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, ":0") Тогда
		// Массивов с нулевым количеством строк в Redis быть не может. То что вернулось "0"
		// означает что значения с таким ключом нет в БД. Возвращать "0" всё равно не буду
		// для единообразия ответов с функцией ПолучитьСтрокуМассива
		Возврат Неопределено;
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, ":") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", ""));
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Возвращает значение строки массива в БД Redis по номеру строки
//
// Параметры:
//  АдресСервераRedis - Строка - Адрес и порт для подключения
//  Ключ              - Строка - Ключ по которому будет запрашиваться значение с сервера
//  НомерСтроки       - Число  - Номер получаемой строки
//
// Возвращаемое значение:
//  Строка, Неопределено - 
//
Функция ПолучитьСтрокуМассива(АдресСервераRedis, Ключ, НомерСтроки) Экспорт
	
	Маркер = Маркер();
	Команда = СтрШаблон("*3%5$6%5LINDEX%5$%2%5%1%5$%4%5%3%5",
		Ключ, СтрДлинаВБайтах(Ключ),
		Формат(НомерСтроки, "ЧН=; ЧГ=0"), Формат(СтрДлина(НомерСтроки), "ЧН=; ЧГ=0"),
		Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "-WRONGTYPE") Тогда
		// Если значение для ключа не массив это не нормальная ситуация. Будет вызвано исключение
		// только с более вменяемым текстом
		ВызватьИсключение СтрШаблон("Значение в БД Redis для ключа ""%1"" не являеся массивом", Ключ);
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, "$") Тогда
		Если СтрНачинаетсяС(РезультатВызова, "$-1") Тогда
			// При некорректном номере строки и при отсутствующем в БД ключе возврат от Redis
			// одинаковый. Так что разделить ответы для этих двух ситуаций не могу
			Возврат Неопределено;
		Иначе
			Результат = "";
			ЧислоСтрок = СтрЧислоСтрок(РезультатВызова);
			Для Сч = 2 По ЧислоСтрок Цикл
				Результат = Результат + СтрПолучитьСтроку(РезультатВызова, Сч) +
					?(Сч < ЧислоСтрок, Маркер, "");
			КонецЦикла;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Удаляет строки массива с сервера Redis по найденным значениям
//
// Параметры:
//  АдресСервераRedis   - Строка - Адрес и порт для подключения
//  Ключ                - Строка - Ключ по которому будет запрашиваться массив с сервера
//  НаправлениеУдаления - Число  - Управляет количеством удаляемых элементов и направлением операции.
//                                 Если значение больше 0, то удаляет указанное количество первых найденных элементов.
//                                 Если значение меньше 0, то удаляет указанное количество воследних найденных элементов.
//                                 Если значение равно 0, то удаляет все найденные элементы
//  ЗначениеЭлемента    - Строка - 
//
// Возвращаемое значение:
//  Число - Количество строк которые были удалены
//
Функция УдалитьСтрокиМассива(АдресСервераRedis, Ключ, НаправлениеУдаления, ЗначениеЭлемента) Экспорт
	
	Маркер = Маркер();
	Команда = СтрШаблон("*4%7$4%7LREM%7$%2%7%1%7$%6%7%5%7$%4%7%3%7",
		Ключ, СтрДлинаВБайтах(Ключ),
		ЗначениеЭлемента, СтрДлинаВБайтах(ЗначениеЭлемента),
		Формат(НаправлениеУдаления, "ЧН=; ЧГ=0"), Формат(СтрДлина(НаправлениеУдаления), "ЧН=; ЧГ=0"),
		Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "-WRONGTYPE") Тогда
		// Если значение для ключа не массив это не нормальная ситуация. Будет вызвано исключение
		// только с более вменяемым текстом
		ВызватьИсключение СтрШаблон("Значение в БД Redis для ключа ""%1"" не являеся массивом", Ключ);
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, ":") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", ""));
	КонецЕсли;

	ВызватьИсключение РезультатВызова;
	
КонецФункции

// TODO: Реализовать LPOP

#КонецОбласти

#Область РаботаСХэшТаблицей

// Возвращает хэш-таблицу с сервера Redis по ключу
//
// Параметры:
//  АдресСервераRedis   - Строка - Адрес и порт для подключения
//  Ключ                - Строка - Ключ по которому будет запрашиваться значение с сервера
//  СохранятьВСтруктуру - Булево - Признак того, что данные необходимо по возможности
//                                 сохранить в Структуру. Иначе функция вернёт Соответствие.
//
// Возвращаемое значение:
//  Структура, Соответствие - Значение полученное из сервера Redis
//
Функция ПолучитьХэшТаблицу(АдресСервераRedis, Ключ, СохранятьВСтруктуру = Истина) Экспорт
	
	Если ПустаяСтрока(Ключ) Тогда
		ВызватьИсключение "Ключ получаемой хэш-таблицы не может быть пустым.";
	КонецЕсли;

	Маркер = Маркер();
	Команда = СтрШаблон("*2%3$7%3HGETALL%3$%2%3%1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);
		
	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	
	Если СтрНачинаетсяС(РезультатВызова, "*") Тогда
		
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		КоличествоЭлементов = Число(СтрЗаменить(ПерваяСтрокаОтвета, "*", ""));
		
		Результат = Новый Соответствие;
		Для Сч = 1 По КоличествоЭлементов / 2 Цикл
			Результат.Вставить(СтрПолучитьСтроку(РезультатВызова, Сч * 4 - 1),
				СтрПолучитьСтроку(РезультатВызова, Сч * 4 + 1));
		КонецЦикла;
		
		Если СохранятьВСтруктуру И ВозможноСохранениеВСтруктуру(Результат) Тогда
			РезультатСтруктура = Новый Структура;
			Для каждого КлючЗначение Из Результат Цикл
				РезультатСтруктура.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
			КонецЦикла;
			
			Результат = РезультатСтруктура;
		КонецЕсли;
		
		Возврат Результат;
		
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Возвращает количество полей в хэш-таблице БД Redis
//
// Параметры:
//  АдресСервераRedis   - Строка - Адрес и порт для подключения
//  Ключ                - Строка - Ключ по которому будет запрашиваться количество полей с сервера
//
// Возвращаемое значение:
//  Число - количество полей в хэш-таблице
Функция КоличествоПолейХэшТаблицы(АдресСервераRedis, Ключ) Экспорт
	
	Маркер = Маркер();
	Команда = СтрШаблон("*2%3$4%3HLEN%3$%2%3%1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "-WRONGTYPE") Тогда
		// Если значение для ключа не хэш-таблица это не нормальная ситуация. Будет вызвано исключение
		// только с более вменяемым текстом
		ВызватьИсключение СтрШаблон("Значение в БД Redis для ключа ""%1"" не являеся хэш-таблицей", Ключ);
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, ":0") Тогда
		// Хэш-таблиц с нулевым количеством полей в Redis быть не может. То что вернулось "0"
		// означает что значения с таким ключом нет в БД. Возвращать "0" всё равно не буду
		// для единообразия ответов с функцией ПолучитьСтрокуМассива
		Возврат Неопределено;
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, ":") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", ""));
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Возвращает массив наименований полей с сервера Redis по ключу
//
// Параметры:
//  АдресСервераRedis   - Строка - Адрес и порт для подключения
//  Ключ                - Строка - Ключ по которому будет запрашиваться поля с сервера
//
// Возвращаемое значение:
//  Массив - наименования полей хэш-таблицы
Функция ПоляХэшТаблицы(АдресСервераRedis, Ключ) Экспорт
	
	Маркер = Маркер();
	Команда = СтрШаблон("*2%3$5%3HKEYS%3$%2%3%1%3",
		Ключ, СтрДлинаВБайтах(Ключ), Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "-WRONGTYPE") Тогда
		// Если значение для ключа не хэш-таблица это не нормальная ситуация. Будет вызвано исключение
		// только с более вменяемым текстом
		ВызватьИсключение СтрШаблон("Значение в БД Redis для ключа ""%1"" не являеся хэш-таблицей", Ключ);
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, "*") Тогда
		
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		КоличествоЭлементов = Число(СтрЗаменить(ПерваяСтрокаОтвета, "*", ""));
		
		Результат = Новый Массив;
		Для Сч = 1 По КоличествоЭлементов Цикл
			Результат.Добавить(СтрПолучитьСтроку(РезультатВызова, Сч * 2 + 1));
		КонецЦикла;
		
		Возврат Результат;
		
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Возвращает значение поля хэш-таблицы в БД Redis по наименованию поля
//
// Параметры:
//  АдресСервераRedis   - Строка - Адрес и порт для подключения
//  Ключ                - Строка - Ключ по которому будет запрашиваться значение поля с сервера
//  Поле                - Строка - Наименование поля для получения значения
//
// Возвращаемое значение:
//  Строка - значение поля хэш-таблицы
Функция ЗначениеПоляХэшТаблицы(АдресСервераRedis, Ключ, Поле) Экспорт
	
	Маркер = Маркер();
	Команда = СтрШаблон("*3%5$4%5HGET%5$%2%5%1%5$%4%5%3%5",
		Ключ, СтрДлинаВБайтах(Ключ),
		Поле, СтрДлинаВБайтах(Поле),
		Маркер);

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "-WRONGTYPE") Тогда
		// Если значение для ключа не хэш-таблица это не нормальная ситуация. Будет вызвано исключение
		// только с более вменяемым текстом
		ВызватьИсключение СтрШаблон("Значение в БД Redis для ключа ""%1"" не являеся хэш-таблицей", Ключ);
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, "$") Тогда
		
		Если СтрНачинаетсяС(РезультатВызова, "$-1") Тогда
			Возврат Неопределено;
		Иначе
			Результат = "";
			ЧислоСтрок = СтрЧислоСтрок(РезультатВызова);
			Для Сч = 2 По ЧислоСтрок Цикл
				Результат = Результат + СтрПолучитьСтроку(РезультатВызова, Сч) +
					?(Сч < ЧислоСтрок, Маркер, "");
			КонецЦикла;
			Возврат Результат;
		КонецЕсли;
		
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
	
КонецФункции

// Удаляет поля хэш-таблицы с сервера Redis по перечню полей
//
// Параметры:
//  АдресСервераRedis   - Строка - Адрес и порт для подключения
//  Ключ                - Строка - Ключ по которому будет произведено удаление полей с сервера
//  Поля                - Массив - Массив наименований удаляемых полей
//
// Возвращаемое значение:
//  Число - количество полей которые были удалены
Функция УдалитьПоляХэшТаблицы(АдресСервераRedis, Ключ, Поля) Экспорт
	
	Маркер = Маркер();
	КоличествоПолей = Поля.Количество();
	
	Команда = СтрШаблон("*%3%4$4%4HDEL%4$%2%4%1%4",
		Ключ, СтрДлинаВБайтах(Ключ), Формат(КоличествоПолей + 2, "ЧН=; ЧГ=0"), Маркер);
		
	Для Сч = 0 По КоличествоПолей - 1 Цикл
		Команда = Команда + СтрШаблон("$%2%3%1%3", Поля[Сч], СтрДлинаВБайтах(Поля[Сч]), Маркер);
	КонецЦикла;

	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "-WRONGTYPE") Тогда
		// Если значение для ключа не хэш-таблица это не нормальная ситуация. Будет вызвано исключение
		// только с более вменяемым текстом
		ВызватьИсключение СтрШаблон("Значение в БД Redis для ключа ""%1"" не являеся хэш-таблицей", Ключ);
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, ":") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат Число(СтрЗаменить(ПерваяСтрокаОтвета, ":", ""));
	КонецЕсли;
	
	ВызватьИсключение РезультатВызова;
		
КонецФункции

#КонецОбласти

#Область РаботаСJson

// Устанавливает JSON значение для ключа. Данные помещаются в корень JSON
//
// Параметры:
//  АдресСервераRedis   - Строка     - Адрес и порт для подключения
//  Ключ                - Строка     - Ключ по которому будет схранены данные на сервере
//  Данные              - Строка     - 
//                      - Число      - 
//                      - ЗаписьJSON - 
//
// Возвращаемое значение:
//  Булево - Истина если помещение данных произведено успешно, ложь - значение не было сохранено
Функция УстановитьJson(АдресСервераRedis, Ключ, Данные) Экспорт
	
	Возврат УстановитьJsonДляПути(АдресСервераRedis, Ключ, Данные);
	
КонецФункции

// Устанавливает JSON значение для ключа по конкретному пути JSON. Путь должен существовать
//
// Параметры:
//  АдресСервераRedis   - Строка     - Адрес и порт для подключения
//  Ключ                - Строка     - Ключ по которому будет схранены данные на сервере
//  Данные              - Строка     - 
//                      - Число      - 
//                      - ЗаписьJSON - 
//  Путь                - Строка     - 
//
// Возвращаемое значение:
//  Булево - Истина если помещение данных произведено успешно, ложь - значение не было сохранено
Функция УстановитьJsonДляПути(АдресСервераRedis, Ключ, Данные, Путь = "") Экспорт
	
	Если ТипЗнч(Данные) = Тип("ЗаписьJSON") Тогда
		СтрокаJson = Данные.Закрыть();
	Иначе // Строка, Число
		СтрокаJson = Строка(Данные);
	КонецЕсли;
	
	Если ПустаяСтрока(Путь) Тогда
		ВремПуть = ".";
	Иначе
		МассивЭлементовПути = СтрРазделить(Путь, ".");
		ВремПуть = "$.[""" + СтрСоединить(МассивЭлементовПути, """].[""") + """]";
	КонецЕсли;
	
	Маркер = Маркер();
	Команда = СтрШаблон("*4%7$8%7JSON.SET%7$%2%7%1%7$%4%7%3%7$%6%7%5%7",
		Ключ, СтрДлинаВБайтах(Ключ),
		ВремПуть, СтрДлинаВБайтах(ВремПуть),
		СтрокаJson, СтрДлинаВБайтах(СтрокаJson),
		Маркер);
		
	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "+") Тогда
		ПерваяСтрокаОтвета = СтрПолучитьСтроку(РезультатВызова, 1);
		Возврат ПерваяСтрокаОтвета = "+OK";
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, "$-1")
		Или СтрНачинаетсяС(РезультатВызова, "-ERR") Тогда
		
		ВызватьИсключение СтрШаблон("Для значения %1 не определен путь %2", Ключ, Путь);
		
	КонецЕсли;
	
	ВызватьИсключение "Неизвестная ошибка работы с Redis JSON";
	
КонецФункции

// Возвращает JSON значение для ключа. Данные запрашиваются из корня JSON
//
// Параметры:
//  АдресСервераRedis   - Строка - Адрес и порт для подключения
//  Ключ                - Строка - Ключ по которому будет прочитаны данные на сервере
//
// Возвращаемое значение:
//  ЧтениеJSON - 
Функция ПолучитьJson(АдресСервераRedis, Ключ) Экспорт
	
	Возврат ПолучитьJsonДляПути(АдресСервераRedis, Ключ);
	
КонецФункции

// Возвращает JSON значение для ключа по конкретному пути JSON. Путь должен существовать
//
// Параметры:
//  АдресСервераRedis   - Строка     - Адрес и порт для подключения
//  Ключ                - Строка     - Ключ по которому будет прочитаны данные на сервере
//  Путь                - Строка     - 
//
// Возвращаемое значение:
//  ЧтениеJSON - 
Функция ПолучитьJsonДляПути(АдресСервераRedis, Ключ, Путь = "") Экспорт

	Если ПустаяСтрока(Путь) Тогда
		ВремПуть = ".";
	Иначе
		МассивЭлементовПути = СтрРазделить(Путь, ".");
		ВремПуть = ".[""" + СтрСоединить(МассивЭлементовПути, """].[""") + """]";
	КонецЕсли;

	Маркер = Маркер();
	Команда = СтрШаблон("*3%5$8%5JSON.GET%5$%2%5%1%5$%4%5%3%5",
		Ключ, СтрДлинаВБайтах(Ключ),
		ВремПуть, СтрДлинаВБайтах(ВремПуть),
		Маркер);
		
	РезультатВызова = ВызовСервераRedis(АдресСервераRedis, Команда);
	Если СтрНачинаетсяС(РезультатВызова, "$-1")
		Или СтрНачинаетсяС(РезультатВызова, "-ERR") Тогда
		
		ВызватьИсключение СтрШаблон("Для значения %1 не определен путь %2", Ключ, Путь);
		
	ИначеЕсли СтрНачинаетсяС(РезультатВызова, "$") Тогда
		СтрокаJson = СтрПолучитьСтроку(РезультатВызова, 2);
		
		ЧтениеJSON = Новый ЧтениеJSON();
		ЧтениеJSON.УстановитьСтроку(СтрокаJson);
		
		Возврат ЧтениеJSON;
	КонецЕсли;

	ВызватьИсключение "Неизвестная ошибка работы с Redis JSON";
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ВызовСервераRedis(АдресСервераRedis, Команда)
	
	ОписаниеОшибки = "";
	Маркер = Маркер();
		
	Соединение = OPI_TCP.ОткрытьСоединение(АдресСервераRedis);
	Если ВыполнениеЗавершилосьОшибкой(Соединение, ОписаниеОшибки) Тогда
		Возврат ОписаниеОшибки;
	КонецЕсли;
	
	РезультатОтправки = OPI_TCP.ОтправитьСтроку(Соединение, Команда);
	РезультатОтправкиОшибка = OPI_TCP.ПолучитьПоследнююОшибку(Соединение);
	Если ВыполнениеЗавершилосьОшибкой(РезультатОтправкиОшибка, ОписаниеОшибки) Тогда
		OPI_TCP.ЗакрытьСоединение(Соединение);
		Возврат ОписаниеОшибки;
	КонецЕсли;
	
	РезультатЧтения = OPI_TCP.ПрочитатьСтроку(Соединение,, Маркер);
	РезультатЧтенияОшибка = OPI_TCP.ПолучитьПоследнююОшибку(Соединение);
	Если ВыполнениеЗавершилосьОшибкой(РезультатЧтенияОшибка, ОписаниеОшибки) Тогда
		OPI_TCP.ЗакрытьСоединение(Соединение);
		Возврат ОписаниеОшибки;
	КонецЕсли;
	
	OPI_TCP.ЗакрытьСоединение(Соединение);
	Возврат РезультатЧтения;
	
КонецФункции

Функция ВыполнениеЗавершилосьОшибкой(Объект, ОписаниеОшибки)
	
	Если ТипЗнч(Объект) = Тип("Соответствие")
		И Не Объект.Получить("error") = Неопределено Тогда

		ОписаниеОшибки = Объект.Получить("error");
		Возврат Истина;
		
	КонецЕсли;

	Возврат Ложь;

КонецФункции

Функция ВозможнаСериализация(Данные)
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда
		Возврат Истина;
	ИначеЕсли ТипЗнч(Данные) = Тип("Массив") Тогда
		Для каждого ЭлементМассива Из Данные Цикл
			Если Не ТипЗнч(ЭлементМассива) = Тип("Строка") Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
		Или ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Для каждого КлючЗначение Из Данные Цикл
			Если Не ТипЗнч(КлючЗначение.Ключ) = Тип("Строка")
				Или Не ТипЗнч(КлючЗначение.Значение) = Тип("Строка") Тогда

				Возврат Ложь;
				
			КонецЕсли;
		КонецЦикла;

		Возврат Истина;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция СтрДлинаВБайтах(Стр)
    ДвоичныеДанные = ПолучитьДвоичныеДанныеИзСтроки(Стр, КодировкаТекста.UTF8);
	Возврат Формат(ДвоичныеДанные.Размер(), "ЧН=; ЧГ=0");
КонецФункции

// Не стал использовать никаких регулярных выражений для совместимости
Функция ВозможноСохранениеВСтруктуру(Данные)
	
	ПервыеСимволы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя_";
	ОстальныеСимволы = ПервыеСимволы + "0123456789";
	
	Для каждого КлючЗначение Из Данные Цикл
		Если СтрНайти(ПервыеСимволы, НРег(Лев(КлючЗначение.Ключ, 1))) = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
		Для Сч = 2 По СтрДлина(КлючЗначение.Ключ) Цикл
			Если СтрНайти(ОстальныеСимволы, НРег(Сред(КлючЗначение.Ключ, Сч, 1))) = 0 Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция Маркер()
	
	Возврат Символы.ВК + Символы.ПС;
	
КонецФункции

#КонецОбласти
