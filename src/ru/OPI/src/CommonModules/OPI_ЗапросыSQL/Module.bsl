// OneScript: ./OInt/tools/Modules/OPI_ЗапросыSQL.os

// MIT License

// Copyright (c) 2023-2025 Anton Tsitavets

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// https://github.com/Bayselonarrend/OpenIntegrations

// BSLLS:Typo-off
// BSLLS:LatinAndCyrillicSymbolInWord-off
// BSLLS:IncorrectLineBreak-off
// BSLLS:NumberOfOptionalParams-off
// BSLLS:UsingServiceTag-off
// BSLLS:LineLength-off
// BSLLS:QueryParseError-off
// BSLLS:AssignAliasFieldsInQuery-off
// BSLLS:NumberOfParams-off
// BSLLS:UsingSynchronousCalls-off
// BSLLS:MagicNumber-off

//@skip-check module-structure-top-region
//@skip-check module-structure-method-in-regions
//@skip-check wrong-string-literal-content
//@skip-check method-too-many-params
//@skip-check constructor-function-return-section

// Раскомментировать, если выполняется OneScript
// #Использовать "./internal"

#Область СлужебныйПрограммныйИнтерфейс

Функция СоздатьБазуДанных(Знач Модуль, Знач База, Знач Соединение = "", Знач Tls = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("CREATEDATABASE", Модуль);

    УстановитьИмяБазы(Схема, База);

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, , , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция УдалитьБазуДанных(Знач Модуль, Знач База, Знач Соединение = "", Знач Tls = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("DROPDATABASE", Модуль);

    УстановитьИмяБазы(Схема, База);

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, , , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция СоздатьТаблицу(Знач Модуль
    , Знач Таблица
    , Знач СтруктураКолонок
    , Знач Соединение = ""
    , Знач Tls        = Неопределено) Экспорт

    ТекстОшибки = "Структура колонок не является валидной структурой ключ-значение";
    OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(СтруктураКолонок, ТекстОшибки);

    Схема = ПустаяСхемаSQL("CREATE", Модуль);

    УстановитьИмяТаблицы(Схема, Таблица);

    Для Каждого Колонка Из СтруктураКолонок Цикл
        ДобавитьКолонку(Схема, Колонка.Ключ, Колонка.Значение);
    КонецЦикла;

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, , , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция ДобавитьКолонкуТаблицы(Знач Модуль
    , Знач Таблица
    , Знач Имя
    , Знач ТипДанных
    , Знач Соединение = ""
    , Знач Tls        = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("ALTERTABLEADD", Модуль);

    УстановитьИмяТаблицы(Схема, Таблица);

    УстановитьПроизвольноеПоле(Схема, "name" , Имя      , "Строка");
    УстановитьПроизвольноеПоле(Схема, "dtype", ТипДанных, "Строка");

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, , , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция УдалитьКолонкуТаблицы(Знач Модуль
    , Знач Таблица
    , Знач Имя
    , Знач Соединение = ""
    , Знач Tls        = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("ALTERTABLEDROP", Модуль);

    УстановитьИмяТаблицы(Схема, Таблица);
    УстановитьПроизвольноеПоле(Схема, "name", Имя, "Строка");

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, , , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция ГарантироватьТаблицу(Знач Модуль
    , Знач Таблица
    , Знач СтруктураКолонок
    , Знач Соединение = ""
    , Знач Tls        = Неопределено) Экспорт

    ТекстОшибки = "Структура колонок не является валидной структурой ключ-значение";
    OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(СтруктураКолонок, ТекстОшибки);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Таблица);

    Result_ = "result";

    СтруктураРезультата = Новый Структура(Result_, Истина);

    Соединение     = ОткрытьСоединение(Модуль, Соединение, Tls);
    ПроблемныйЭтап = ОбработатьНачалоЗаписи(Модуль, Истина, Соединение);

    Если ЗначениеЗаполнено(ПроблемныйЭтап) Тогда
        Возврат ПроблемныйЭтап;
    КонецЕсли;

    Попытка

        ОписаниеТаблицы = ПолучитьСтруктуруТаблицы(Модуль, Таблица, Соединение, Tls);

        Если Не ОписаниеТаблицы[Result_] Тогда
            Возврат ОписаниеТаблицы;
        КонецЕсли;

        КолонкиТаблицы = ОписаниеТаблицы["data"];

        Если Не ЗначениеЗаполнено(КолонкиТаблицы) Тогда
            СтруктураРезультата = СоздатьТаблицу(Модуль, Таблица, СтруктураКолонок, Соединение, Tls);
        Иначе

            Ошибка = НормализоватьТаблицу(Модуль, Таблица, СтруктураКолонок, КолонкиТаблицы, Соединение, Tls);

            Если Ошибка <> Неопределено Тогда
                Возврат Ошибка;
            КонецЕсли;

        КонецЕсли;

        Завершение = Модуль.ВыполнитьЗапросSQL("COMMIT;", , , Соединение);
        СтруктураРезультата.Вставить("commit", Завершение);

    Исключение

        Откат = Модуль.ВыполнитьЗапросSQL("ROLLBACK;", , , Соединение);

        СтруктураРезультата.Вставить(Result_   , Ложь);
        СтруктураРезультата.Вставить("error"   , ОписаниеОшибки());
        СтруктураРезультата.Вставить("rollback", Откат);

    КонецПопытки;

    Возврат СтруктураРезультата;

КонецФункции

Функция ДобавитьЗаписи(Знач Модуль
    , Знач Таблица
    , Знач МассивДанных
    , Знач Транзакция = Истина
    , Знач Соединение = ""
    , Знач Tls        = Неопределено) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьМассив(МассивДанных);
    OPI_ПреобразованиеТипов.ПолучитьБулево(Транзакция);

    Соединение     = ОткрытьСоединение(Модуль, Соединение, Tls);
    ПроблемныйЭтап = ОбработатьНачалоЗаписи(Модуль, Транзакция, Соединение);

    Если ЗначениеЗаполнено(ПроблемныйЭтап) Тогда
        Возврат ПроблемныйЭтап;
    КонецЕсли;

    СтруктураОбработки  = ОбработатьЗаписи(Модуль, Таблица, МассивДанных, Транзакция, Соединение);
    СтруктураРезультата = ОбработатьКонецЗаписи(СтруктураОбработки, Модуль, Транзакция, Соединение);

    Возврат СтруктураРезультата;

КонецФункции

Функция ПолучитьЗаписи(Знач Модуль
    , Знач Таблица
    , Знач Поля       = "*"
    , Знач Фильтры    = ""
    , Знач Сортировка = ""
    , Знач Количество = ""
    , Знач Соединение = ""
    , Знач Tls        = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("SELECT", Модуль);

    УстановитьИмяТаблицы(Схема, Таблица);
    УстановитьЛимит(Схема, Количество);

    ЗаполнитьПоля(Схема, Поля);
    ЗаполнитьФильтры(Схема, Фильтры);
    ЗаполнитьСортировку(Схема, Сортировка);

    Запрос = СформироватьТекстSQL(Схема);

    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, Схема["values"], , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция ОбновитьЗаписи(Знач Модуль
    , Знач Таблица
    , Знач СтруктураЗначений
    , Знач Фильтры    = ""
    , Знач Соединение = ""
    , Знач Tls        = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("UPDATE", Модуль);

    МассивПолей    = Новый Массив;
    МассивЗначений = Новый Массив;

    УстановитьИмяТаблицы(Схема, Таблица);
    РазделитьКоллекциюДанных(СтруктураЗначений, МассивПолей, МассивЗначений);

    Схема["values"] = МассивЗначений;

    Для Каждого Поле Из МассивПолей Цикл
        ДобавитьПоле(Схема, Поле);
    КонецЦикла;

    ЗаполнитьФильтры(Схема, Фильтры);

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, Схема["values"], , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция УдалитьЗаписи(Знач Модуль
    , Знач Таблица
    , Знач Фильтры    = ""
    , Знач Соединение = ""
    , Знач Tls        = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("DELETE", Модуль);

    УстановитьИмяТаблицы(Схема, Таблица);

    ЗаполнитьФильтры(Схема, Фильтры);

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, Схема["values"], , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция УдалитьТаблицу(Знач Модуль, Знач Таблица, Знач Соединение = "", Знач Tls = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("DROP", Модуль);

    УстановитьИмяТаблицы(Схема, Таблица);

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, , , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция ОчиститьТаблицу(Знач Модуль, Знач Таблица, Знач Соединение = "", Знач Tls = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("TRUNCATE", Модуль);

    УстановитьИмяТаблицы(Схема, Таблица);

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, , , Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция ПолучитьСтруктуруТаблицы(Знач Модуль, Знач Таблица, Знач Соединение = "", Знач Tls = Неопределено) Экспорт

    Схема = ПустаяСхемаSQL("TABLESCHEMA", Модуль);

    УстановитьИмяТаблицы(Схема, Таблица);

    Запрос    = СформироватьТекстSQL(Схема);
    Результат = ВыполнитьЗапросSQL(Модуль, Запрос, , Истина, Соединение, Tls);

    Возврат Результат;

КонецФункции

Функция ПолучитьСтруктуруФильтраЗаписей(Знач Пустая = Ложь) Экспорт

    СтруктураФильтра = Новый Структура;

    СтруктураФильтра.Вставить("field", "<имя поля для отбора>");
    СтруктураФильтра.Вставить("type" , "<тип сравнения>");
    СтруктураФильтра.Вставить("value", "<значение для сравнения>");
    СтруктураФильтра.Вставить("union", "<связь со следующим условием: AND, OR и пр.>");
    СтруктураФильтра.Вставить("raw"  , "<истина - значение будет вставлено текстом, как есть, ложь - через параметр>");

    Если Пустая Тогда
        СтруктураФильтра = OPI_Инструменты.ОчиститьКоллекциюРекурсивно(СтруктураФильтра);
    КонецЕсли;

    //@skip-check constructor-function-return-section
    Возврат СтруктураФильтра;

КонецФункции

Функция ВыполнитьЗапросСОбработкой(Коннектор, Знач ТекстЗапроса, Знач ФорсироватьРезультат, Знач Параметры) Экспорт

    КлючЗапроса = ИнициализироватьЗапрос(Коннектор, ТекстЗапроса, ФорсироватьРезультат);

    Если Не КлючЗапроса["result"] Тогда
        Возврат КлючЗапроса;
    Иначе
        КлючЗапроса = КлючЗапроса["key"];
    КонецЕсли;

    Добавление = УстановитьПараметрыЗапроса(Коннектор, КлючЗапроса, Параметры);

    Если Не Добавление["result"] Тогда
        Возврат Добавление;
    КонецЕсли;

    Результат = Коннектор.Execute(КлючЗапроса);
    Результат = ОбработатьРезультатЗапроса(Коннектор, КлючЗапроса, Результат);

    Возврат Результат;

КонецФункции

Функция ОбработатьПараметры(Знач Компонента, Знач Параметры, Знач СтруктураТипов) Экспорт

    Если Не ЗначениеЗаполнено(Параметры) Тогда
        Возврат Новый Массив;
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьМассив(Параметры);

    Для Н = 0 По Параметры.ВГраница() Цикл

        ТекущийПараметр = Параметры[Н];

        ТекущийПараметр = ОбработатьПараметр(Компонента, ТекущийПараметр, СтруктураТипов);

        Параметры[Н] = ТекущийПараметр;

    КонецЦикла;

    Возврат Параметры;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область Схемы

Функция ПустаяСхемаSQL(Знач Действие, Знач Модуль = Неопределено)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Действие);

    Действие = вРег(Действие);

    Если Действие = "SELECT" Тогда

        Схема = ПустаяСхемаSelect();

    ИначеЕсли Действие = "INSERT" Тогда

        Схема = ПустаяСхемаInsert();

    ИначеЕсли Действие = "UPDATE" Тогда

        Схема = ПустаяСхемаUpdate();

    ИначеЕсли Действие = "DELETE" Тогда

        Схема = ПустаяСхемаDelete();

    ИначеЕсли Действие = "CREATE" Тогда

        Схема = ПустаяСхемаCreate();

    ИначеЕсли Действие = "DROP" Тогда

        Схема = ПустаяСхемаDrop();

    ИначеЕсли Действие = "TRUNCATE" Тогда

        Схема = ПустаяСхемаTruncate();

    ИначеЕсли Действие = "CREATEDATABASE" Тогда

        Схема = ПустаяСхемаCreateDatabase();

    ИначеЕсли Действие = "DROPDATABASE" Тогда

        Схема = ПустаяСхемаDropDatabase();

    ИначеЕсли Действие = "TABLESCHEMA" Тогда

        Схема = ПустаяСхемаTableSchema();

    ИначеЕсли Действие = "ALTERTABLEADD" Тогда

        Схема = ПустаяСхемаAlterTableAdd();

    ИначеЕсли Действие = "ALTERTABLEDROP" Тогда

        Схема = ПустаяСхемаAlterTableDrop();

    Иначе

        Схема = Новый Структура;

    КонецЕсли;

    Особенности = Модуль.ПолучитьОсобенности();

    ЗаменитьСтандартныеОсобенности(Особенности);

    Схема.Вставить("nump" , Особенности["НумерацияПараметров"]);
    Схема.Вставить("markp", Особенности["МаркерПараметров"]);
    Схема.Вставить("dbms" , Особенности["СУБД"]);

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаSelect()

    Схема = Новый Структура("type", "SELECT");

    Схема.Вставить("table"   , "");
    Схема.Вставить("filter"  , Новый Массив);
    Схема.Вставить("order"   , Новый Массив);
    Схема.Вставить("limit"   , 0);
    Схема.Вставить("set"     , Новый Массив);
    Схема.Вставить("values"  , Новый Массив);

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаInsert()

    Схема = Новый Структура("type", "INSERT");

    Схема.Вставить("table", "");
    Схема.Вставить("set"  , Новый Массив);

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаUpdate()

    Схема = Новый Структура("type", "UPDATE");

    Схема.Вставить("table"   , "");
    Схема.Вставить("set"     , Новый Массив);
    Схема.Вставить("filter"  , Новый Массив);
    Схема.Вставить("values"  , Новый Массив);

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаDelete()

    Схема = Новый Структура("type", "DELETE");

    Схема.Вставить("table" , "");
    Схема.Вставить("filter", Новый Массив);
    Схема.Вставить("values", Новый Массив);

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаCreate()

    Схема = Новый Структура("type", "CREATE");

    Схема.Вставить("table"  , "");
    Схема.Вставить("columns", Новый Массив);

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаDrop()

    Схема = Новый Структура("type", "DROP");

    Схема.Вставить("table"  , "");

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаTruncate()

    Схема = Новый Структура("type", "TRUNCATE");

    Схема.Вставить("table"  , "");

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаCreateDatabase()

    Схема = Новый Структура("type", "CREATEDATABASE");

    Схема.Вставить("database"  , "");

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаDropDatabase()

    Схема = Новый Структура("type", "DROPDATABASE");

    Схема.Вставить("database"  , "");

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаTableSchema()

    Схема = Новый Структура("type", "TABLESCHEMA");

    Схема.Вставить("table" , "");
    Схема.Вставить("common", Истина);

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаAlterTableAdd()

    Схема = Новый Структура("type", "ALTERTABLEADD");

    Схема.Вставить("table", "");
    Схема.Вставить("name" , "");
    Схема.Вставить("dtype", "");

    Возврат Схема;

КонецФункции

Функция ПустаяСхемаAlterTableDrop()

    Схема = Новый Структура("type", "ALTERTABLEDROP");

    Схема.Вставить("table", "");
    Схема.Вставить("name" , "");

    Возврат Схема;

КонецФункции

#КонецОбласти

#Область Процессоры

Функция СформироватьТекстSQL(Знач Схема)

    ТекстОшибки = "Переданное значение не является валидной схемой SQL запроса";
    OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Схема, ТекстОшибки);

    ТипСхемы = "";

    Если Не OPI_Инструменты.ПолеКоллекцииСуществует(Схема, "type", ТипСхемы) Тогда
        ВызватьИсключение ТекстОшибки;
    КонецЕсли;

    ТипСхемы = вРег(ТипСхемы);

    Если ТипСхемы = "SELECT" Тогда

        ТекстЗапроса = СформироватьТекстSelect(Схема);

    ИначеЕсли ТипСхемы = "INSERT" Тогда

        ТекстЗапроса = СформироватьТекстInsert(Схема);

    ИначеЕсли ТипСхемы = "UPDATE" Тогда

        ТекстЗапроса = СформироватьТекстUpdate(Схема);

    ИначеЕсли ТипСхемы = "DELETE" Тогда

        ТекстЗапроса = СформироватьТекстDelete(Схема);

    ИначеЕсли ТипСхемы = "CREATE" Тогда

        ТекстЗапроса = СформироватьТекстCreate(Схема);

    ИначеЕсли ТипСхемы = "DROP" Тогда

        ТекстЗапроса = СформироватьТекстDrop(Схема);

    ИначеЕсли ТипСхемы = "TRUNCATE" Тогда

        ТекстЗапроса = СформироватьТекстTruncate(Схема);

    ИначеЕсли ТипСхемы = "CREATEDATABASE" Тогда

        ТекстЗапроса = СформироватьТекстCreateDatabase(Схема);

    ИначеЕсли ТипСхемы = "DROPDATABASE" Тогда

        ТекстЗапроса = СформироватьТекстDropDatabase(Схема);

    ИначеЕсли ТипСхемы = "TABLESCHEMA" Тогда

        ТекстЗапроса = СформироватьТекстTableSchema(Схема);

    ИначеЕсли ТипСхемы = "ALTERTABLEADD" Тогда

        ТекстЗапроса = СформироватьТекстAlterTableAdd(Схема);

    ИначеЕсли ТипСхемы = "ALTERTABLEDROP" Тогда

        ТекстЗапроса = СформироватьТекстAlterTableDrop(Схема);

    Иначе

        ТекстЗапроса = "";

    КонецЕсли;

    Возврат ТекстЗапроса;

КонецФункции

Функция СформироватьТекстSelect(Знач Схема)

    ПроверитьОбязательныеПоляСхемы(Схема, "table,filter,order,limit,set");

    Таблица    = Схема["table"];
    Поля       = Схема["set"];
    Фильтры    = Схема["filter"];
    Сортировка = Схема["order"];
    Количество = Схема["limit"];
    СУБД       = Схема["dbms"];

    ШаблонSQL = "SELECT %1 %2 FROM %3
    |%4
    |%5
    |%6;";

    ТекстФильтра    = СформироватьТекстФильтра(Фильтры);
    ТекстСортировки = СформироватьТекстСортировки(Сортировка);

    Если СУБД = "mssql" Тогда
        ТекстТопа   = СформироватьТекстТопа(Количество);
        ТекстЛимита = "";
    Иначе
        ТекстТопа   = "";
        ТекстЛимита = СформироватьТекстКоличества(Количество);
    КонецЕсли;

    ТекстSQL = СтрШаблон(ШаблонSQL
        , ТекстТопа
        , СтрСоединить(Поля, ", ")
        , Таблица
        , ТекстФильтра
        , ТекстСортировки
        , ТекстЛимита);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстInsert(Знач Схема)

    ПроверитьОбязательныеПоляСхемы(Схема, "table,set");

    Таблица   = Схема["table"];
    Поля      = Схема["set"];
    Нумерация = Схема["nump"];
    Маркер    = Схема["markp"];

    ШаблонSQL = "INSERT INTO %1 (%2) VALUES (%3);";

    Параметры = Новый Массив;

    Для Н = 1 По Поля.Количество() Цикл

        ТекущийМаркер = Маркер;

        Если Нумерация Тогда
            ТекущийМаркер = ТекущийМаркер + OPI_Инструменты.ЧислоВСтроку(Н);
        КонецЕсли;

        Параметры.Добавить(ТекущийМаркер);

    КонецЦикла;

    ТекстSQL = СтрШаблон(ШаблонSQL
        , Таблица
        , СтрСоединить(Поля, ", ")
        , СтрСоединить(Параметры, ", "));

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстUpdate(Знач Схема)

    ПроверитьОбязательныеПоляСхемы(Схема, "table,set,values");

    Таблица   = Схема["table"];
    Поля      = Схема["set"];
    Фильтры   = Схема["filter"];
    Нумерация = Схема["nump"];
    Маркер    = Схема["markp"];

    ШаблонSQL = "UPDATE %1 SET %2 %3;";

    ТекстФильтра = СформироватьТекстФильтра(Фильтры);

    Для Н = 0 По Поля.ВГраница() Цикл

        ТекущийМаркер = Маркер;

        Если Нумерация Тогда
            ТекущийМаркер = ТекущийМаркер + OPI_Инструменты.ЧислоВСтроку(Н + 1);
        КонецЕсли;

        Поля[Н] = Поля[Н] + " = " + ТекущийМаркер;

    КонецЦикла;

    ТекстSQL = СтрШаблон(ШаблонSQL, Таблица, СтрСоединить(Поля, "," + Символы.ПС), ТекстФильтра);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстDelete(Знач Схема)

    ПроверитьОбязательныеПоляСхемы(Схема, "table");

    Таблица = Схема["table"];
    Фильтры = Схема["filter"];

    ШаблонSQL = "DELETE FROM %1 %2;";

    ТекстФильтра = СформироватьТекстФильтра(Фильтры);

    ТекстSQL = СтрШаблон(ШаблонSQL, Таблица, ТекстФильтра);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстCreate(Знач Схема)

    ПроверитьОбязательныеПоляСхемы(Схема, "table,columns");

    Таблица = Схема["table"];
    Колонки = Схема["columns"];

    ШаблонSQL = "CREATE TABLE %1 (
    | %2
    | );";

    ШаблонКолонки = "%1 %2";

    МассивОписанийКолонок = Новый Массив;

    Для Каждого Колонка Из Колонки Цикл
        Для Каждого Элемент Из Колонка Цикл
            МассивОписанийКолонок.Добавить(СтрШаблон(ШаблонКолонки, Элемент.Ключ, Элемент.Значение));
        КонецЦикла;
    КонецЦикла;

    ОписанияКолонок = СтрСоединить(МассивОписанийКолонок, "," + Символы.ПС);

    ТекстSQL = СтрШаблон(ШаблонSQL, Таблица, ОписанияКолонок);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстDrop(Знач Схема)

    ПроверитьОбязательныеПоляСхемы(Схема, "table");

    Таблица = Схема["table"];

    ШаблонSQL = "DROP TABLE %1;";

    ТекстSQL = СтрШаблон(ШаблонSQL, Таблица);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстTruncate(Знач Схема)

    ПроверитьОбязательныеПоляСхемы(Схема, "table");

    Таблица = Схема["table"];

    ШаблонSQL = "TRUNCATE TABLE %1;";

    ТекстSQL = СтрШаблон(ШаблонSQL, Таблица);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстCreateDatabase(Знач Схема)

    ПроверитьОбязательныеПоляСхемы(Схема, "database");

    База = Схема["database"];

    ШаблонSQL = "CREATE DATABASE %1;";

    ТекстSQL = СтрШаблон(ШаблонSQL, База);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстDropDatabase(Знач Схема)

    ПроверитьОбязательныеПоляСхемы(Схема, "database");

    База = Схема["database"];

    ШаблонSQL = "DROP DATABASE %1;";

    ТекстSQL = СтрШаблон(ШаблонSQL, База);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстTableSchema(Знач Схема)

    СУБД    = Схема["dbms"];
    Таблица = Схема["table"];

    Если СУБД = "sqlite" Тогда

        ШаблонSQL = "PRAGMA table_info('%1');";

    Иначе

        ШаблонSQL         = "SELECT column_name, data_type, is_nullable, column_default, character_maximum_length
        |FROM information_schema.columns
        |WHERE table_name = '%1';";

    КонецЕсли;

    ТекстSQL = СтрШаблон(ШаблонSQL, Таблица);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстAlterTableAdd(Знач Схема)

    Таблица   = Схема["table"];
    Имя       = Схема["name"];
    ТипДанных = Схема["dtype"];

    ШаблонSQL = "ALTER TABLE %1 ADD %2 %3";

    ТекстSQL = СтрШаблон(ШаблонSQL, Таблица, Имя, ТипДанных);

    Возврат ТекстSQL;

КонецФункции

Функция СформироватьТекстAlterTableDrop(Знач Схема)

    Таблица = Схема["table"];
    Имя     = Схема["name"];
    СУБД    = Схема["dbms"];

    ШаблонSQL = "ALTER TABLE %1 DROP %2 %3";
    Уточнение = ?(СУБД = "mssql", "COLUMN", "");

    ТекстSQL = СтрШаблон(ШаблонSQL, Таблица, Уточнение, Имя);

    Возврат ТекстSQL;

КонецФункции

#КонецОбласти

#Область Вспомогательные

Функция ОткрытьСоединение(Знач Модуль, Знач Соединение, Знач Tls)

    Если Tls = Неопределено Тогда
        Результат = Модуль.ОткрытьСоединение(Соединение);
    Иначе
        Результат = Модуль.ОткрытьСоединение(Соединение, Tls);
    КонецЕсли;

    Возврат Результат;

КонецФункции

Функция ВыполнитьЗапросSQL(Знач Модуль
    , Знач ТекстЗапроса
    , Знач Параметры            = ""
    , Знач ФорсироватьРезультат = Ложь
    , Знач Соединение           = ""
    , Знач Tls                  = Неопределено)

    Если ЗначениеЗаполнено(Tls) Тогда
        Результат = Модуль.ВыполнитьЗапросSQL(ТекстЗапроса, Параметры, ФорсироватьРезультат, Соединение, Tls);
    Иначе
        Результат = Модуль.ВыполнитьЗапросSQL(ТекстЗапроса, Параметры, ФорсироватьРезультат, Соединение);
    КонецЕсли;

    Возврат Результат;

КонецФункции

Функция ОбработатьЗаписи(Знач Модуль, Знач Таблица, Знач МассивДанных, Знач Транзакция, Знач Соединение)

    Если OPI_Компоненты.ТребуетсяПередачаЧерезФайл() Тогда
        Результат = ДобавитьЗаписиПакетом(Модуль, Таблица, МассивДанных, Транзакция, Соединение);
    Иначе
        Результат = ДобавитьЗаписиРаздельно(Модуль, Таблица, МассивДанных, Транзакция, Соединение);
    КонецЕсли;

    Возврат Результат;

КонецФункции

Функция ДобавитьЗаписиРаздельно(Знач Модуль, Знач Таблица, Знач МассивДанных, Знач Транзакция, Знач Соединение)

    МассивОшибок    = Новый Массив;
    Счетчик         = 0;
    СчетчикУспешных = 0;

    Для Каждого Запись Из МассивДанных Цикл

        Счетчик = Счетчик + 1;

        Если Не ПроверитьКорректностьЗаписи(Запись, МассивОшибок, Счетчик) Тогда
            Если Транзакция Тогда
                Прервать;
            Иначе
                Продолжить;
            КонецЕсли;
        КонецЕсли;

        Результат = ДобавитьЗапись(Модуль, Таблица, Запись, Соединение);

        Успех = ПроверитьВыполнениеОчередногоЗапроса(Результат, Транзакция, Счетчик, СчетчикУспешных, МассивОшибок);

        Если Не Успех Тогда
            Прервать;
        КонецЕсли;

    КонецЦикла;

    Результат = Новый Структура("МассивОшибок,СчетчикУспешных", МассивОшибок, СчетчикУспешных);

    Возврат Результат;

КонецФункции

Функция ДобавитьЗаписиПакетом(Знач Модуль, Знач Таблица, Знач МассивДанных, Знач Транзакция, Знач Соединение)

    МассивЗаготовок = Новый Массив;
    МассивОшибок    = Новый Массив;

    // BSLLS:MissingTemporaryFileDeletion-off

    //@skip-check missing-temporary-file-deletion
    ПутьЗаготовок   = ПолучитьИмяВременногоФайла();
    //@skip-check missing-temporary-file-deletion
    ПутьКлючей      = ПолучитьИмяВременногоФайла();

    // BSLLS:MissingTemporaryFileDeletion-on

    Счетчик         = 0;
    СчетчикУспешных = 0;

    Для Каждого Запись Из МассивДанных Цикл

        Счетчик = Счетчик + 1;

        Если Не ПроверитьКорректностьЗаписи(Запись, МассивОшибок, Счетчик) Тогда
            Если Транзакция Тогда
                Прервать;
            Иначе
                Продолжить;
            КонецЕсли;
        КонецЕсли;

        Результат = ДобавитьЗапись(Модуль, Таблица, Запись, Соединение, Ложь);
        МассивЗаготовок.Добавить(Результат);

    КонецЦикла;

    Попытка

        OPI_Инструменты.ЗаписатьJSONФайл(ПутьЗаготовок, МассивЗаготовок);

        Инициализация = Соединение.BatchQuery(ПутьЗаготовок, ПутьКлючей);
        Инициализация = OPI_Инструменты.JsonВСтруктуру(Инициализация);

        OPI_Инструменты.УдалитьФайлВПопытке(ПутьЗаготовок, "Не удалось удалить файл пакета запросов после установки");

        Если Не Инициализация["result"] Тогда
            ВызватьИсключение Инициализация["error"];
        КонецЕсли;

        Ключи = OPI_Инструменты.ПрочитатьJSONФайл(ПутьКлючей, Истина);

        OPI_Инструменты.УдалитьФайлВПопытке(ПутьКлючей, "Не удалось удалить файл ключей после инициализации");

    Исключение

        Ошибка = СтрШаблон("Batch query error: %1", ОписаниеОшибки());
        МассивОшибок.Добавить(Новый Структура("row,error", -1, Ошибка));

        Возврат Новый Структура("МассивОшибок,СчетчикУспешных",  МассивОшибок, 0);

    КонецПопытки;

    Для Каждого КлючЗапроса Из Ключи Цикл

        Результат = Соединение.Execute(КлючЗапроса);
        Результат = ОбработатьРезультатЗапроса(Соединение, КлючЗапроса, Результат);

        Успех = ПроверитьВыполнениеОчередногоЗапроса(Результат, Транзакция, Счетчик, СчетчикУспешных, МассивОшибок);

        Если Не Успех Тогда
            Прервать;
        КонецЕсли;

    КонецЦикла;

    Результат = Новый Структура("МассивОшибок,СчетчикУспешных", МассивОшибок, СчетчикУспешных);

    Возврат Результат;

КонецФункции

Функция ПроверитьВыполнениеОчередногоЗапроса(Знач Результат
    , Знач Транзакция
    , Знач Счетчик
    , СчетчикУспешных
    , МассивОшибок)

    Если Результат["result"] Тогда
            СчетчикУспешных = СчетчикУспешных + 1;
        Иначе

            МассивОшибок.Добавить(Новый Структура("row,error", Счетчик, Результат["error"]));

            Если Транзакция Тогда
                Возврат Ложь;
            КонецЕсли;

    КонецЕсли;

    Возврат Истина;

КонецФункции

Функция ПроверитьКорректностьЗаписи(Запись, МассивОшибок, Знач Счетчик)

    ОшибкаКоллекции = "Invalid data";
    Корректна       = Истина;

    Попытка
        OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Запись, ОшибкаКоллекции);
    Исключение
        МассивОшибок.Добавить(Новый Структура("row,error", Счетчик, ОшибкаКоллекции));
        Корректна = Ложь;
    КонецПопытки;

    Возврат Корректна;

КонецФункции

Функция ДобавитьЗапись(Знач Модуль, Знач Таблица, Знач Запись, Знач Соединение, Знач ВыполнятьСразу = Истина)

    МассивПолей    = Новый Массив;
    МассивЗначений = Новый Массив;

    Схема = ПустаяСхемаSQL("INSERT", Модуль);
    УстановитьИмяТаблицы(Схема, Таблица);

    РазделитьКоллекциюДанных(Запись, МассивПолей, МассивЗначений);

    Для Каждого Поле Из МассивПолей Цикл
        ДобавитьПоле(Схема, Поле);
    КонецЦикла;

    Запрос = СформироватьТекстSQL(Схема);

    Если ВыполнятьСразу Тогда
        Результат = Модуль.ВыполнитьЗапросSQL(Запрос, МассивЗначений, , Соединение);
    Иначе

        Параметры = ОбработатьПараметры(Соединение
            , МассивЗначений
            , Модуль.ПолучитьСтруктуруТипов());

        Результат = Новый Соответствие;
        Результат.Вставить("text"        , Запрос);
        Результат.Вставить("params"      , Параметры);
        Результат.Вставить("force_result", Ложь);

    КонецЕсли;

    Возврат Результат;

КонецФункции

Функция ОбработатьНачалоЗаписи(Знач Модуль, Знач Транзакция, Знач Соединение)

    Если Не OPI_Компоненты.ЭтоКомпонента(Соединение) Тогда
        Возврат Соединение;
    КонецЕсли;

    Если Транзакция Тогда

        Текст  = Модуль.ПолучитьОсобенности()["НачалоТранзакции"];
        Начало = Модуль.ВыполнитьЗапросSQL(Текст, , , Соединение);

        Если Не Начало["result"] Тогда
            Возврат Начало;
        КонецЕсли;

    КонецЕсли;

КонецФункции

Функция ОбработатьКонецЗаписи(Знач СтруктураОбработки, Знач Модуль, Знач Транзакция, Знач Соединение)

    СтруктураРезультата = Новый Структура;

    МассивОшибок    = СтруктураОбработки["МассивОшибок"];
    СчетчикУспешных = СтруктураОбработки["СчетчикУспешных"];

    Если Транзакция Тогда

        Если МассивОшибок.Количество() > 0 Тогда

            Откат = Модуль.ВыполнитьЗапросSQL("ROLLBACK;", , , Соединение);

            СчетчикУспешных = 0;
            СтруктураРезультата.Вставить("rollback", Откат);

        Иначе

            Завершение = Модуль.ВыполнитьЗапросSQL("COMMIT;", , , Соединение);
            СтруктураРезультата.Вставить("commit", Завершение);

        КонецЕсли;

    КонецЕсли;

    СтруктураРезультата.Вставить("result", МассивОшибок.Количество() = 0);
    СтруктураРезультата.Вставить("rows"  , СчетчикУспешных);
    СтруктураРезультата.Вставить("errors", МассивОшибок);

    Возврат СтруктураРезультата;

КонецФункции

Функция НормализоватьТаблицу(Знач Модуль
    , Знач Таблица
    , Знач СтруктураКолонок
    , Знач КолонкиТаблицы
    , Знач Соединение
    , Знач Tls)

    СоответствиеНахождения = Новый Соответствие;
    ИмяПоля                = Модуль.ПолучитьОсобенности()["ПолеКолонки"];

    КодУдаления      = 0;
    КодДобавления    = 1;
    КодИгнорирования = 2;

    Для Каждого Колонка Из КолонкиТаблицы Цикл

        ИмяКолонки = Колонка[ИмяПоля];

        Если Не ЗначениеЗаполнено(ИмяКолонки) Тогда
            Продолжить;
        Иначе
            СоответствиеНахождения.Вставить(ИмяКолонки, КодУдаления);
        КонецЕсли;

    КонецЦикла;

    Если СоответствиеНахождения.Количество() = 0 Тогда
        СоответствиеОтвета = Новый Соответствие;
        СоответствиеОтвета.Вставить("result", "false");
        СоответствиеОтвета.Вставить("error" , "Unsupported table schema type");
        Возврат СоответствиеОтвета;
    КонецЕсли;

    Для Каждого НеобходимаяКолонка Из СтруктураКолонок Цикл

        ИмяКолонки = НеобходимаяКолонка.Ключ;
        Существует = СоответствиеНахождения.Получить(ИмяКолонки) <> Неопределено;
        Действие   = ?(Существует, КодИгнорирования, КодДобавления);

        СоответствиеНахождения.Вставить(ИмяКолонки, Действие);

    КонецЦикла;

    Для Каждого ЧастьСхемы Из СоответствиеНахождения Цикл

        КодДействия = ЧастьСхемы.Значение;
        ИмяКолонки  = ЧастьСхемы.Ключ;

        Если КодДействия = 0 Тогда

            Результат = УдалитьКолонкуТаблицы(Модуль, Таблица, ИмяКолонки, Соединение, Tls);

        ИначеЕсли КодДействия = 1 Тогда

            ТипДанных = СтруктураКолонок[ИмяКолонки];
            Результат = ДобавитьКолонкуТаблицы(Модуль, Таблица, ИмяКолонки, ТипДанных, Соединение, Tls);

        Иначе
            Продолжить;
        КонецЕсли;

        Если Не Результат["result"] Тогда
            ВызватьИсключение Результат["error"];
        КонецЕсли;

    КонецЦикла;

    Возврат Неопределено;

КонецФункции

Функция СформироватьТекстФильтра(Знач Фильтры)

    Если Не ЗначениеЗаполнено(Фильтры) Тогда
        Возврат "";
    КонецЕсли;

    ТекстФильтров = "WHERE %1";

    МассивФильтров = Новый Массив;

    Счетчик = 1;
    Всего   = Фильтры.Количество();

    Для Каждого Фильтр Из Фильтры Цикл

        ТекущийТекст = "%1 %2 %3 %4";

        Поле       = Фильтр["field"];
        Тип        = Фильтр["type"];
        Значение   = Фильтр["value"];
        Соединение = Фильтр["union"];
        Соединение = ?(ЗначениеЗаполнено(Соединение), Соединение, "AND");

        Если Счетчик = Всего Тогда
            Соединение = "";
        КонецЕсли;

        ТекущийТекст = СтрШаблон(ТекущийТекст, Поле, Тип, Значение, Соединение);
        МассивФильтров.Добавить(ТекущийТекст);

        Счетчик = Счетчик + 1;

    КонецЦикла;

    ТекстФильтров = СтрШаблон(ТекстФильтров, СтрСоединить(МассивФильтров, " "));

    Возврат ТекстФильтров;

КонецФункции

Функция СформироватьТекстСортировки(Знач Сортировка)

    Если Не ЗначениеЗаполнено(Сортировка) Тогда
        Возврат "";
    КонецЕсли;

    ТекстСортировки = "ORDER BY %1";

    МассивСортировки = Новый Массив;

    Для Каждого Элемент Из Сортировка Цикл

        МассивСортировки.Добавить(Элемент["field"] + " " + Элемент["type"]);

    КонецЦикла;

    ТекстСортировки = СтрШаблон(ТекстСортировки, СтрСоединить(МассивСортировки, ", "));

    Возврат ТекстСортировки;

КонецФункции

Функция СформироватьТекстКоличества(Знач Количество)

    Если Не ЗначениеЗаполнено(Количество) Тогда
        Возврат "";
    КонецЕсли;

    ТекстКоличества = "LIMIT %1";
    ТекстКоличества = СтрШаблон(ТекстКоличества, OPI_Инструменты.ЧислоВСтроку(Количество));

    Возврат ТекстКоличества;

КонецФункции

Функция СформироватьТекстТопа(Знач Количество)

    Если Не ЗначениеЗаполнено(Количество) Тогда
        Возврат "";
    КонецЕсли;

    ТекстКоличества = "TOP %1";
    ТекстКоличества = СтрШаблон(ТекстКоличества, OPI_Инструменты.ЧислоВСтроку(Количество));

    Возврат ТекстКоличества;

КонецФункции

Процедура РазделитьКоллекциюДанных(Знач Запись, МассивПолей, МассивЗначений)

    ТекстОшибки = "Некорректный набор данных для обновления";
    OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Запись, ТекстОшибки);

    Для Каждого Элемент Из Запись Цикл

        МассивПолей.Добавить(Элемент.Ключ);
        МассивЗначений.Добавить(Элемент.Значение);

    КонецЦикла;

КонецПроцедуры

Процедура ЗаполнитьПоля(Схема, Знач Поля)

    Если Не ЗначениеЗаполнено(Поля) Тогда
        Поля = "*";
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьМассив(Поля);

    //@skip-check bsl-legacy-check-for-each-statetement-collection
    Для Каждого Поле Из Поля Цикл
        ДобавитьПоле(Схема, Поле);
    КонецЦикла;

КонецПроцедуры

Процедура ЗаполнитьФильтры(Схема, Знач Фильтры)

    Если Не ЗначениеЗаполнено(Фильтры) Тогда
        Возврат;
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьМассив(Фильтры);

    //@skip-check bsl-legacy-check-for-each-statetement-collection
    Для Каждого Фильтр Из Фильтры Цикл

        ДобавитьОтбор(Схема
            , Фильтр["field"]
            , ?(OPI_Инструменты.ПолеКоллекцииСуществует(Фильтр, "type"), Фильтр["type"], "=")
            , Фильтр["value"]
            , ?(OPI_Инструменты.ПолеКоллекцииСуществует(Фильтр, "union"), Фильтр["union"], "AND")
            , ?(OPI_Инструменты.ПолеКоллекцииСуществует(Фильтр, "raw"), Фильтр["raw"], Ложь));

    КонецЦикла;

КонецПроцедуры

Процедура ЗаполнитьСортировку(Знач Схема, Знач Сортировка)

    Если Не ЗначениеЗаполнено(Сортировка) Тогда
        Возврат;
    КонецЕсли;

    OPI_ПреобразованиеТипов.ПолучитьКоллекцию(Сортировка);

    //@skip-check bsl-legacy-check-for-each-statetement-collection
    Для Каждого Элемент Из Сортировка Цикл

        ДобавитьСортировку(Схема, Элемент.Ключ, Элемент.Значение);

    КонецЦикла;

КонецПроцедуры

Процедура ПроверитьОбязательныеПоляСхемы(Схема, Знач Поля)

    МассивОбязательныхПолей = СтрРазделить(Поля, ",");
    МассивОтсутствующих     = OPI_Инструменты.НайтиОтсутствующиеПоляКоллекции(Схема, МассивОбязательныхПолей);

    Если ЗначениеЗаполнено(МассивОтсутствующих) Тогда
        ВызватьИсключение "Отсутствуют необходимые поля схемы: " + СтрСоединить(МассивОтсутствующих, ", ");
    КонецЕсли;

КонецПроцедуры

Процедура ДобавитьКолонку(Схема, Знач Имя, Знач Тип) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Имя);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Тип);

    Если Не Схема["type"] = "CREATE" Тогда
        Возврат;
    КонецЕсли;

    СоответствиеКолонки = Новый Соответствие;
    СоответствиеКолонки.Вставить(Имя, Тип);

    Схема["columns"].Добавить(СоответствиеКолонки);

КонецПроцедуры

Процедура ДобавитьПоле(Схема, Знач Имя) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Имя);

    Схема["set"].Добавить(Имя);

КонецПроцедуры

Процедура ДобавитьОтбор(Схема
    , Знач Поле
    , Знач Тип
    , Знач Значение
    , Знач Группировка
    , Знач КакЕсть)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Поле);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Тип);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Группировка);
    OPI_ПреобразованиеТипов.ПолучитьБулево(КакЕсть);

    Нумерация = Схема["nump"];
    Маркер    = Схема["markp"];

    ОсновнаяСтруктура = Новый Структура("field,type,union"
        , Поле
        , Тип
        , Группировка);

    Если КакЕсть Тогда

        ОсновнаяСтруктура.Вставить("value", Строка(Значение));

    Иначе

        Схема["values"].Добавить(Значение);

        ТекущийМаркер = Маркер;

        Если Нумерация Тогда
            ПорядковыйНомер = Схема["values"].Количество();
            ТекущийМаркер   = ТекущийМаркер + OPI_Инструменты.ЧислоВСтроку(ПорядковыйНомер);
        КонецЕсли;

        ОсновнаяСтруктура.Вставить("value", ТекущийМаркер);

    КонецЕсли;

    Схема["filter"].Добавить(ОсновнаяСтруктура);

КонецПроцедуры

Процедура ДобавитьСортировку(Схема, Знач Поле, Знач Тип)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Поле);
    OPI_ПреобразованиеТипов.ПолучитьСтроку(Тип);

    Схема["order"].Добавить(Новый Структура("field,type", Поле, Тип));

КонецПроцедуры

Процедура УстановитьИмяТаблицы(Схема, Знач Имя)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Имя);

    Схема.Вставить("table", Имя);

КонецПроцедуры

Процедура УстановитьИмяБазы(Схема, Знач Имя)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Имя);

    Схема.Вставить("database", Имя);

КонецПроцедуры

Процедура УстановитьЛимит(Схема, Знач Количество)

    OPI_ПреобразованиеТипов.ПолучитьЧисло(Количество);

    Схема.Вставить("limit", Количество);

КонецПроцедуры

Процедура УстановитьПроизвольноеПоле(Схема, Знач ИмяПоля, Знач Значение, Знач ТипДанных)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(ИмяПоля);

    OPI_Инструменты.ДобавитьПоле(ИмяПоля, Значение, ТипДанных, Схема);

КонецПроцедуры

Процедура ЗаменитьСтандартныеОсобенности(Особенности)

    СтандартныеОсобенности = Новый Соответствие;
    СтандартныеОсобенности.Вставить("НумерацияПараметров", Истина);   // nump
    СтандартныеОсобенности.Вставить("МаркерПараметров"   , "?");      // markp
    СтандартныеОсобенности.Вставить("СУБД"               , "");       // dbms

    Для Каждого Особенность Из Особенности Цикл
        СтандартныеОсобенности.Вставить(Особенность.Ключ, Особенность.Значение);
    КонецЦикла;

    Особенности = СтандартныеОсобенности;

КонецПроцедуры

#КонецОбласти

#Область ОбработкаПараметров

Функция ИнициализироватьЗапрос(Знач Коннектор, Знач ТекстЗапроса, Знач ФорсироватьРезультат)

    Если OPI_Компоненты.ТребуетсяПередачаЧерезФайл() И СтрДлина(ТекстЗапроса) > 1000 Тогда

        // BSLLS:MissingTemporaryFileDeletion-off

        //@skip-check missing-temporary-file-deletion
        ИВФ     = ПолучитьИмяВременногоФайла();

        // BSLLS:MissingTemporaryFileDeletion-on

        ТекстДД = ПолучитьДвоичныеДанныеИзСтроки(ТекстЗапроса);
        ТекстДД.Записать(ИВФ);

        КлючЗапроса = Коннектор.InitQuery(ИВФ, ФорсироватьРезультат, Истина);

        OPI_Инструменты.УдалитьФайлВПопытке(ИВФ, "Не удалось удалить файл запроса после установки");

    Иначе
        КлючЗапроса = Коннектор.InitQuery(ТекстЗапроса, ФорсироватьРезультат, Ложь);
    КонецЕсли;

    КлючЗапроса = OPI_Инструменты.JSONВСтруктуру(КлючЗапроса);

    Возврат КлючЗапроса;

КонецФункции

Функция УстановитьПараметрыЗапроса(Знач Коннектор, Знач КлючЗапроса, Знач Параметры)

    Если OPI_Компоненты.ТребуетсяПередачаЧерезФайл() И ЗначениеЗаполнено(Параметры) Тогда

        // BSLLS:MissingTemporaryFileDeletion-off

        //@skip-check missing-temporary-file-deletion
        ИВФ = ПолучитьИмяВременногоФайла();

        // BSLLS:MissingTemporaryFileDeletion-on

        Попытка
            OPI_Инструменты.ЗаписатьJSONФайл(ИВФ, Параметры);
        Исключение
            ООп = ОписаниеОшибки();
            ВызватьИсключение СтрШаблон("Ошибка валидации JSON массива параметров: %1", ООп);
        КонецПопытки;

        Добавление = Коннектор.SetParamsFromFile(КлючЗапроса, ИВФ);

        OPI_Инструменты.УдалитьФайлВПопытке(ИВФ, "Не удалось удалить файл параметров запроса после установки");

    Иначе
        Параметры_ = OPI_Инструменты.JSONСтрокой(Параметры);
        Добавление = Коннектор.SetParamsFromString(КлючЗапроса, Параметры_);
    КонецЕсли;

    Добавление = OPI_Инструменты.JsonВСтруктуру(Добавление);

    Возврат Добавление;

КонецФункции

Функция ОбработатьРезультатЗапроса(Знач Коннектор, Знач КлючЗапроса, Знач РезультатВыполнения)

    РезультатВыполнения = OPI_Инструменты.JsonВСтруктуру(РезультатВыполнения);

    Если Не РезультатВыполнения["result"] Тогда

        Возврат РезультатВыполнения;

    ИначеЕсли РезультатВыполнения["data"] = Ложь Тогда

        РезультатВыполнения.Удалить("data");
        Возврат РезультатВыполнения;

    Иначе

        Если OPI_Компоненты.ТребуетсяПередачаЧерезФайл() Тогда

            // BSLLS:MissingTemporaryFileDeletion-off

            //@skip-check missing-temporary-file-deletion
            ИВФ = ПолучитьИмяВременногоФайла();

            // BSLLS:MissingTemporaryFileDeletion-on

            Результат = Коннектор.GetResultAsFile(КлючЗапроса, ИВФ);
            Результат = OPI_Инструменты.JsonВСтруктуру(Результат);

            Если Результат["result"] Тогда
                Результат = OPI_Инструменты.ПрочитатьJSONФайл(ИВФ, Истина);
            КонецЕсли;

            OPI_Инструменты.УдалитьФайлВПопытке(ИВФ, "Не удалось удалить файл результата запроса после установки");

        Иначе
            Результат = Коннектор.GetResultAsString(КлючЗапроса);
            Результат = OPI_Инструменты.JsonВСтруктуру(Результат);
        КонецЕсли;

        Возврат Результат;

    КонецЕсли;

КонецФункции

Функция ОбработатьПараметр(Знач Компонента, ТекущийПараметр, СтруктураТипов, КакОбъект = Истина)

    ТекущийТип  = ОпределитьТипПараметра(ТекущийПараметр);
    ТекущийКлюч = СтруктураТипов.Получить(ТекущийТип);

    Если ТекущийТип = "ДвоичныеДанные" Тогда

        ТекущийПараметр = ОбработатьBlob(Компонента, ТекущийПараметр);

    ИначеЕсли ТекущийТип = "УникальныйИдентификатор" Тогда

        ТекущийПараметр = Строка(ТекущийПараметр);

    ИначеЕсли ТекущийТип = "Дата" Тогда

        ТекущийПараметр = OPI_Инструменты.ДатаRFC3339(ТекущийПараметр);

    ИначеЕсли OPI_Инструменты.ЭтоКоллекция(ТекущийПараметр) Тогда

        ОбработатьПараметрКоллекцию(Компонента
            , ТекущийТип
            , СтруктураТипов
            , ТекущийПараметр
            , ТекущийКлюч);

    ИначеЕсли ТекущийТип = "Целое" Или ТекущийТип = "Дробное" Тогда

        OPI_ПреобразованиеТипов.ПолучитьЧисло(ТекущийПараметр);

    ИначеЕсли ТекущийТип = "Булево" Тогда

        OPI_ПреобразованиеТипов.ПолучитьБулево(ТекущийПараметр);

        Если СтруктураТипов.Получить("БулевоКакЧисло") Тогда
            ТекущийПараметр = ?(ТекущийПараметр, 1, 0);
        КонецЕсли;

    Иначе

        OPI_ПреобразованиеТипов.ПолучитьСтроку(ТекущийПараметр);

    КонецЕсли;

    Если КакОбъект И Не ТекущийПараметр = Неопределено Тогда
        ТекущийПараметр = Новый Структура(ТекущийКлюч, ТекущийПараметр);
    КонецЕсли;

    Возврат ТекущийПараметр;

КонецФункции

Функция ОбработатьBlob(Знач Компонента, Знач Значение)

    Результат = OPI_Компоненты.ПоместитьДанные(Компонента, Значение);

    Если Не Результат["result"] Тогда
        ВызватьИсключение СтрШаблон("Ошибка при передаче двоичного значения: %1", Результат["error"]);
    КонецЕсли;

    Возврат Результат["key"];

КонецФункции

Функция ОпределитьТипПараметра(Знач ТекущийПараметр)

    ТекущийТип = ТипЗнч(ТекущийПараметр);

    ОбычноеСопоставление = Новый Массив;
    ОбычноеСопоставление.Добавить("ДвоичныеДанные");
    ОбычноеСопоставление.Добавить("УникальныйИдентификатор");
    ОбычноеСопоставление.Добавить("Структура");
    ОбычноеСопоставление.Добавить("Соответствие");
    ОбычноеСопоставление.Добавить("Массив");
    ОбычноеСопоставление.Добавить("Булево");
    ОбычноеСопоставление.Добавить("Дата");
    ОбычноеСопоставление.Добавить("Строка");
    ОбычноеСопоставление.Добавить("Неопределено");

    Если ТекущийТип = Тип("Число") Тогда
        Возврат ?(Цел(ТекущийПараметр) = ТекущийПараметр, "Целое", "Дробное");
    Иначе

        Для Каждого ИмяТипа Из ОбычноеСопоставление Цикл

            Если ТекущийТип = Тип(ИмяТипа) Тогда
                Возврат ИмяТипа;
            КонецЕсли;

        КонецЦикла;

    КонецЕсли;

    ВызватьИсключение СтрШаблон("Тип параметра не поддерживается: %1", Строка(ТекущийТип));

КонецФункции

Процедура ОбработатьПараметрКоллекцию(Знач Компонента
    , Знач ТекущийТип
    , Знач СтруктураТипов
    , ТекущийПараметр
    , ТекущийКлюч)

    ТипыКоллекции = СтруктураТипов.Получить("Коллекции");
    ТипДвоичные   = СтруктураТипов.Получить("ДвоичныеДанные");
    ТипСтрока     = СтруктураТипов.Получить("Строка");

    Если ТекущийТип = "Структура" Или ТекущийТип = "Соответствие" Тогда

        //@skip-check bsl-legacy-check-for-each-statetement-collection
        Для Каждого ЭлементПараметра Из ТекущийПараметр Цикл

            ТекущийКлюч     = вРег(ЭлементПараметра.Ключ);
            ТекущееЗначение = ЭлементПараметра.Значение;

            Если ТипыКоллекции.НайтиПоЗначению(ТекущийКлюч) <> Неопределено Тогда
                ТекущийПараметр = ТекущееЗначение;

            ИначеЕсли ТекущийКлюч = ТипДвоичные Тогда
                ТекущийПараметр = ОбработатьBlob(Компонента, ТекущееЗначение);
            Иначе
                ТекущийПараметр = ОбработатьПараметр(Компонента, ТекущееЗначение, СтруктураТипов, Ложь);
            КонецЕсли;

            Прервать;

        КонецЦикла;

    Иначе

        OPI_ПреобразованиеТипов.ПолучитьСтроку(ТекущийПараметр);
        ТекущийКлюч = ТипСтрока;

    КонецЕсли;

КонецПроцедуры

#КонецОбласти

#КонецОбласти
