// OneScript: ./OInt/tools/main/Modules/internal/Modules/internal/Modules/OPI_ПреобразованиеТипов.os

// MIT License

// Copyright (c) 2023-2026 Anton Tsitavets

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// https://github.com/Bayselonarrend/OpenIntegrations

// BSLLS:LatinAndCyrillicSymbolInWord-off
// BSLLS:IncorrectLineBreak-off
// BSLLS:UnusedLocalVariable-off
// BSLLS:UsingServiceTag-off
// BSLLS:UsingSynchronousCalls-off
// BSLLS:CognitiveComplexity-off

//@skip-check module-structure-top-region
//@skip-check module-structure-method-in-regions
//@skip-check undefined-function-or-procedure
//@skip-check wrong-string-literal-content

#Область СлужебныйПрограммныйИнтерфейс

Процедура ПолучитьДвоичныеДанные(Значение, Знач Безусловно = Ложь, Знач ПопыткаB64 = Истина) Экспорт

    Если Значение = Неопределено Тогда
        Значение = ПолучитьДвоичныеДанныеИзСтроки("");
        Возврат;
    КонецЕсли;

    Попытка

        Если ТипЗнч(Значение) = Тип("ДвоичныеДанные") Тогда

            Возврат;

        ИначеЕсли ЭтоКоллекция(Значение) Тогда

            Значение = JSONСтрокой(Значение);
            Значение = ПолучитьДвоичныеДанныеИзСтроки(Значение);

        Иначе
            ПолучитьСтроку(Значение);
            ПреобразоватьИсточникВЗначение(Значение, ПопыткаB64);
        КонецЕсли;

    Исключение

        Если Безусловно Тогда
            ПолучитьСтроку(Значение);
            Значение = ПолучитьДвоичныеДанныеИзСтроки(Значение);
        Иначе
            ВызватьИсключение "Ошибка получения двоичных данных из параметра: " + ОписаниеОшибки();
        КонецЕсли;

    КонецПопытки;

КонецПроцедуры

Процедура ПолучитьДвоичныеИлиПоток(Значение) Экспорт

    Если Значение = Неопределено Тогда
        Возврат;
    КонецЕсли;

    Если ТипЗнч(Значение) <> Тип("Строка") Тогда
        ПолучитьДвоичныеДанные(Значение);
        Возврат;
    КонецЕсли;

    ЗначениеУП = Значение;
    ВернутьУправляющиеПоследовательности(ЗначениеУП);

    Файл = Новый Файл(ЗначениеУП);

    Если Файл.Существует() Тогда
        Значение = Новый ФайловыйПоток(ЗначениеУП, РежимОткрытияФайла.Открыть);
    Иначе
        ПолучитьДвоичныеДанные(Значение);
    КонецЕсли;

КонецПроцедуры

Процедура ПолучитьКоллекцию(Значение, ПоСети = Истина, Успех = Ложь) Экспорт

    Успех = Ложь;

    Если Значение = Неопределено Тогда
        Возврат;
    КонецЕсли;

    Успех = Истина;

    Попытка

        // BSLLS:ExternalAppStarting-off

        ИсходноеЗначение = Значение;

        Если ЭтоКоллекция(Значение) Тогда
            Возврат;
        Иначе

            Если ТипЗнч(Значение) = Тип("ДвоичныеДанные") Тогда
                Значение = ПолучитьСтрокуИзДвоичныхДанных(Значение);
            Иначе
                Значение = ЧислоВСтроку(Значение);
            КонецЕсли;

            ЗначениеУП = Значение;
            ВернутьУправляющиеПоследовательности(ЗначениеУП);

            Файл       = Новый Файл(ЗначениеУП);
            ЧтениеJSON = Новый ЧтениеJSON;

            Если Файл.Существует() Тогда

                ЧтениеJSON.ОткрытьФайл(ЗначениеУП);
                Значение = ПрочитатьJSON(ЧтениеJSON, Истина, Неопределено, ФорматДатыJSON.ISO);
                ЧтениеJSON.Закрыть();

            ИначеЕсли ПоСети И (СтрНачинаетсяС(СокрЛ(ЗначениеУП), "http://")
                Или СтрНачинаетсяС(СокрЛ(ЗначениеУП), "https://")) Тогда

                Значение = ПолучитьHttpКлиент().Get(ЗначениеУП);

            Иначе

                ЧтениеJSON.УстановитьСтроку(СокрЛП(Значение));
                Значение = ПрочитатьJSON(ЧтениеJSON, Истина, Неопределено, ФорматДатыJSON.ISO);
                ЧтениеJSON.Закрыть();

            КонецЕсли;

            Если (Не ЭтоКоллекция(Значение)) Или Не ЗначениеЗаполнено(Значение) Тогда

                Успех    = Ложь;
                Значение = ИсходноеЗначение;
                ЗначениеВМассив(Значение);

            КонецЕсли;

        КонецЕсли;

        // BSLLS:ExternalAppStarting-on

    Исключение

        Успех    = Ложь;
        Значение = ИсходноеЗначение;
        ЗначениеВМассив(Значение);

    КонецПопытки;

КонецПроцедуры

Процедура ПолучитьКоллекциюКлючИЗначение(Значение
    , Знач СообщениеОшибки = "Указанное значение не является подходящей коллекцией!") Экспорт

    ПолучитьКоллекцию(Значение);

    Если ТипЗнч(Значение) = Тип("Массив") Тогда
        ВызватьИсключение СообщениеОшибки;
    КонецЕсли;

КонецПроцедуры

Процедура ПолучитьМассив(Значение) Экспорт

    Если ТипЗнч(Значение) = Тип("Массив") Тогда
        Возврат;
    КонецЕсли;

    ПолучитьКоллекцию(Значение);

    Если Не ТипЗнч(Значение) = Тип("Массив") Тогда
        ЗначениеВМассив(Значение);
    КонецЕсли;

КонецПроцедуры

Процедура ПолучитьБулево(Значение) Экспорт

    Если Значение = Неопределено Тогда
        Возврат;
    КонецЕсли;

    Попытка

        Если ТипЗнч(Значение) = Тип("Булево") Тогда

            Возврат;

        Иначе

            Значение = Булево(Значение);

        КонецЕсли;

    Исключение
        ВызватьИсключение "Ошибка получения данных булево из параметра";
    КонецПопытки;

КонецПроцедуры

Процедура ПолучитьСтроку(Значение, Знач ИзИсточника = Ложь) Экспорт

    Если Значение = Неопределено Тогда
        Возврат;
    КонецЕсли;

    Попытка

        Если ЭтоСимвольное(Значение) Тогда

            Значение = ЧислоВСтроку(Значение);

            Если Не ИзИсточника Тогда
                Возврат;
            КонецЕсли;

            ЗначениеУП = Значение;
            ВернутьУправляющиеПоследовательности(ЗначениеУП);

            Файл = Новый Файл(ЗначениеУП);

            Если Файл.Существует() Тогда

                ЧтениеТекста = Новый ЧтениеТекста(ЗначениеУП);
                Значение     = ЧтениеТекста.Прочитать();
                ЧтениеТекста.Закрыть();

            ИначеЕсли СтрНачинаетсяС(СокрЛ(ЗначениеУП), "http://")
                Или СтрНачинаетсяС(СокрЛ(ЗначениеУП), "https://") Тогда

                Значение = ПолучитьHttpКлиент().Get(ЗначениеУП);
                ПолучитьСтроку(Значение);

            Иначе

                Значение = ЧислоВСтроку(Значение);

            КонецЕсли;

        ИначеЕсли ТипЗнч(Значение) = Тип("ДвоичныеДанные") Тогда

            Значение = ПолучитьСтрокуИзДвоичныхДанных(Значение);

        ИначеЕсли ЭтоКоллекция(Значение) Тогда

            Значение = JSONСтрокой(Значение);

        ИначеЕсли ТипЗнч(Значение) = Тип("ЗаписьXML") Тогда

            Значение = Значение.Закрыть();

        Иначе
            Возврат;
        КонецЕсли;

    Исключение
        Значение = Строка(Значение);
        Возврат;
    КонецПопытки;

КонецПроцедуры

Процедура ПолучитьДату(Значение) Экспорт

    Если Значение = Неопределено Тогда
        Возврат;
    КонецЕсли;

    Дата = "Дата";

    Попытка

        Если ТипЗнч(Значение) = Тип(Дата) Тогда

            Возврат;

        Иначе

            Значение = XMLЗначение(Тип(Дата), Значение);

        КонецЕсли;

    Исключение
        ООД      = Новый ОписаниеТипов(Дата);
        Значение = ООД.ПривестиЗначение(Значение);
    КонецПопытки;

КонецПроцедуры

Процедура ПолучитьЧисло(Значение) Экспорт

    Если ТипЗнч(Значение) = Тип("Число") Тогда

        Возврат;

    ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда

        Значение = ?(Значение, 1, 0);

    Иначе

        ОписаниеТипа = Новый ОписаниеТипов("Число");
        Значение_    = ОписаниеТипа.ПривестиЗначение(Значение);

        Если Значение_ = 0 Тогда

            Попытка

                Значение_ = Строка(Значение);
                Значение_ = СтрЗаменить(Значение, Символы.НПП, "");
                Значение_ = СтрЗаменить(Значение, " "        , "");
                Значение_ = СтрЗаменить(Значение, ","        , ".");

                Если СтрЧислоВхождений(Значение_, ".") > 1 Тогда

                    МассивЧастей   = СтрРазделить(Значение_, ".");
                    ПоследняяЧасть = МассивЧастей.ВГраница();
                    ДробнаяЧасть   = МассивЧастей[ПоследняяЧасть];

                    МассивЧастей.Удалить(ПоследняяЧасть);

                    Значение_ = СтрШаблон("%1.%2", СтрСоединить(МассивЧастей), ДробнаяЧасть);

                КонецЕсли;

                // BSLLS:TryNumber-off
                Значение = Число(Значение_);
                // BSLLS:TryNumber-on

            Исключение
                Возврат;
            КонецПопытки;

        Иначе
            Значение = Значение_;
        КонецЕсли;

    КонецЕсли;

КонецПроцедуры

Процедура ПолучитьФайлНаДиске(Значение, Знач Расширение = "tmp") Экспорт

    СтруктураВозврата = Новый Структура("Путь,Временный", "", Ложь);
    ЗначениеСтрокой   = ЧислоВСтроку(Значение);
    ЗначениеФайл      = Новый Файл(ЗначениеСтрокой);

    Если ЗначениеФайл.Существует() Тогда

        СтруктураВозврата.Вставить("Путь", ЗначениеФайл.ПолноеИмя);

    Иначе

        ПолучитьДвоичныеДанные(Значение, Истина);

        // BSLLS:MissingTemporaryFileDeletion-off

        //@skip-check missing-temporary-file-deletion
        Путь = ПолучитьИмяВременногоФайла(Расширение);

        // BSLLS:MissingTemporaryFileDeletion-on

        Значение.Записать(Путь);

        СтруктураВозврата.Вставить("Путь"     , Путь);
        СтруктураВозврата.Вставить("Временный", Истина);

    КонецЕсли;

    Значение = СтруктураВозврата;

КонецПроцедуры

Процедура ВернутьУправляющиеПоследовательности(Текст) Экспорт

    ПолучитьСтроку(Текст);

    СоответствиеСимволов = ПолучитьСоответствиеУправляющихПоследовательностей();

    Для Каждого Символ Из СоответствиеСимволов Цикл

        Текст = СтрЗаменить(Текст, Символ.Значение, Символ.Ключ);

    КонецЦикла;

КонецПроцедуры

Процедура ЗаменитьУправляющиеПоследовательности(Текст) Экспорт

    ПолучитьСтроку(Текст);

    СоответствиеСимволов = ПолучитьСоответствиеУправляющихПоследовательностей();

    Для Каждого Символ Из СоответствиеСимволов Цикл

        Текст = СтрЗаменить(Текст, Символ.Ключ          , Символ.Значение);
        Текст = СтрЗаменить(Текст, "\" + Символ.Значение, Символ.Ключ);

    КонецЦикла;

КонецПроцедуры

Процедура ЗначениеВМассив(Значение) Экспорт

    Если ТипЗнч(Значение) = Тип("Массив") Тогда
        Возврат;
    КонецЕсли;

    Значение_ = Новый Массив;
    Значение_.Добавить(Значение);

    Значение = Значение_;

КонецПроцедуры

Функция JSONСтрокой(Знач Данные
    , Знач Экранирование  = "Нет"
    , Знач ПереносСтрок   = Истина
    , Знач ДвойныеКавычки = Истина) Экспорт

    Перенос = ?(ПереносСтрок, ПереносСтрокJSON.Windows, ПереносСтрокJSON.Нет);

    ПараметрыJSON = Новый ПараметрыЗаписиJSON(Перенос
        , " "
        , ДвойныеКавычки
        , ЭкранированиеСимволовJSON[Экранирование]
        , Ложь
        , Ложь
        , Ложь
        , Ложь);

    Попытка

        ЗаписьJSON = Новый ЗаписьJSON;
        ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);

        ЗаписатьJSON(ЗаписьJSON, Данные);
        Возврат ЗаписьJSON.Закрыть();

    Исключение
        Возврат "НЕ JSON: " + Строка(Данные);
    КонецПопытки;

КонецФункции

Функция ЧислоВСтроку(Знач Значение) Экспорт

    Если ТипЗнч(Значение) = Тип("Число") Тогда

        Если Значение = 0 Тогда
            Значение_ = "0";
        Иначе
            Значение_ = Формат(Значение, "ЧГ=0");
        КонецЕсли;

    Иначе
        Значение_ = Строка(Значение);
    КонецЕсли;

    Возврат Значение_;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ЭтоКоллекция(Знач Значение)

    Возврат ТипЗнч(Значение) = Тип("Массив")
        Или ТипЗнч(Значение) = Тип("Структура")
        Или ТипЗнч(Значение) = Тип("Соответствие");

КонецФункции

Функция ЭтоСимвольное(Знач Значение)

    Возврат ТипЗнч(Значение) = Тип("Строка")
        Или ТипЗнч(Значение) = Тип("Число")
        Или ТипЗнч(Значение) = Тип("Дата");

КонецФункции

Функция ПолучитьСоответствиеУправляющихПоследовательностей()

    СоответствиеСимволов = Новый Соответствие;

    СоответствиеСимволов.Вставить("\n"  , Символы.ПС);
    СоответствиеСимволов.Вставить("\r"  , Символы.ВК);
    СоответствиеСимволов.Вставить("\f"  , Символы.ПФ);
    СоответствиеСимволов.Вставить("\v"  , Символы.ВТаб);

    Возврат СоответствиеСимволов;

КонецФункции

Процедура ПреобразоватьИсточникВЗначение(Значение, ПопыткаB64)

    ЗначениеУП = Значение;
    ВернутьУправляющиеПоследовательности(ЗначениеУП);

    Файл = Новый Файл(ЗначениеУП);

    Если Файл.Существует() Тогда

        Значение = Новый ДвоичныеДанные(ЗначениеУП);

    ИначеЕсли СтрНачинаетсяС(СокрЛ(ЗначениеУП), "http://")
        Или СтрНачинаетсяС(СокрЛ(ЗначениеУП), "https://") Тогда

        Значение = ПолучитьHttpКлиент().Get(ЗначениеУП);

    Иначе

        Если ПопыткаB64 Тогда

            Значение_ = Base64Значение(Значение);

            Если ТипЗнч(Значение_) = Тип("ДвоичныеДанные") Тогда
                Успех = Значение_.Размер() <> 0;
            Иначе
                Успех = Ложь;
            КонецЕсли;

            Если Успех Тогда
                Значение = Значение_;
            КонецЕсли;

        Иначе
            Успех = Ложь;
        КонецЕсли;

        Если Не Успех Тогда
            ВызватьИсключение "Значение не является путем к файлу или Base64 строкой";
        КонецЕсли;

    КонецЕсли;

КонецПроцедуры

#Область HttpКлиент

Функция ПолучитьHttpКлиент()

    Если ЭтоOneScript() Тогда

        Попытка
            OPI_ЗапросыHTTP = Неопределено;
        Исключение
            Возврат OPI_ЗапросыHTTP;
        КонецПопытки;

        //@skip-check module-unused-local-variable
        ПутьКлиента = ПолучитьПутьHttpКлиента();

        ПодключитьСценарий(ПутьКлиента, "OPI_ЗапросыHTTP");

        Возврат OPI_ЗапросыHTTP;

    Иначе
        Возврат OPI_ЗапросыHTTP;
    КонецЕсли;

КонецФункции

Функция ПолучитьПутьHttpКлиента() Экспорт

    КаталогСкрипта = "";

    КаталогСкрипта = ТекущийСценарий().Каталог;

    Если Не ЗначениеЗаполнено(КаталогСкрипта) Тогда
        Возврат "";
    КонецЕсли;

    КаталогСкрипта = СтрЗаменить(КаталогСкрипта, "\", "/");
    МассивЧастей   = СтрРазделить(КаталогСкрипта, "/");

    МассивЧастей.Удалить(МассивЧастей.ВГраница());
    МассивЧастей.Удалить(МассивЧастей.ВГраница());
    МассивЧастей.Удалить(МассивЧастей.ВГраница());
    МассивЧастей.Удалить(МассивЧастей.ВГраница());
    МассивЧастей.Удалить(МассивЧастей.ВГраница());
    МассивЧастей.Удалить(МассивЧастей.ВГраница());
    МассивЧастей.Удалить(МассивЧастей.ВГраница());

    МассивЧастей.Добавить("tools");
    МассивЧастей.Добавить("http");
    МассивЧастей.Добавить("Modules");
    МассивЧастей.Добавить("OPI_ЗапросыHTTP.os");

    Путь = СтрСоединить(МассивЧастей, "/");

    Возврат Путь;

КонецФункции

Функция ЭтоOneScript()

    Попытка

        Ответ = Ложь;

        // BSLLS:UnusedLocalVariable-off

        //@skip-check module-unused-local-variable
        Проверка = Новый ЗащищенноеСоединениеOpenSSL;

        // BSLLS:UnusedLocalVariable-on

    Исключение

        Ответ = Истина;

    КонецПопытки;

    Возврат Ответ;

КонецФункции

#КонецОбласти

#КонецОбласти

#Region Alternate

Procedure GetBinaryData(Value, Val Force = False, Val TryB64 = True) Export
    ПолучитьДвоичныеДанные(Value, Force, TryB64);
EndProcedure

Procedure GetBinaryOrStream(Value) Export
    ПолучитьДвоичныеИлиПоток(Value);
EndProcedure

Procedure GetCollection(Value, ByNetwork = True, Success = False) Export
    ПолучитьКоллекцию(Value, ByNetwork, Success);
EndProcedure

Procedure GetKeyValueCollection(Value, Val ErrorText = "The specified value is not a valid collection!") Export
    ПолучитьКоллекциюКлючИЗначение(Value, ErrorText);
EndProcedure

Procedure GetArray(Value) Export
    ПолучитьМассив(Value);
EndProcedure

Procedure GetBoolean(Value) Export
    ПолучитьБулево(Value);
EndProcedure

Procedure GetLine(Value, Val FromSource = False) Export
    ПолучитьСтроку(Value, FromSource);
EndProcedure

Procedure GetDate(Value) Export
    ПолучитьДату(Value);
EndProcedure

Procedure GetNumber(Value) Export
    ПолучитьЧисло(Value);
EndProcedure

Procedure GetFileOnDisk(Value, Val Extension = "tmp") Export
    ПолучитьФайлНаДиске(Value, Extension);
EndProcedure

Procedure RestoreEscapeSequences(Text) Export
    ВернутьУправляющиеПоследовательности(Text);
EndProcedure

Procedure ReplaceEscapeSequences(Text) Export
    ЗаменитьУправляющиеПоследовательности(Text);
EndProcedure

Procedure ValueToArray(Value) Export
    ЗначениеВМассив(Value);
EndProcedure

Function JSONString(Val Data, Val Escaping = "None", Val LineBreaks = True, Val DoubleQuotes = True) Export
    Return JSONСтрокой(Data, Escaping, LineBreaks, DoubleQuotes);
EndFunction

Function NumberToString(Val Value) Export
    Return ЧислоВСтроку(Value);
EndFunction

Function GetHttpClientPath() Export
    Return ПолучитьПутьHttpКлиента();
EndFunction

#EndRegion