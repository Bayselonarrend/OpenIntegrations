// OneScript: ./OInt/tools/Modules/internal/Modules/OPI_Инструменты.os

// MIT License

// Copyright (c) 2023 Anton Tsitavets

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// https://github.com/Bayselonarrend/OpenIntegrations

// BSLLS:Typo-off
// BSLLS:LatinAndCyrillicSymbolInWord-off
// BSLLS:IncorrectLineBreak-off
// BSLLS:UnusedLocalVariable-off
// BSLLS:UsingServiceTag-off
// BSLLS:NumberOfOptionalParams-off

//@skip-check module-unused-local-variable
//@skip-check method-too-many-params
//@skip-check module-structure-top-region
//@skip-check module-structure-method-in-regions
//@skip-check wrong-string-literal-content
#Область СлужебныйПрограммныйИнтерфейс

#Область HTTPМетоды

#Область ЗапросыБезТела

Функция Get(Знач URL, Знач Параметры = "", Знач ДопЗаголовки = "", Знач ФайлОтвета = Неопределено) Экспорт
    Возврат ВыполнитьЗапросБезТела(URL, "GET", Параметры, ДопЗаголовки, ФайлОтвета);
КонецФункции

Функция Delete(Знач URL, Знач Параметры = "", Знач ДопЗаголовки = "", Знач ФайлОтвета = Неопределено) Экспорт
    Возврат ВыполнитьЗапросБезТела(URL, "DELETE", Параметры, ДопЗаголовки, ФайлОтвета);
КонецФункции

#КонецОбласти

#Область ЗапросыСТелом

Функция Post(Знач URL, Знач Параметры = "", Знач ДопЗаголовки = "", Знач JSON = Истина, Знач ПолныйОтвет = Ложь,
    Знач ФайлОтвета = Неопределено) Экспорт

    Возврат ВыполнитьЗапросСТелом(URL, "POST", Параметры, ДопЗаголовки, JSON, ПолныйОтвет, ФайлОтвета);

КонецФункции

Функция Patch(Знач URL, Знач Параметры = "", Знач ДопЗаголовки = "", Знач JSON = Истина, Знач ПолныйОтвет = Ложь,
    Знач ФайлОтвета = Неопределено) Экспорт

    Возврат ВыполнитьЗапросСТелом(URL, "PATCH", Параметры, ДопЗаголовки, JSON, ПолныйОтвет, ФайлОтвета);

КонецФункции

Функция Put(Знач URL, Знач Параметры = "", Знач ДопЗаголовки = "", Знач JSON = Истина, Знач ПолныйОтвет = Ложь,
    Знач ФайлОтвета = Неопределено) Экспорт

    Возврат ВыполнитьЗапросСТелом(URL, "PUT", Параметры, ДопЗаголовки, JSON, ПолныйОтвет, ФайлОтвета);

КонецФункции

Функция PostBinary(Знач URL, Знач Тело, Знач ДопЗаголовки, Знач ПолныйОтвет = Ложь,
    Знач ТипДанных = "application/octet-stream") Экспорт

    Возврат ВыполнитьЗапросСДвоичнымиДанными(URL, "POST", Тело, ДопЗаголовки, ПолныйОтвет, ТипДанных);

КонецФункции

#КонецОбласти

#Область ЗапросыMultipart

Функция PostMultipart(Знач URL, Знач Параметры = "", Знач Файлы = "", Знач ТипКонтента = "image/jpeg",
    Знач ДопЗаголовки = "", Знач ФайлОтвета = Неопределено) Экспорт

    Возврат ВыполнитьЗапросМультипарт(URL, "POST", Параметры, Файлы, ТипКонтента, ДопЗаголовки, ФайлОтвета);

КонецФункции

Функция PutMultipart(Знач URL, Знач Параметры = "", Знач Файлы = "", Знач ТипКонтента = "image/jpeg",
    Знач ДопЗаголовки = "", Знач ФайлОтвета = Неопределено) Экспорт

    Возврат ВыполнитьЗапросМультипарт(URL, "PUT", Параметры, Файлы, ТипКонтента, ДопЗаголовки, ФайлОтвета);

КонецФункции

Функция PostMultipartRelated(Знач URL, Знач JSON = "", Знач Файлы = "", Знач ДопЗаголовки = "",
    Знач ФайлОтвета = Неопределено) Экспорт

    Возврат ВыполнитьЗапросМультипартРелэйтед(URL, "POST", JSON, Файлы, ДопЗаголовки, ФайлОтвета);

КонецФункции

Функция PatchMultipartRelated(Знач URL, Знач JSON = "", Знач Файлы = "", Знач ДопЗаголовки = "",
    Знач ФайлОтвета = Неопределено) Экспорт

    Возврат ВыполнитьЗапросМультипартРелэйтед(URL, "PATCH", JSON, Файлы, ДопЗаголовки, ФайлОтвета);

КонецФункции

#КонецОбласти

#Область Прочее

Процедура ОбработатьОтвет(Ответ, Знач ПолныйОтвет = Ложь) Экспорт

    Если ПолныйОтвет Или ТипЗнч(Ответ) <> Тип("HTTPОтвет") Тогда
        Возврат;
    КонецЕсли;

    ФайлТела = Ответ.ПолучитьИмяФайлаТела();

    Если Не ФайлТела = Неопределено Тогда
        Ответ           = ФайлТела;
        Возврат;
    КонецЕсли;

    GZip = "gzip";
    НужнаРаспаковка      = Ответ.Заголовки.Получить("Content-Encoding")      = GZip Или Ответ.Заголовки.Получить(
        "content-encoding") = GZip;

    Если НужнаРаспаковка Тогда
        Ответ = РаспаковатьОтвет(Ответ);
    КонецЕсли;

    Ответ = ?(ТипЗнч(Ответ) = Тип("HTTPОтвет"), Ответ.ПолучитьТелоКакДвоичныеДанные(), Ответ);

    Если ТипЗнч(Ответ) = Тип("ДвоичныеДанные") Тогда

        Если Ответ.Размер() = 0 Тогда
            Ответ              = ПолучитьДвоичныеДанныеИзСтроки("{}");
        КонецЕсли;

        Попытка
            Ответ = JsonВСтруктуру(Ответ);
        Исключение
            Возврат;
        КонецПопытки;

    КонецЕсли;

КонецПроцедуры

Функция СоздатьЗапрос(Знач Адрес, Знач ДопЗаголовки = "", Знач ТипДанных = "") Экспорт

    Заголовки = Новый Соответствие;
    Заголовки.Вставить("Accept-Encoding", "gzip");
    Заголовки.Вставить("Accept"         , "*/*");
    Заголовки.Вставить("Connection"     , "keep-alive");
    Заголовки.Вставить("Accept-Charset" , "utf-8");

    Если ЗначениеЗаполнено(ТипДанных) Тогда
        Заголовки.Вставить("Content-Type", ТипДанных);
    КонецЕсли;

    Если ТипЗнч(ДопЗаголовки) = Тип("Соответствие") Тогда

        Для Каждого Заголовок Из ДопЗаголовки Цикл
            Заголовки.Вставить(Заголовок.Ключ, Заголовок.Значение);
        КонецЦикла;

    КонецЕсли;

    НовыйЗапрос = Новый HTTPЗапрос(Адрес, Заголовки);

    Возврат НовыйЗапрос;

КонецФункции

Функция СоздатьСоединение(Знач Сервер, Знач Защищенное = Истина, Знач Пользователь = "", Знач Пароль = "") Экспорт

    Если Защищенное Тогда

        Если ЭтоOneScript() Тогда
            Соединение    = Новый HTTPСоединение(Сервер, 443, Пользователь, Пароль, , 3000);
        Иначе
            SSL           = Новый ЗащищенноеСоединениеOpenSSL;
            Соединение    = Новый HTTPСоединение(Сервер, 443, Пользователь, Пароль, , 3000, SSL);
        КонецЕсли;

    Иначе

        Соединение = Новый HTTPСоединение(Сервер, 80, Пользователь, Пароль, , 3000, SSL);

    КонецЕсли;

    Возврат Соединение;

КонецФункции

Функция ВыполнитьЗапрос(Знач Запрос, Знач Соединение, Знач Вид, Знач ФайлОтвета = "", Знач ПолныйОтвет = Ложь) Экспорт

    Если ЗначениеЗаполнено(ФайлОтвета) Тогда
        Ответ = Соединение.ВызватьHTTPМетод(Вид, Запрос, ФайлОтвета);
    Иначе
        Ответ = Соединение.ВызватьHTTPМетод(Вид, Запрос);
    КонецЕсли;

    Если ЭтоПереадресация(Ответ) Тогда

        URL = Ответ.Заголовки["Location"];

        СтруктураURL  = РазбитьURL(URL);
        Сервер        = СтруктураURL["Сервер"];
        Адрес         = СтруктураURL["Адрес"];
        Защищенное    = СтруктураURL["Защищенное"];

        Соединение          = СоздатьСоединение(Сервер, Защищенное);
        Запрос.АдресРесурса = Адрес;

        Ответ = ВыполнитьЗапрос(Запрос, Соединение, Вид, ФайлОтвета, ПолныйОтвет);

    Иначе
        ОбработатьОтвет(Ответ, ПолныйОтвет);
    КонецЕсли;

    Возврат Ответ;

КонецФункции

Функция СоздатьЗапросСТелом(Знач Адрес, Знач Параметры, Знач ДопЗаголовки, Знач JSON) Экспорт

    ТипДанных = ?(JSON, "application/json; charset=utf-8", "application/x-www-form-urlencoded; charset=utf-8");
    Запрос    = СоздатьЗапрос(Адрес, ДопЗаголовки, ТипДанных);

    УстановитьТелоЗапроса(Запрос, Параметры, JSON);

    Возврат Запрос;

КонецФункции

Функция СоздатьЗапросМультипарт(Знач Адрес, Знач Параметры, Знач Файлы, Знач ДопЗаголовки, Знач ИмяФайла,
    Знач ТипКонтента) Экспорт

    Boundary         = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
    РазделительСтрок = Символы.ВК + Символы.ПС;
    ТипДанных        = "multipart/form-data; boundary=" + Boundary;

    Запрос        = СоздатьЗапрос(Адрес, ДопЗаголовки, ТипДанных);

    ЗаписьТекста = Новый ЗаписьДанных(ИмяФайла, КодировкаТекста.UTF8, ПорядокБайтов.LittleEndian, "", Ложь, "", Ложь);

    ЗаписатьПараметрыМультипарт(ЗаписьТекста, Boundary, Параметры);
    ЗаписатьФайлыМультипарт(ЗаписьТекста, Boundary, ТипКонтента, Файлы);

    ЗаписьТекста.ЗаписатьСтроку("--" + boundary + "--" + РазделительСтрок);
    ЗаписьТекста.Закрыть();

    Запрос.УстановитьИмяФайлаТела(ИмяФайла);

    Возврат Запрос

КонецФункции

Функция СоздатьЗапросМультипартРелэйтед(Знач Адрес, Знач Файлы, Знач JSON, Знач ДопЗаголовки, Знач ИмяФайла) Экспорт

    Boundary         = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
    РазделительСтрок = Символы.ВК + Символы.ПС;
    ТипДанных        = "multipart/related; boundary=" + Boundary;

    Запрос        = СоздатьЗапрос(Адрес, ДопЗаголовки, ТипДанных);
    ЗаписьТекста  = Новый ЗаписьДанных(ИмяФайла, КодировкаТекста.UTF8, ПорядокБайтов.LittleEndian, "", Ложь, "", Ложь);

    ЗаписатьJSONМультипарт(ЗаписьТекста, Boundary, JSON);
    ЗаписатьФайлыРелэйтед(ЗаписьТекста, Boundary, Файлы);

    ЗаписьТекста.ЗаписатьСтроку("--" + boundary + "--" + РазделительСтрок);
    ЗаписьТекста.Закрыть();

    ДобавитьContentLength(Запрос);

    Запрос.УстановитьИмяФайлаТела(ИмяФайла);

    Возврат Запрос;

КонецФункции

#КонецОбласти

#КонецОбласти

#Область Служебные

Функция ПараметрыЗапросаВСтроку(Знач Параметры, Знач ОтдельныеЭлементыМассивов = Ложь, Знач Начало = Истина) Экспорт

    Если Параметры.Количество() = 0 Тогда
        Возврат "";
    КонецЕсли;

    СтрокаПараметров = ?(Начало, "?", "&");

    Для Каждого Параметр Из Параметры Цикл

        ТекущееЗначение = Параметр.Значение;
        ТекущийКлюч     = Параметр.Ключ;

        Если Не ТипЗнч(ТекущееЗначение) = Тип("Массив") Или Не ОтдельныеЭлементыМассивов Тогда

            ЗначениеПараметра = ПреобразоватьПараметрВСтроку(ТекущееЗначение);

            СтрокаПараметров = СтрокаПараметров + Параметр.Ключ + "=" + ЗначениеПараметра + "&";

        Иначе

            ЗначениеПараметра = РазделитьМассивНаПараметрыURL(ТекущийКлюч, ТекущееЗначение);
            СтрокаПараметров  = СтрокаПараметров + ЗначениеПараметра + "&";

        КонецЕсли;

    КонецЦикла;

    СтрокаПараметров = Лев(СтрокаПараметров, СтрДлина(СтрокаПараметров) - 1);

    Возврат СтрокаПараметров;

КонецФункции

Функция РазбитьURL(Знач URL) Экспорт

    ЗащищенноеСоединение = Не СтрНачинаетсяС(URL, "http://");

    URL = СтрЗаменить(URL, "https://", "");
    URL = СтрЗаменить(URL, "http://" , "");
    URL = СтрЗаменить(URL, ":443"    , "");

    Если СтрНайти(URL, "/") = 0 Тогда
        Адрес  = "";
        Сервер = URL;
    Иначе
        Адрес  = Прав(URL, СтрДлина(URL) - СтрНайти(URL, "/", НаправлениеПоиска.СНачала) + 1);
        Сервер = Лев(URL, СтрНайти(URL, "/", НаправлениеПоиска.СНачала) - 1);
    КонецЕсли;

    Если ЭтоOneScript() И ЗащищенноеСоединение Тогда
        Сервер = "https://" + Сервер;
    КонецЕсли;

    СтруктураВозврата = Новый Структура;
    СтруктураВозврата.Вставить("Сервер"    , Сервер);
    СтруктураВозврата.Вставить("Адрес"     , Адрес);
    СтруктураВозврата.Вставить("Защищенное", ЗащищенноеСоединение);

    Возврат СтруктураВозврата;

КонецФункции

Функция JsonВСтруктуру(Знач Текст) Экспорт

    Если Не ЗначениеЗаполнено(Текст) Тогда
        Возврат "";
    КонецЕсли;

    Текст = ?(ТипЗнч(Текст) = Тип("ДвоичныеДанные"), ПолучитьСтрокуИзДвоичныхДанных(Текст), Текст);

    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(Текст);

    Данные = ПрочитатьJSON(ЧтениеJSON, Истина, Неопределено, ФорматДатыJSON.ISO);
    ЧтениеJSON.Закрыть();

    Возврат Данные;

КонецФункции

Функция JSONСтрокой(Знач Данные, Знач Экранирование = "Нет", Знач ПереносСтрок = Истина, Знач ДвойныеКавычки = Истина) Экспорт

    Перенос = ?(ПереносСтрок, ПереносСтрокJSON.Windows, ПереносСтрокJSON.Нет);

    ПараметрыJSON = Новый ПараметрыЗаписиJSON(Перенос, " ", ДвойныеКавычки, ЭкранированиеСимволовJSON[Экранирование],
        Ложь, Ложь, Ложь, Ложь);

    Попытка

        ЗаписьJSON = Новый ЗаписьJSON;
        ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);

        ЗаписатьJSON(ЗаписьJSON, Данные);
        Возврат ЗаписьJSON.Закрыть();

    Исключение
        Возврат "НЕ JSON: " + Строка(Данные);
    КонецПопытки;

КонецФункции

Функция ЧислоВСтроку(Знач Число) Экспорт
    Возврат СтрЗаменить(Строка(Число), Символы.НПП, "");
КонецФункции

Функция ПрочитатьJSONФайл(Знач Путь) Экспорт

    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.ОткрытьФайл(Путь);
    Значения   = ПрочитатьJSON(ЧтениеJSON);

    ЧтениеJSON.Закрыть();

    Возврат Значения;

КонецФункции

Функция ПараметрыЗапросаВСоответствие(Знач СтрокаПараметров) Экспорт

    СоответствиеВозврата = Новый Соответствие;
    КоличествоЧастей     = 2;
    МассивПараметров     = СтрРазделить(СтрокаПараметров, "&", Ложь);

    Для Каждого Параметр Из МассивПараметров Цикл

        МассивКлючЗначение = СтрРазделить(Параметр, "=");

        Если МассивКлючЗначение.Количество() = КоличествоЧастей Тогда
            СоответствиеВозврата.Вставить(МассивКлючЗначение[0], МассивКлючЗначение[1]);
        Иначе
            СоответствиеВозврата.Вставить(МассивКлючЗначение[0], Неопределено);
        КонецЕсли;

    КонецЦикла;

    Возврат СоответствиеВозврата;

КонецФункции

Функция ПолучитьТекущуюДату() Экспорт
    Возврат МестноеВремя(ТекущаяУниверсальнаяДата());
КонецФункции

Функция UNIXTime(Знач Дата) Экспорт

    ОТД  = Новый ОписаниеТипов("Дата");
    Дата = ОТД.ПривестиЗначение(Дата);

    UNIX = Формат(Дата - Дата(1970, 1, 1, 1, 0, 0), "ЧЦ=10; ЧДЦ=0; ЧГ=0");
    UNIX = СтрЗаменить(UNIX, ","        , "");
    UNIX = СтрЗаменить(UNIX, Символы.НПП, "");
    UNIX = СтрЗаменить(UNIX, " "        , "");
    UNIX = Лев(UNIX, 10);

    Возврат UNIX;

КонецФункции

Функция ИнформацияОПрогрессе(Знач Текущее, Знач Всего, Знач ЕдИзм, Знач Делитель = 1) Экспорт

    Целое   = 100;
    Текущее = Окр(Текущее / Делитель, 2);
    Всего   = Окр(Всего / Делитель, 2);
    Процент = Цел(Текущее / Всего * Целое);

    СтрТекущее = ЧислоВСтроку(Текущее);
    СтрВсего   = ЧислоВСтроку(Всего);
    СтрПроцент = ЧислоВСтроку(Процент);

    Информация = СтрТекущее + "/" + СтрВсего + " " + ЕдИзм + " ( " + СтрПроцент + "% )";

    Возврат Информация;

КонецФункции

Функция ПреобразоватьДанныеСПолучениемРазмера(Данные, Знач МинимальныйРазмерДляПотока = 0) Экспорт

    Размер = 0;

    Если ТипЗнч(Данные) = Тип("Строка") Тогда

        ФайлНаДиске = Новый Файл(Данные);

        Если ФайлНаДиске.Существует() Тогда
            Размер = ФайлНаДиске.Размер();
        Иначе
            OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные);
            Размер = Данные.Размер();
        КонецЕсли;

    Иначе
        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные);
        Размер = Данные.Размер();
    КонецЕсли;

    Если ЗначениеЗаполнено(МинимальныйРазмерДляПотока) Тогда
        Если Размер < МинимальныйРазмерДляПотока Тогда
            OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные);
        Иначе
            OPI_ПреобразованиеТипов.ПолучитьДвоичныеИлиПоток(Данные);
        КонецЕсли;
    Иначе
        OPI_ПреобразованиеТипов.ПолучитьДвоичныеИлиПоток(Данные);
    КонецЕсли;

    Возврат Размер;

КонецФункции

Функция ПолеКоллекцииСуществует(Знач Коллекция, Знач Поле) Экспорт

    ТипКоллекции = ТипЗнч(Коллекция);

    ЭтоСтруктура    = ТипКоллекции = Тип("Структура");
    ЭтоСоответствие = ТипКоллекции = Тип("Соответствие");
    ЭтоКоллекция    = ЭтоСтруктура Или ЭтоСоответствие;

    Если СтрНайти(Поле, ".") И ЭтоКоллекция Тогда

        ЧастиПоля   = СтрРазделить(Поле, ".");
        ТекущееПоле = ЧастиПоля[0];

        Если Не ПолеКоллекцииСуществует(Коллекция, ТекущееПоле) Тогда

            Возврат Ложь;

        Иначе

            ЧастиПоля.Удалить(0);
            СледующаяКоллекция = Коллекция[ТекущееПоле];
            СледующееПоле      = СтрСоединить(ЧастиПоля, ".");

            Возврат ПолеКоллекцииСуществует(СледующаяКоллекция, СледующееПоле);

        КонецЕсли;

    ИначеЕсли ЭтоСтруктура Тогда

        Возврат Коллекция.Свойство(Поле);

    ИначеЕсли ЭтоСоответствие Тогда

        Возврат Коллекция[Поле] <> Неопределено;

    Иначе

        Возврат Ложь;

    КонецЕсли;

КонецФункции

Функция НайтиОтсутствующиеПоляКоллекции(Знач Коллекция, Знач Поля) Экспорт

    МассивОтсутствующихПолей = Новый Массив;

    Для Каждого ЭлементКоллекции Из Коллекция Цикл

        ТекущийКлюч = ЭлементКоллекции.Ключ;
        Существует  = ПолеКоллекцииСуществует(Коллекция, ТекущийКлюч);

        Если Не Существует Тогда
            МассивОтсутствующихПолей.Добавить(ТекущийКлюч);
        КонецЕсли;

    КонецЦикла;

    Возврат МассивОтсутствующихПолей;

КонецФункции

Функция ОчиститьКоллекциюРекурсивно(Знач Коллекция) Экспорт

    ТипЗначения  = ТипЗнч(Коллекция);

    Если ТипЗначения = Тип("Структура") Тогда

        Для Каждого ЭлементКоллекции Из Коллекция Цикл

            ОчищенноеПоле = ОчиститьКоллекциюРекурсивно(ЭлементКоллекции.Значение);

            Коллекция[ЭлементКоллекции.Ключ] = ОчищенноеПоле;

        КонецЦикла;

    ИначеЕсли ТипЗначения = Тип("Соответствие") Тогда

        Коллекция_ = Новый Соответствие;

        Для Каждого ЭлементКоллекции Из Коллекция Цикл

            ОчищенноеПоле = ОчиститьКоллекциюРекурсивно(ЭлементКоллекции.Значение);

            Коллекция_.Вставить(ЭлементКоллекции.Ключ, ОчищенноеПоле);

        КонецЦикла;

        Коллекция = Коллекция_;

    ИначеЕсли ТипЗначения = Тип("Массив") Тогда

        Коллекция_ = Новый Массив;

        Для Каждого ЭлементКоллекции Из Коллекция Цикл

            ОчищенноеПоле = ОчиститьКоллекциюРекурсивно(ЭлементКоллекции);
            Коллекция_.Добавить(ОчищенноеПоле);

        КонецЦикла;

        Коллекция = Коллекция_;

    Иначе

        Коллекция = "";

    КонецЕсли;

    Возврат Коллекция;

КонецФункции

Функция ВременнаяМеткаISO(Знач Дата) Экспорт

    Метка = Лев(XMLСтрока(Дата), 19) + "Z";
    Метка = СтрЗаменить(Метка, "-", "");
    Метка = СтрЗаменить(Метка, ":", "");

    Возврат Метка;

КонецФункции

Функция ЭтоOneScript() Экспорт

    Попытка

        Ответ    = Ложь;

        // BSLLS:UnusedLocalVariable-off

        //@skip-check module-unused-local-variable
        Проверка = Новый ЗащищенноеСоединениеOpenSSL;

        // BSLLS:UnusedLocalVariable-on

    Исключение

        Ответ = Истина;

    КонецПопытки;

    Возврат Ответ;

КонецФункции

Функция ОбработатьXML(XML) Экспорт

    НачалоОбработкиXML(XML);

    ВозвращаемоеЗначение = Новый Соответствие;

    Пока XML.Прочитать() Цикл

        ТипУзла = XML.ТипУзла;

        Если Не ПодходящийТипУзла(ТипУзла) Тогда
            Продолжить;
        КонецЕсли;

        ИмяУзла = XML.Имя;

        СуществующееЗначение = ВозвращаемоеЗначение.Получить(ИмяУзла);

        Если ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда

            Если СуществующееЗначение = Неопределено Тогда
                ВозвращаемоеЗначение.Вставить(ИмяУзла, ОбработатьXML(XML));
            Иначе
                ЗначениеВМассив(СуществующееЗначение);
                СуществующееЗначение.Добавить(ОбработатьXML(XML));
                ВозвращаемоеЗначение.Вставить(ИмяУзла, СуществующееЗначение);
            КонецЕсли;

        Иначе

            Если Не ТипУзла       = ТипУзлаXML.КонецЭлемента Тогда
                ВозвращаемоеЗначение = XML.Значение;
                XML.Прочитать();
            КонецЕсли;

            Прервать;

        КонецЕсли;

    КонецЦикла;

    Возврат ВозвращаемоеЗначение;

КонецФункции

Функция ПолучитьXML(Значение, ПространствоИмен = "", ЗаписьXML = Неопределено) Экспорт

    ЭтоВход   = НачалоФормированияXML(Значение, ЗаписьXML);

    ТипЗначения = ТипЗнч(Значение);

    Если ТипЗначения = Тип("Структура") Или ТипЗначения = Тип("Соответствие") Тогда

        Для Каждого ЗначениеКоллекции Из Значение Цикл

            ЗаписьXML.ЗаписатьНачалоЭлемента(ЗначениеКоллекции.Ключ, ПространствоИмен);

            Если ЗначениеЗаполнено(ПространствоИмен) Тогда
                ЗаписьXML.ЗаписатьСоответствиеПространстваИмен("", ПространствоИмен);
            КонецЕсли;

            ПолучитьXML(ЗначениеКоллекции.Значение, "", ЗаписьXML);
            ЗаписьXML.ЗаписатьКонецЭлемента();

        КонецЦикла;

    ИначеЕсли ТипЗначения = Тип("Массив") Тогда

        Для Каждого ЭлементМассива Из Значение Цикл
            ПолучитьXML(ЭлементМассива, "", ЗаписьXML);
        КонецЦикла;

    Иначе

        ЗаписьXML.ЗаписатьТекст(Значение);

    КонецЕсли;

    Если ЭтоВход Тогда
        Возврат ЗаписьXML.Закрыть();
    Иначе
        Возврат Неопределено;
    КонецЕсли;

КонецФункции

Функция ПодходящийТипУзла(Знач ТипУзла)

    Возврат ТипУзла = ТипУзлаXML.НачалоЭлемента Или ТипУзла = ТипУзлаXML.КонецЭлемента Или ТипУзла = ТипУзлаXML.Текст;

КонецФункции

Процедура ЗначениеВМассив(Значение) Экспорт

    Если ТипЗнч(Значение) = Тип("Массив") Тогда
        Возврат;
    КонецЕсли;

    Значение_ = Новый Массив;
    Значение_.Добавить(Значение);
    Значение  = Значение_;

КонецПроцедуры

Процедура ЗаменитьСпецСимволы(Текст, Разметка = "Markdown") Экспорт

    СоответствиеСимволов = Новый Соответствие;

    Если Разметка = "HTML" Тогда

        СоответствиеСимволов.Вставить("&", "&amp;");

    ИначеЕсли Разметка = "MarkdownV2" Тогда

        СоответствиеСимволов.Вставить("-", "\-");
        СоответствиеСимволов.Вставить("+", "\+");
        СоответствиеСимволов.Вставить("#", "\#");
        СоответствиеСимволов.Вставить("=", "\=");
        СоответствиеСимволов.Вставить("{", "\{");
        СоответствиеСимволов.Вставить("}", "\}");
        СоответствиеСимволов.Вставить(".", "\.");

    Иначе
        Возврат;
    КонецЕсли;

    Для Каждого СимволМассива Из СоответствиеСимволов Цикл
        Текст = СтрЗаменить(Текст, СимволМассива.Ключ, СимволМассива.Значение);
    КонецЦикла;

КонецПроцедуры

Процедура УдалитьПустыеПоляКоллекции(Коллекция) Экспорт

    ТипКоллекции        = ТипЗнч(Коллекция);
    ВыходнаяКоллекция   = Новый (ТипКоллекции);

    Если ТипКоллекции = Тип("Соответствие") Или ТипКоллекции = Тип("Структура") Тогда

        УдалитьПустыеКлючиЗначения(Коллекция, ВыходнаяКоллекция);

    ИначеЕсли ТипКоллекции = Тип("Массив") Тогда

        УдалитьПустыеЭлементыМассива(Коллекция, ВыходнаяКоллекция);

    Иначе

        ВыходнаяКоллекция = Коллекция;

    КонецЕсли;

    Коллекция = ВыходнаяКоллекция;

КонецПроцедуры

Процедура Пауза(Знач Секунды) Экспорт

    Соединение = Новый HTTPСоединение("1C.ru", 11111, , , , Секунды);
    Попытка
        Соединение.Получить(Новый HTTPЗапрос(""));
    Исключение
        Возврат;
    КонецПопытки;

КонецПроцедуры

Процедура ДобавитьПоле(Знач Имя, Знач Значение, Знач Тип, Коллекция) Экспорт

    Заполнено = ЗначениеЗаполнено(Значение);

    Если Не Заполнено Тогда
        Возврат;
    КонецЕсли;

    Если Тип  = "Дата" Тогда
        OPI_ПреобразованиеТипов.ПолучитьДату(Значение);
        Значение = UNIXTime(Значение);

    ИначеЕсли Тип = "ДатаISO" Тогда
        OPI_ПреобразованиеТипов.ПолучитьДату(Значение);
        Значение     = Лев(XMLСтрока(Значение), 19);

    ИначеЕсли Тип = "ДатаISOZ" Тогда
        OPI_ПреобразованиеТипов.ПолучитьДату(Значение);
        Значение     = Лев(XMLСтрока(Значение), 19) + "Z";

    ИначеЕсли Тип = "ДатаБезВремени" Тогда
        OPI_ПреобразованиеТипов.ПолучитьДату(Значение);
        Значение = Формат(Значение, "ДФ=yyyy-MM-dd");

    ИначеЕсли Тип = "Коллекция" Тогда
        OPI_ПреобразованиеТипов.ПолучитьКоллекцию(Значение);

    ИначеЕсли Тип = "Булево" Тогда
        OPI_ПреобразованиеТипов.ПолучитьБулево(Значение);

    ИначеЕсли Тип = "СтрокаФайла" Тогда
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение, Истина);

    ИначеЕсли Тип = "Массив" Тогда
        OPI_ПреобразованиеТипов.ПолучитьМассив(Значение);

    ИначеЕсли Тип = "ДвоичныеДанные" Тогда
        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Значение);

    ИначеЕсли Тип = "Число" Тогда
        OPI_ПреобразованиеТипов.ПолучитьЧисло(Значение);

    ИначеЕсли Тип = "УникальныйИдентификатор" Тогда

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
        Значение = Новый УникальныйИдентификатор(Значение);

    Иначе

        Если Не Тип = "Текущий" Тогда
            OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
        КонецЕсли;

    КонецЕсли;

    Коллекция.Вставить(Имя, Значение);

КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ВыполнитьЗапросСТелом(Знач URL, Знач Вид, Знач Параметры = "", Знач ДопЗаголовки = "", Знач JSON = Истина,
    Знач ПолныйОтвет = Ложь, Знач ФайлОтвета = Неопределено)

    Если Не ЗначениеЗаполнено(Параметры) Тогда
        Параметры = Новый Структура;
    КонецЕсли;

    СтруктураURL  = РазбитьURL(URL);
    Сервер        = СтруктураURL["Сервер"];
    Адрес         = СтруктураURL["Адрес"];
    Защищенное    = СтруктураURL["Защищенное"];

    Запрос        = СоздатьЗапросСТелом(Адрес, Параметры, ДопЗаголовки, JSON);
    Соединение    = СоздатьСоединение(Сервер, Защищенное);
    Ответ         = ВыполнитьЗапрос(Запрос, Соединение, Вид, ФайлОтвета, ПолныйОтвет);

    Возврат Ответ;

КонецФункции

Функция ВыполнитьЗапросСДвоичнымиДанными(Знач URL, Знач Вид, Знач Данные, Знач ДопЗаголовки, Знач ПолныйОтвет,
    Знач ТипДанных)

    СтруктураURL  = РазбитьURL(URL);
    Сервер        = СтруктураURL["Сервер"];
    Адрес         = СтруктураURL["Адрес"];
    Защищенное    = СтруктураURL["Защищенное"];

    Запрос        = СоздатьЗапрос(Адрес, ДопЗаголовки, ТипДанных);
    Соединение    = СоздатьСоединение(Сервер, Защищенное);

    Если Не Данные.Размер() = 0 Тогда
        Запрос.УстановитьТелоИзДвоичныхДанных(Данные);
    КонецЕсли;

    Ответ = ВыполнитьЗапрос(Запрос, Соединение, Вид, , ПолныйОтвет);

    Возврат Ответ;

КонецФункции

Функция ВыполнитьЗапросБезТела(Знач URL, Знач Вид, Знач Параметры = "", Знач ДопЗаголовки = "",
    Знач ФайлОтвета = Неопределено)

    Если Не ЗначениеЗаполнено(Параметры) Тогда
        Параметры = Новый Структура;
    КонецЕсли;

    СтруктураURL  = РазбитьURL(URL);
    Сервер        = СтруктураURL["Сервер"];
    Адрес         = СтруктураURL["Адрес"] + ПараметрыЗапросаВСтроку(Параметры);
    Защищенное    = СтруктураURL["Защищенное"];

    Запрос     = СоздатьЗапрос(Адрес, ДопЗаголовки);
    Соединение = СоздатьСоединение(Сервер, Защищенное);

    Ответ      = ВыполнитьЗапрос(Запрос, Соединение, Вид, ФайлОтвета);

    Возврат Ответ;

КонецФункции

Функция ВыполнитьЗапросМультипарт(Знач URL, Знач Вид, Знач Параметры = "", Знач Файлы = "",
    Знач ТипКонтента = "image/jpeg", Знач ДопЗаголовки = "", Знач ФайлОтвета = Неопределено)

    Если Не ЗначениеЗаполнено(Параметры) Тогда
        Параметры = Новый Структура;
    КонецЕсли;

    Если Не ЗначениеЗаполнено(Файлы) Тогда
        Файлы = Новый Соответствие;
    КонецЕсли;

    СтруктураURL     = РазбитьURL(URL);
    Сервер           = СтруктураURL["Сервер"];
    Адрес            = СтруктураURL["Адрес"];
    Защищенное       = СтруктураURL["Защищенное"];

    ТелоЗапроса      = ПолучитьИмяВременногоФайла();

    Запрос     = СоздатьЗапросМультипарт(Адрес, Параметры, Файлы, ДопЗаголовки, ТелоЗапроса, ТипКонтента);
    Соединение = СоздатьСоединение(Сервер, Защищенное);
    Ответ      = ВыполнитьЗапрос(Запрос, Соединение, Вид, ФайлОтвета);

    Запрос       = Неопределено;
    ЗаписьТекста = Неопределено;

    УдалитьФайлы(ТелоЗапроса);
    Возврат Ответ;

КонецФункции

Функция ВыполнитьЗапросМультипартРелэйтед(Знач URL, Знач Вид, Знач JSON = "", Знач Файлы = "", Знач ДопЗаголовки = "",
    Знач ФайлОтвета = Неопределено)

    СтруктураURL = РазбитьURL(URL);
    Сервер       = СтруктураURL["Сервер"];
    Адрес        = СтруктураURL["Адрес"];
    Защищенное   = СтруктураURL["Защищенное"];

    ТелоЗапроса  = ПолучитьИмяВременногоФайла();

    Запрос       = СоздатьЗапросМультипартРелэйтед(Адрес, Файлы, JSON, ДопЗаголовки, ТелоЗапроса);
    Соединение   = СоздатьСоединение(Сервер, Защищенное);

    Ответ = ВыполнитьЗапрос(Запрос, Соединение, Вид, ФайлОтвета);

    Запрос       = Неопределено;
    ЗаписьТекста = Неопределено;

    УдалитьФайлы(ТелоЗапроса);
    Возврат Ответ;

КонецФункции

Функция ЭтоПереадресация(Знач Ответ)

    Переадресация  = 300;
    Ошибка         = 400;

    ЭтоПереадресация = Ответ.КодСостояния >= Переадресация И Ответ.КодСостояния < Ошибка И ЗначениеЗаполнено(
        Ответ.Заголовки["Location"]);

    Возврат ЭтоПереадресация;

КонецФункции

Функция ПреобразоватьПараметрВСтроку(Знач Значение)

    Если ТипЗнч(Значение) = Тип("Массив") Тогда

        Для Н        = 0 По Значение.ВГраница() Цикл
            Значение[Н] = ПреобразоватьПараметрВСтроку(Значение[Н]);
        КонецЦикла;

        Значение = СтрСоединить(Значение, ",");
        Значение = КодироватьСтроку(Значение, СпособКодированияСтроки.URLВКодировкеURL);
        Значение = "[" + Значение + "]";

    ИначеЕсли ТипЗнч(Значение) = Тип("Соответствие") Или ТипЗнч(Значение) = Тип("Структура") Тогда

        ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет, "");

        ЗаписьJSON = Новый ЗаписьJSON;
        ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);

        ЗаписатьJSON(ЗаписьJSON, Значение);
        Значение = ЗаписьJSON.Закрыть();

    ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда

        Значение = ?(Значение, "true", "false");

    Иначе

        Значение = ЧислоВСтроку(Значение);
        Значение = КодироватьСтроку(Значение, СпособКодированияСтроки.URLВКодировкеURL);

    КонецЕсли;

    Возврат Значение;

КонецФункции

Функция РазобратьКлючФайла(Знач ДанныеФайла, Знач ТипКонтента)

    ЗаменаТочки = "___";
    ИмяФайла    = СтрЗаменить(ДанныеФайла, ЗаменаТочки, ".");
    МассивИмени = СтрРазделить(ИмяФайла, "|", Ложь);
    ЧастейИмени = 2;

    Если МассивИмени.Количество() = ЧастейИмени Тогда
        ИмяПоля  = МассивИмени[0];
        ИмяФайла = МассивИмени[1];
    Иначе

        Если ТипКонтента = "image/jpeg" Тогда

            ИмяПоля = "photo";

        Иначе

            ИмяПоля = Лев(ИмяФайла, СтрНайти(ИмяФайла, ".") - 1);
            ИмяПоля = ?(ЗначениеЗаполнено(ИмяПоля), ИмяПоля, СтрЗаменить(ДанныеФайла, ЗаменаТочки, "."));

        КонецЕсли;

    КонецЕсли;

    СтруктураВозврата = Новый Структура("ИмяПоля,ИмяФайла", ИмяПоля, ИмяФайла);

    Возврат СтруктураВозврата;

КонецФункции

Функция РазделитьМассивНаПараметрыURL(Знач Ключ, Знач Значение)

    КлючМассив = Ключ + "=";

    Для Н = 0 По Значение.ВГраница() Цикл

        ТекущееЗначение = Значение[Н];

        OPI_ПреобразованиеТипов.ПолучитьСтроку(ТекущееЗначение);

        Значение.Установить(Н, КлючМассив + ТекущееЗначение);

    КонецЦикла;

    ПараметрСтрокой = СтрСоединить(Значение, "&");

    Возврат ПараметрСтрокой;

КонецФункции

Процедура УстановитьТелоЗапроса(Запрос, Знач Параметры, Знач JSON)

    Коллекция = ТипЗнч(Параметры) = Тип("Структура") Или ТипЗнч(Параметры) = Тип("Соответствие") Или ТипЗнч(Параметры)
                 = Тип("Массив");

    Если JSON Тогда

        Данные = JSONСтрокой(Параметры);

    ИначеЕсли Не Коллекция Тогда

        Данные = Параметры;

    Иначе

        СтрокаПараметров = ПараметрыЗапросаВСтроку(Параметры);
        Данные           = Прав(СтрокаПараметров, СтрДлина(СтрокаПараметров) - 1);

    КонецЕсли;

    Если ТипЗнч(Данные) = Тип("Строка") Тогда
        Запрос.УстановитьТелоИзСтроки(Данные);
    Иначе
        //@skip-check wrong-type-expression
        Запрос.УстановитьТелоИзДвоичныхДанных(Данные);
    КонецЕсли;

КонецПроцедуры

Процедура ЗаписатьПараметрыМультипарт(ЗаписьТекста, Знач Boundary, Знач Параметры)

    РазделительСтрок = Символы.ВК + Символы.ПС;

    Для Каждого Параметр Из Параметры Цикл

        Если Параметр.Значение = Неопределено Или Параметр.Значение = Null Тогда
            Продолжить;
        КонецЕсли;

        ЗаписьТекста.ЗаписатьСтроку("--" + boundary + РазделительСтрок);
        ЗаписьТекста.ЗаписатьСтроку("Content-Disposition: form-data; name=""" + Параметр.Ключ + """");
        ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);
        ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);

        Если ТипЗнч(Параметр.Значение) = Тип("Строка") Или ТипЗнч(Параметр.Значение) = Тип("Число") Тогда

            ЗначениеСтрокой = ЧислоВСтроку(Параметр.Значение);
            ЗаписьТекста.ЗаписатьСтроку(ЗначениеСтрокой);

        ИначеЕсли ТипЗнч(Параметр.Значение) = Тип("Булево") Тогда

            ЗаписьТекста.ЗаписатьСтроку(?(Параметр.Значение, "true", "false"));

        Иначе

            ЗаписьТекста.Записать(Параметр.Значение);

        КонецЕсли;

        ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);

    КонецЦикла;

КонецПроцедуры

Процедура ЗаписатьФайлыМультипарт(ЗаписьТекста, Знач Boundary, Знач ТипКонтента, Знач Файлы)

    ТипКонтента      = СокрЛП(ТипКонтента);
    РазделительСтрок = Символы.ВК + Символы.ПС;

    Для Каждого Файл Из Файлы Цикл

        СтруктураИнформации = РазобратьКлючФайла(Файл.Ключ, ТипКонтента);

        ИмяПоля   = СтруктураИнформации["ИмяПоля"];
        ИмяФайла  = СтруктураИнформации["ИмяФайла"];

        ЗаписьТекста.ЗаписатьСтроку("--" + boundary + РазделительСтрок);
        ЗаписьТекста.ЗаписатьСтроку("Content-Disposition: form-data; name=""" + ИмяПоля + """; filename=""" + ИмяФайла
            + """");
        ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);

        Если ЗначениеЗаполнено(ТипКонтента) Тогда
            ЗаписьТекста.ЗаписатьСтроку("Content-Type: " + ТипКонтента);
        КонецЕсли;

        ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);
        ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);
        ЗаписатьДвоичныеДанные(ЗаписьТекста, Файл.Значение);
        ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);

    КонецЦикла;

КонецПроцедуры

Процедура ЗаписатьФайлыРелэйтед(ЗаписьТекста, Знач Boundary, Знач Файлы)

    Если Не ЗначениеЗаполнено(Файлы) Тогда
        Возврат;
    КонецЕсли;

    РазделительСтрок = Символы.ВК + Символы.ПС;

    Если ТипЗнч(Файлы) = Тип("Соответствие") Тогда
        Для Каждого Файл Из Файлы Цикл

            ЗаписьТекста.ЗаписатьСтроку("--" + boundary + РазделительСтрок);
            ЗаписьТекста.ЗаписатьСтроку("Content-Type: " + Файл.Значение);
            ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);
            ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);
            ЗаписатьДвоичныеДанные(ЗаписьТекста, Файл.Ключ);
            ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);
            ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);

        КонецЦикла;

    КонецЕсли;

КонецПроцедуры

Процедура ЗаписатьДвоичныеДанные(ЗаписьДанных, Знач ДвоичныеДанные)

    РазмерЧасти      = 268435456;
    ПрочитанноБайт   = 0;
    ТекущаяПозиция   = 0;
    ОбщийРазмер      = ДвоичныеДанные.Размер();

    Пока ПрочитанноБайт < ОбщийРазмер Цикл

        ЧтениеДанных     = Новый ЧтениеДанных(ДвоичныеДанные);
        ПрочитанноБайт   = ЧтениеДанных.Пропустить(ТекущаяПозиция);
        Результат        = ЧтениеДанных.Прочитать(РазмерЧасти);
        ТекущиеДанные    = Результат.ПолучитьДвоичныеДанные();
        РазмерТекущих    = ТекущиеДанные.Размер();

        Если Не ЗначениеЗаполнено(ТекущиеДанные) Тогда
            Прервать;
        КонецЕсли;

        ЗаписьДанных.Записать(ТекущиеДанные);

        ОсвободитьОбъект(ТекущиеДанные);
        ВыполнитьСборкуМусора();

        ТекущаяПозиция = ТекущаяПозиция + РазмерТекущих;

    КонецЦикла;

КонецПроцедуры

Процедура ЗаписатьJSONМультипарт(ЗаписьТекста, Знач Boundary, Знач JSON)

    Если Не ЗначениеЗаполнено(JSON) Тогда
        Возврат;
    КонецЕсли;

    РазделительСтрок = Символы.ВК + Символы.ПС;

    ЗаписьТекста.ЗаписатьСтроку("--" + boundary + РазделительСтрок);
    ЗаписьТекста.ЗаписатьСтроку("Content-Type: application/json; charset=UTF-8");
    ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);
    ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);
    ЗаписьТекста.ЗаписатьСтроку(JSON);
    ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);
    ЗаписьТекста.ЗаписатьСтроку(РазделительСтрок);

КонецПроцедуры

Процедура ДобавитьContentLength(Запрос)

    ТелоЗапроса = Запрос.ПолучитьТелоКакДвоичныеДанные();

    Если ЗначениеЗаполнено(ТелоЗапроса) Тогда

        Размер = ТелоЗапроса.Размер();
        Запрос.Заголовки.Вставить("Content-Length", ЧислоВСтроку(Размер));

    КонецЕсли;

КонецПроцедуры

Процедура УдалитьПустыеКлючиЗначения(Знач Коллекция, ВыходнаяКоллекция)

    Для Каждого ЭлементКоллекции Из Коллекция Цикл

        Если Не ЭлементКоллекции.Значение = Неопределено И Не ЭлементКоллекции.Значение = Null Тогда
            ВыходнаяКоллекция.Вставить(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
        КонецЕсли;

    КонецЦикла;

КонецПроцедуры

Процедура УдалитьПустыеЭлементыМассива(Знач Коллекция, ВыходнаяКоллекция)

    Для Каждого ЭлементКоллекции Из Коллекция Цикл

        Если Не ЭлементКоллекции = Неопределено И Не ЭлементКоллекции = Null Тогда
            ВыходнаяКоллекция.Добавить(ЭлементКоллекции);
        КонецЕсли;

    КонецЦикла;

КонецПроцедуры

Процедура НачалоОбработкиXML(XML)

    Если Не ТипЗнч(XML) = Тип("ЧтениеXML") Тогда
        XML_               = XML;
        XML                = Новый ЧтениеXML;
        XML.УстановитьСтроку(XML_);
    КонецЕсли;

КонецПроцедуры

Функция НачалоФормированияXML(Значение, ЗаписьXML)

    ЭтоВход = Ложь;

    Если ЗаписьXML = Неопределено Тогда

        ТекстОшибки = "Ошибка получения коллекции для формирования XML";
        OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Значение, ТекстОшибки);

        ЗаписьXML = Новый ЗаписьXML;
        ЗаписьXML.УстановитьСтроку();
        ЗаписьXML.ЗаписатьОбъявлениеXML();

        ЭтоВход = Истина;

    КонецЕсли;

    Возврат ЭтоВход;

КонецФункции

#Область GZip

// Описание структур см. здесь https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
// Источник: https://github.com/vbondarevsky/Connector

// Коннектор: удобный HTTP-клиент для 1С:Предприятие 8
//
// Copyright 2017-2023 Vladimir Bondarevskiy
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//
// URL:    https://github.com/vbondarevsky/Connector
// e-mail: vbondarevsky@gmail.com
// Версия: 2.4.8
//
// Требования: платформа 1С версии 8.3.10 и выше

Функция РаспаковатьОтвет(Ответ)

    Попытка
        Возврат ПрочитатьGZip(Ответ.ПолучитьТелоКакДвоичныеДанные());
    Исключение
        Возврат Ответ;
    КонецПопытки;

КонецФункции

Функция ПрочитатьGZip(СжатыеДанные) Экспорт

    РазмерПрефиксаGZip  = 10;
    РазмерПостфиксаGZip = 8;

    РазмерДД  = ZipРазмерDD();
    РазмерСДХ = ZipРазмерCDH();
    РазмерЕСД = ZipРазмерEOCD();
    РазмерЛФХ = ZipРазмерLFH();

    ЧтениеДанных       = Новый ЧтениеДанных(СжатыеДанные);
    ЧтениеДанных.Пропустить(РазмерПрефиксаGZip);
    РазмерСжатыхДанных = ЧтениеДанных.ИсходныйПоток().Размер() - РазмерПрефиксаGZip - РазмерПостфиксаGZip;

    ПотокZip     = Новый ПотокВПамяти(РазмерЛФХ + РазмерСжатыхДанных + РазмерДД + РазмерСДХ + РазмерЕСД);

    ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipLFH());
    ЧтениеДанных.КопироватьВ(ЗаписьДанных, РазмерСжатыхДанных);

    ЗаписьДанных.Закрыть();
    ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);

    CRC32 = ЧтениеДанных.ПрочитатьЦелое32();
    РазмерНесжатыхДанных = ЧтениеДанных.ПрочитатьЦелое32();
    ЧтениеДанных.Закрыть();

    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipDD(CRC32 , РазмерСжатыхДанных, РазмерНесжатыхДанных));
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipEOCD(РазмерСжатыхДанных));
    ЗаписьДанных.Закрыть();

    Возврат ПрочитатьZip(ПотокZip);

КонецФункции

Функция ПрочитатьZip(СжатыеДанные, ТекстОшибки = Неопределено)

    Каталог         = ПолучитьИмяВременногоФайла();
    ЧтениеZip       = Новый ЧтениеZipФайла(СжатыеДанные);
    ИмяФайла        = ЧтениеZip.Элементы[0].Имя;
    Попытка
        ЧтениеZip.Извлечь(ЧтениеZip.Элементы[0], Каталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
    Исключение
        // Игнорируем проверку целостности архива, просто читаем результат
        ТекстОшибки    = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
    КонецПопытки;
    ЧтениеZip.Закрыть();

    Результат = Новый ДвоичныеДанные(Каталог + ПолучитьРазделительПути() + ИмяФайла);
    УдалитьФайлы(Каталог);

    Возврат Результат;

КонецФункции

Функция ZipРазмерLFH()

    Возврат 34;

КонецФункции

Функция ZipРазмерDD()

    Возврат 16;

КонецФункции

Функция ZipРазмерCDH()

    Возврат 50;

КонецФункции

Функция ZipРазмерEOCD()

    Возврат 22;

КонецФункции

Функция ZipLFH()

    // Local file header
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерLFH());
    Буфер.ЗаписатьЦелое32(0, 67324752); // signature 0x04034b50
    Буфер.ЗаписатьЦелое16(4, 20);       // version
    Буфер.ЗаписатьЦелое16(6, 10);       // bit flags
    Буфер.ЗаписатьЦелое16(8, 8);        // compression method
    Буфер.ЗаписатьЦелое16(10, 0);       // time
    Буфер.ЗаписатьЦелое16(12, 0);       // date
    Буфер.ЗаписатьЦелое32(14, 0);       // crc-32
    Буфер.ЗаписатьЦелое32(18, 0);       // compressed size
    Буфер.ЗаписатьЦелое32(22, 0);       // uncompressed size
    Буфер.ЗаписатьЦелое16(26, 4);       // filename legth - "data"
    Буфер.ЗаписатьЦелое16(28, 0);       // extra field length
    Буфер.Записать(30, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));

    Возврат Буфер;

КонецФункции

Функция ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

    // Data descriptor
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерDD());
    Буфер.ЗаписатьЦелое32(0, 134695760);
    Буфер.ЗаписатьЦелое32(4, CRC32);
    Буфер.ЗаписатьЦелое32(8, РазмерСжатыхДанных);
    Буфер.ЗаписатьЦелое32(12, РазмерНесжатыхДанных);

    Возврат Буфер;

КонецФункции

Функция ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

    // Central directory header
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерCDH());
    Буфер.ЗаписатьЦелое32(0, 33639248);              // signature 0x02014b50
    Буфер.ЗаписатьЦелое16(4, 798);                   // version made by
    Буфер.ЗаписатьЦелое16(6, 20);                    // version needed to extract
    Буфер.ЗаписатьЦелое16(8, 10);                    // bit flags
    Буфер.ЗаписатьЦелое16(10, 8);                    // compression method
    Буфер.ЗаписатьЦелое16(12, 0);                    // time
    Буфер.ЗаписатьЦелое16(14, 0);                    // date
    Буфер.ЗаписатьЦелое32(16, CRC32);                // crc-32
    Буфер.ЗаписатьЦелое32(20, РазмерСжатыхДанных);   // compressed size
    Буфер.ЗаписатьЦелое32(24, РазмерНесжатыхДанных); // uncompressed size
    Буфер.ЗаписатьЦелое16(28, 4);                    // file name length
    Буфер.ЗаписатьЦелое16(30, 0);                    // extra field length
    Буфер.ЗаписатьЦелое16(32, 0);                    // file comment length
    Буфер.ЗаписатьЦелое16(34, 0);                    // disk number start
    Буфер.ЗаписатьЦелое16(36, 0);                    // internal file attributes
    Буфер.ЗаписатьЦелое32(38, 2176057344);           // external file attributes
    Буфер.ЗаписатьЦелое32(42, 0);                    // relative offset of local header
    Буфер.Записать(46, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));

    Возврат Буфер;

КонецФункции

Функция ZipEOCD(РазмерСжатыхДанных)

    // End of central directory
    РазмерCDH = 50;
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерEOCD());
    Буфер.ЗаписатьЦелое32(0, 101010256); // signature 0x06054b50
    Буфер.ЗаписатьЦелое16(4, 0); // number of this disk
    Буфер.ЗаписатьЦелое16(6, 0); // number of the disk with the start of the central directory
    Буфер.ЗаписатьЦелое16(8, 1); // total number of entries in the central directory on this disk
    Буфер.ЗаписатьЦелое16(10, 1); // total number of entries in the central directory
    Буфер.ЗаписатьЦелое32(12, РазмерCDH); // size of the central directory
    // offset of start of central directory with respect to the starting disk number
    Буфер.ЗаписатьЦелое32(16, ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD());
    Буфер.ЗаписатьЦелое16(20, 0); // the starting disk number

    Возврат Буфер;

КонецФункции

#КонецОбласти

#КонецОбласти
