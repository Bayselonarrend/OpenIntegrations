// OneScript: ./OInt/tools/Modules/internal/Classes/OPI_HTTPКлиент.os

// MIT License

// Copyright (c) 2023-2025 Anton Tsitavets

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// https://github.com/Bayselonarrend/OpenIntegrations

// BSLLS:Typo-off
// BSLLS:LatinAndCyrillicSymbolInWord-off
// BSLLS:IncorrectLineBreak-off
// BSLLS:NumberOfOptionalParams-off
// BSLLS:UsingServiceTag-off
// BSLLS:LineLength-off
// BSLLS:ExportVariables-off
// BSLLS:OneStatementPerLine-off

//@skip-check module-structure-top-region
//@skip-check module-structure-method-in-regions
//@skip-check wrong-string-literal-content
//@skip-check method-too-many-params
//@skip-check constructor-function-return-section
//@skip-check doc-comment-collection-item-type
//@skip-check object-module-export-variable

// #Если Не Клиент Тогда

#Область ОписаниеПеременных

// Обработка

Перем Инициализирован; // Признак, что обязательная функция Инициализировать() была вызвана
Перем Ошибка Экспорт;  // Признак ошибки выполнения для пропуска оставшихся действий в цепочке
Перем Лог;             // Массив сообщений о действиях внутри обработки

// Запрос

Перем Запрос;     // Объект HTTPЗапрос
Перем Соединение; // Объект HTTPСоединение
Перем Настройки;  // Структура дополнительных настроек

Перем ЗапросURL;          // URL запроса
Перем ЗапросСервер;       // Сервер из URL запроса
Перем ЗапросПорт;         // Порт из URL запроса или по умолчанию
Перем ЗапросАдрес;        // Путь из URL запроса
Перем ЗапросАдресПолный;  // Путь с параметрами и секцией из URL запроса
Перем ЗапросСекция;       // Секция в URL, если присутствует
Перем ЗапросЗащищенное;   // Признак использования HTTPS
Перем ЗапросДомен;        // Домен из URL запроса

Перем ЗапросМетод;                 // Используемый метод HTTP
Перем ЗапросПараметрыURL;          // Структура параметров URL
Перем ЗапросТело;                  // Данные тела запроса
Перем ЗапросЗаголовки;             // Соответствие заголовков запроса
Перем ЗапросПользователь;          // Пользователь для базовой авторизации
Перем ЗапросПароль;                // Пароль для базовой авторизации
Перем ЗапросТаймаут;               // Таймаут запроса
Перем ЗапросПрокси;                // Настройки прокси запроса
Перем ЗапросВыходнойФайл;          // Путь к файлу для сохранения результата запроса
Перем ЗапросФайлТела;              // Путь к файлу с телом запроса
Перем ЗапросПотокТела;             // Поток тела запроса
Перем ЗапросЗаписьДанных;          // Запись данных тела запроса
Перем ЗапросТипДанных;             // MIME тип для Content-Type
Перем ЗапросТипУстановленВручную;  // Признак отключения автоматического определения Content-Type
Перем ФайлТелаВременный;           // Признак удаления файла тела, если он был создан автоматически

// AWS

Перем AWS4Использовать;  // Признак использования AWS4 авторизации
Перем AWS4Данные;        // Структура учетных данных

// Ответ

Перем Ответ;             // Объект HTTPОтвет
Перем ОтветКодСостояния; // Код состояния ответа
Перем ОтветТело;         // Данные тела ответа
Перем ОтветЗаголовки;    // Соответствие заголовков ответа

// Multipart

Перем Multipart;        // Признак установки тела в формате Multipart
Перем Boundary;         // Boundary для разделения частей тела
Перем РазделительСтрок; // Разделитель строк тела

#КонецОбласти

#Область ПрограммныйИнтерфейс

#Область Инициализация

// Инициализировать !NOCLI
// Инициализирует новый пустой запрос
//
// Примечание:
// Функция обязательная для вызова первой при создании нового объекта обработки
//
// Параметры:
//  URL - Строка - URL адрес для запроса
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция Инициализировать(Знач URL = "") Экспорт

    Инициализирован = Истина;
    Ошибка          = Ложь;
    Лог             = Новый Массив;

    ЗапросПараметрыURL = Новый Массив;
    ЗапросТело         = Неопределено;
    ЗапросЗаголовки    = Новый Соответствие;
    ЗапросТаймаут      = 3600;

    ЗапросТипУстановленВручную = Ложь;

    ФайлТелаВременный = Ложь;
    AWS4Использовать  = Ложь;

    ОтветКодСостояния = 0;
    ОтветТело         = Неопределено;
    ОтветЗаголовки    = Новый Соответствие;

    Multipart = Ложь;

    УстановитьСтандартныеНастройки();
    УстановитьURL(URL);

    Возврат ЭтотОбъект;

КонецФункции

// Установить URL !NOCLI
// Устанавливает новый URL запроса
//
// Параметры:
//  URL - Строка -  URL запроса - url
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьURL(Знач URL) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Если ЗначениеЗаполнено(URL) Тогда

            OPI_ПреобразованиеТипов.ПолучитьСтроку(URL);
            OPI_Инструменты.ВернутьУправляющиеПоследовательности(URL);

            Если ПолучитьНастройку("КодировкаURL") Тогда
                КодироватьURLВURL(URL);
            КонецЕсли;

            ЗапросURL = URL;

            ДобавитьЛог("УстановитьURL: Разбиение запроса на составные части");

        Иначе

            ДобавитьЛог("УстановитьURL: URL пуст - пропуск");

        КонецЕсли;

        Возврат РазбитьURL();

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить параметры URL !NOCLI
// Устанавливает коллекцию параметров URL
//
// Параметры:
//  Значение - Произвольный - Стрктура или соответствие параметров URL - params
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьПараметрыURL(Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не ЗначениеЗаполнено(Значение) Тогда Значение = Новый Структура; КонецЕсли;

        ТекстОшибки        = "УстановитьПараметрыURL: Переданные параметры не являются коллекцией ключ/значение";
        OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Значение, ТекстОшибки);
        ЗапросПараметрыURL = Значение;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить файл ответа !NOCLI
// Устанавливает путь к файлу для сохранения результата запроса
//
// Параметры:
//  Значение - Строка - Путь к файлу - filepath
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьФайлОтвета(Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не ЗначениеЗаполнено(Значение) Тогда
            ЗапросВыходнойФайл = Неопределено;
            Возврат ЭтотОбъект;
        КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
        ЗапросВыходнойФайл = Значение;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить тип данных !NOCLI
// Устанавливает Content-Type запроса
//
// Примечание:
// Если тип данных не установлен вручную, то он будет подобран в процессе установки тела запроса
//
// Параметры:
//  Значение - Строка - Значение заголовка ContentType - type
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьТипДанных(Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("УстановитьТипДанных: Установка значения");
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);

        ЗапросТипДанных            = Значение;
        ЗапросТипУстановленВручную = Истина;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Получить лог !NOCLI
// Получает лог выполнения
//
// Параметры:
//  Строкой - Булево - Возврат лога в виде строки - string
//
// Возвращаемое значение:
//  Строка, Массив - Лог выполнения
Функция ПолучитьЛог(Знач Строкой = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Строкой);

    Если Не ЗначениеЗаполнено(Лог) Тогда
        Возврат ?(Строкой, ""              , Новый Массив);
    Иначе
        Возврат ?(Строкой, СтрСоединить(Лог, Символы.ПС), Лог);
    КонецЕсли;

КонецФункции

#КонецОбласти

#Область Настройки

// Использовать кодировку !NOCLI
// Устанавливает кодировку тела запроса
//
// Примечание:
// По умолчанию используется UTF-8
//
// Параметры:
//  Кодировка - Строка - Название кодировки - enc
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ИспользоватьКодировку(Знач Кодировка) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("ИспользоватьКодировку: Установка значения");
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Кодировка);

        УстановитьНастройку("КодировкаТелаЗапроса", Кодировка);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Использовать сжатие gzip !NOCLI
// Включает или отключает заголовок получения данных от сервера в сжатом виде
//
// Примечание:
// По умлчанию ответ от сервера запрашивается со сжатием gzip
//
// Параметры:
//  Флаг - Булево - Признак использования gzip - gzip
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ИспользоватьСжатиеGzip(Знач Флаг) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("ИспользоватьСжатиеGzip: Установка значения");
        OPI_ПреобразованиеТипов.ПолучитьБулево(Флаг);

        УстановитьНастройку("gzip", Флаг);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

#КонецОбласти

#Область УстановкаТела

// Установить двоичное тело !NOCLI
// Устанавливает тело запрос из двоичных данных, файла или строки (с преобразованием в двоичные данные)
//
// Параметры:
//  Данные              - Строка, ДвоичныеДанные - Файл, строка или данные тела запроса               - data
//  УстанавливатьПустое - Булево                 - Устанавливает тело даже при передаче пустых данных - empty
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьДвоичноеТело(Знач Данные, Знач УстанавливатьПустое = Ложь) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ОтменитьЗаписьMultipart();

        Если Не ЗапросТипУстановленВручную Тогда
            ЗапросТипДанных = "application/octet-stream";
        КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные, Истина, Ложь);
        OPI_ПреобразованиеТипов.ПолучитьБулево(УстанавливатьПустое);

        Данные     = ?(Данные = Неопределено, ПолучитьДвоичныеДанныеИзСтроки(""), Данные);
        ЕстьДанные = Данные.Размер() > 0;

        Если ЕстьДанные Или УстанавливатьПустое Тогда

            Если Не ЕстьДанные Тогда
                Данные = ПолучитьДвоичныеДанныеИзСтроки("");
            КонецЕсли;

            ДобавитьЛог("УстановитьДвоичноеТело: Начало установки тела");
            УстановитьТелоИзДвоичныхДанных(Данные);
            ДобавитьЛог(СтрШаблон("УстановитьДвоичноеТело: Тело установлено, размер %1", ЗапросТело.Размер()));

        Иначе
            ДобавитьЛог("УстановитьДвоичноеТело: Передано пустое тело, пропуск");
        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить строковое тело !NOCLI
// Устанавливает тело запроса из строки в указанной кодировке
//
// Параметры:
//  Данные      - Строка - Данные тела запроса         - data
//  ЗаписатьBOM - Булево - Истина > BOM будет добавлен - bom
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьСтроковоеТело(Знач Данные, Знач ЗаписатьBOM = Ложь) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ОтменитьЗаписьMultipart();

        Если Не ЗначениеЗаполнено(Данные) Тогда
            ДобавитьЛог("УстановитьСтроковоеТело: Нет данных, пропуск");
            Возврат ЭтотОбъект;
        КонецЕсли;

        Кодировка = ПолучитьНастройку("КодировкаТелаЗапроса");

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Кодировка);

        Если Не ЗапросТипУстановленВручную Тогда
          ЗапросТипДанных  = СтрШаблон("text/plain; charset=%1", Кодировка);
        КонецЕсли;

        ДобавитьЛог("УстановитьСтроковоеТело: Начало установки тела");
        УстановитьТелоИзСтроки(Данные, ЗаписатьBOM);
        ДобавитьЛог(СтрШаблон("УстановитьСтроковоеТело: Тело установлено, размер %1", ЗапросТело.Размер()));

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить JSON тело !NOCLI
// Устанавливает тело в формате JSON из подходящей коллекции или строки
//
// Параметры:
//  Данные - Произвольный - Строка или коллекция для преобразования в JSON - data
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьJsonТело(Знач Данные) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ОтменитьЗаписьMultipart();

        Если Не ЗначениеЗаполнено(Данные) Тогда
            ДобавитьЛог("УстановитьJsonТело: Нет данных, пропуск");
            Возврат ЭтотОбъект;
        КонецЕсли;

        Если Не ЗапросТипУстановленВручную Тогда
          ЗапросТипДанных  = "application/json; charset=utf-8";
        КонецЕсли;

        ДобавитьЛог("УстановитьJsonТело: Начало установки тела");

        Если Не ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
            OPI_ПреобразованиеТипов.ПолучитьКоллекцию(Данные);
        КонецЕсли;

        УстановитьТелоИзСтроки(Данные);

        ДобавитьЛог(СтрШаблон("УстановитьJsonТело: Тело установлено, размер %1", ЗапросТело.Размер()));

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Установить Form тело !NOCLI
// Устанавливает тело в формате x-www-form-urlencoded из коллекции значений полей
//
// Параметры:
//  Данные - Произвольный - Коллекция КлючЗначение с параметрами формы - data
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Установить form тело
Функция УстановитьFormТело(Знач Данные) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        ОтменитьЗаписьMultipart();

        Если Не ЗначениеЗаполнено(Данные) Тогда
            ДобавитьЛог("УстановитьFormТело: Нет данных, пропуск");
            Возврат ЭтотОбъект;
        КонецЕсли;

        Если Не ЗапросТипУстановленВручную Тогда
          ЗапросТипДанных  = "application/x-www-form-urlencoded; charset=utf-8";
        КонецЕсли;

        ДобавитьЛог("УстановитьFormТело: Начало установки тела");

        OPI_ПреобразованиеТипов.ПолучитьКоллекцию(Данные);

        Если ТипЗнч(Данные) = Тип("Массив") Тогда

            Данные = Данные[0];

            Если Не ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
                OPI_ПреобразованиеТипов.ПолучитьСтроку(Данные);
            КонецЕсли;

        Иначе

            Данные = ПараметрыЗапросаВСтроку(Данные);

        КонецЕсли;

        УстановитьТелоИзСтроки(Данные);

        ДобавитьЛог(СтрШаблон("УстановитьFormТело: Тело установлено, размер %1", ЗапросТело.Размер()));

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Начать запись тела multipart !NOCLI
// Инициализирует запись данных в тело в формате multipart
//
// Примечание:
// Для дальнейшего формирования тела используются методы `ДобавитьФайлMultipart` и `ДобавитьПолеMultipart`
//
// Параметры:
//  ИспользоватьФайл - Булево - Истина > использовать временный файл, Ложь > формирует тело в памяти - file
//  Вид              - Строка - Вид multipart загрузки: form data, related                           - type
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция НачатьЗаписьТелаMultipart(ИспользоватьФайл = Истина, Знач Вид = "form-data") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьБулево(ИспользоватьФайл);
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Вид);

        Multipart        = Истина;
        Boundary         = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
        РазделительСтрок = Символы.ВК + Символы.ПС;
        Кодировка        = ПолучитьНастройку("КодировкаТелаЗапроса");
        ЗапросТипДанных  = СтрШаблон("multipart/%1; boundary=%2", Вид, Boundary);

        Если ИспользоватьФайл Тогда

            ДобавитьЛог("НачатьЗаписьТелаMultipart: Создание временного файла");

            // BSLLS:MissingTemporaryFileDeletion-off
            ЗапросФайлТела     = ПолучитьИмяВременногоФайла();
            // BSLLS:MissingTemporaryFileDeletion-on

            ФайлТелаВременный  = Истина;
            ЗапросЗаписьДанных = Новый ЗаписьДанных(ЗапросФайлТела
                , Кодировка
                , ПорядокБайтов.LittleEndian
                , ""
                , Ложь
                , ""
                , Ложь);

        Иначе

            ДобавитьЛог("НачатьЗаписьТелаMultipart: Создание потока в памяти");

            ЗапросПотокТела = Новый ПотокВПамяти();

            ЗапросЗаписьДанных = Новый ЗаписьДанных(ЗапросПотокТела
                , Кодировка
                , ПорядокБайтов.LittleEndian
                , ""
                , ""
                , Ложь);

        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить файл multipart !NOCLI
// Добавляет блок файла в multipart/form-data тело
//
// Примечание:
// Запись Multipart предварительно должна быть инициализирована при помощи функции `НачатьЗаписьТелаMultipart`
//
// Параметры:
//  ИмяПоля   - Строка                 - Имя поля формы               - field
//  ИмяФайла  - Строка                 - Имя файла с расширением      - filename
//  Данные    - ДвоичныеДанные, Строка - Данные файла для записи      - data
//  ТипДанных - Строка                 - Mime тип записываемых данных - mime
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьФайлMultipartFormData(Знач ИмяПоля, Знач ИмяФайла, Знач Данные, Знач ТипДанных = "") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не Multipart Тогда Возврат Ошибка("ДобавитьФайлMultipart: Не инициализирована запись Multipart"); КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные);

        ДобавитьЛог("ДобавитьФайлMultipart: Запись шапки блока");

        Шапка = СтрШаблон("Content-Disposition: form-data; name=""%1""; filename=""%2""", ИмяПоля, ИмяФайла);

        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + Boundary + РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(Шапка);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        Если ЗначениеЗаполнено(ТипДанных) Тогда
            ЗапросЗаписьДанных.ЗаписатьСтроку("Content-Type: " + ТипДанных);
        КонецЕсли;

        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        ДобавитьЛог("ДобавитьФайлMultipart: Запись данных");

        ЗаписатьДвоичныеДанные(ЗапросЗаписьДанных, Данные);

        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить поле multipart !NOCLI
// Добавляет поле формы в multipart/form-data тело
//
// Примечание:
// Запись Multipart предварительно должна быть инициализирована при помощи функции `НачатьЗаписьТелаMultipart`
//
// Параметры:
//  ИмяПоля   - Строка       - Имя поля формы     - field
//  Значение  - Произвольный - Значение поля      - data
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьПолеMultipartFormData(Знач ИмяПоля, Знач Значение) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не Multipart Тогда Возврат Ошибка("ДобавитьПолеMultipart: Не инициализирована запись Multipart"); КонецЕсли;

        ТипЗначения = ТипЗнч(Значение);

        ДобавитьЛог("ДобавитьПолеMultipart: Запись шапки блока");

        Шапка       = СтрШаблон("Content-Disposition: form-data; name=""%1""", ИмяПоля);

        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + boundary + РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(Шапка);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        ДобавитьЛог("ДобавитьПолеMultipart: Запись данных");

        Если ТипЗначения = Тип("Булево") Тогда

            Значение = ?(Значение, "true", "false");
            ЗапросЗаписьДанных.ЗаписатьСтроку(Значение);

        ИначеЕсли ТипЗначения = Тип("ДвоичныеДанные") Тогда

            ЗаписатьДвоичныеДанные(ЗапросЗаписьДанных, Значение);

        Иначе

            OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
            ЗапросЗаписьДанных.ЗаписатьСтроку(Значение);

        КонецЕсли;

        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить данные Related
// Добавляет данные в multipart/related тело
//
// Примечание:
// Запись Multipart предварительно должна быть инициализирована при помощи функции `НачатьЗаписьТелаMultipart`
//
// Параметры:
//  Данные    - Произвольный - Данные для записи            - data
//  ТипДанных - Строка       - MIME тип записываемых данных - mime
//  IDЧасти   - Строка       - Content ID, если необходим   - cid
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьДанныеRelated(Знач Данные, Знач ТипДанных, Знач IDЧасти = "") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не Multipart Тогда Возврат Ошибка("ДобавитьФайлRelated: Не инициализирована запись Multipart"); КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(ТипДанных);
        OPI_ПреобразованиеТипов.ПолучитьСтроку(IDЧасти);
        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные, Истина, Ложь);

        ДобавитьЛог("ДобавитьФайлRelated: Запись шапки блока");
        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + Boundary + РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку("Content-Type: " + ТипДанных);

        Если ЗначениеЗаполнено(IDЧасти) Тогда
            ЗапросЗаписьДанных.ЗаписатьСтроку("Content-ID: " + IDЧасти);
        КонецЕсли;

        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        ДобавитьЛог("ДобавитьФайлRelated: Запись данных");
        ЗаписатьДвоичныеДанные(ЗапросЗаписьДанных, Данные);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
        ЗапросЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

#КонецОбласти

#Область УстановкаЗаголовков

// Установить заголовки !NOCLI
// Устанавливает коллекцию заголовков запросов
//
// Примечание:
// `ПолнаяЗамена` также очищает заголовки, установленные ранее другими способами (например, заголовки авторизации)
//
// Параметры:
//  Значение     - Произвольный - Стрктура или соответствие заголовков запрос         - headers
//  ПолнаяЗамена - Булево       - Очищает все существующие заголовки перед установкой - replace
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция УстановитьЗаголовки(Знач Значение, Знач ПолнаяЗамена = Ложь) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;
        Если Не ЗначениеЗаполнено(Значение) Тогда Значение = Новый Соответствие; КонецЕсли;

        ТекстОшибки = "УстановитьПараметрыURL: Переданные параметры не являются коллекцией ключ/значение";
        OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Значение, ТекстОшибки);
        OPI_ПреобразованиеТипов.ПолучитьБулево(ПолнаяЗамена);

        Если ПолнаяЗамена Тогда
            ЗапросЗаголовки = Значение;
        Иначе
            Для Каждого Заголовок Из Значение Цикл
                ЗапросЗаголовки.Вставить(Заголовок.Ключ, Заголовок.Значение);
            КонецЦикла;
        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

#КонецОбласти

#Область Авторизация

// Добавить Basic авторизацию !NOCLI
// Добавляет стандартную авторизацю по пользователю и паролю
//
// Параметры:
//  Пользователь - Строка - Имя пользователя - user
//  Пароль       - Строка - Пароль           - pwd
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьBasicАвторизацию(Знач Пользователь, Знач Пароль) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Пользователь);
        OPI_ПреобразованиеТипов.ПолучитьСтроку(Пароль);

        ЗапросПользователь = Пользователь;
        ЗапросПароль       = Пароль;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Добавить AWS4 авторизацию !NOCLI
// Добавляет данные для AWS4 авторизации
//
// Параметры:
//  AccessKey - Строка - Access key для авторизации       - access
//  SecretKey - Строка - Secret key для авторизации       - secret
//  Region    - Строка - Регион сервиса                   - region
//  Service   - Строка - Вид сервиса, если отличен от s3  - service
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ДобавитьAWS4Авторизацию(Знач AccessKey, Знач SecretKey, Знач Region, Знач Service = "s3") Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        Строка_          = "Строка";
        AWS4Использовать = Истина;

        AWS4Данные = Новый Структура;
        OPI_Инструменты.ДобавитьПоле("AccessKey", AccessKey, Строка_, AWS4Данные);
        OPI_Инструменты.ДобавитьПоле("SecretKey", SecretKey, Строка_, AWS4Данные);
        OPI_Инструменты.ДобавитьПоле("Region"   , Region   , Строка_, AWS4Данные);
        OPI_Инструменты.ДобавитьПоле("Service"  , Service  , Строка_, AWS4Данные);

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

#КонецОбласти

#Область ОбработкаЗапроса

// Обработать запрос !NOCLI
// Создает запрос на основе введенных данных с выполнением или без
//
// Примечание:
// `ВыполнитьСразу = Ложь` может быть использовано для получения готовых^^
// объектов HTTPЗапрос и HTTPСоединение без их выполнения. См. `ВернутьЗапрос` и `ВернутьСоединение`
//
// Параметры:
//  Метод          - Строка - HTTP метод запроса                        - method
//  ВыполнитьСразу - Булево - Выполняет запрос сразу после формирования - run
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ОбработатьЗапрос(Знач Метод, Знач ВыполнитьСразу = Истина) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Метод);
        OPI_ПреобразованиеТипов.ПолучитьБулево(ВыполнитьСразу);
        ЗапросМетод = Метод;

        ДобавитьЛог("ОбработатьЗапрос: Формирование запроса");
        Если СформироватьЗапрос().Ошибка Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДобавитьЛог("ОбработатьЗапрос: Установка тела запроса");
        Если УстановитьТелоЗапроса().Ошибка Тогда Возврат ЭтотОбъект; КонецЕсли;

        ДополнитьЗаголовки();

        Если ВыполнитьСразу Тогда
            ДобавитьЛог("ОбработатьЗапрос: Выполнение запроса");
            ВызватьМетод();
        КонецЕсли;

        Возврат ЭтотОбъект;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Выполнить запрос !NOCLI
// Выполняет запрос, если он был сформирован или установлен ранее
//
// Параметры:
//  Метод - Строка - HTTP метод запроса - method
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент -  Этот же объект обработки
Функция ВыполнитьЗапрос(Знач Метод) Экспорт

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Метод);
        ЗапросМетод = Метод;

        ДобавитьЛог("ВыполнитьЗапрос: Выполнение запроса");

        Возврат ВызватьМетод();

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Вернуть запрос !NOCLI
// Возвращает объект текущего HTTP запроса
//
// Параметры:
//  Принудительно - Булево -  Ложь > Вместо запроса будет возвращен объект обработки, если в ней были ошибки - force
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент, HTTPЗапрос, Неопределено -  Запрос или этот же объект обработки
Функция ВернутьЗапрос(Принудительно = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу() И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    Возврат Запрос;

КонецФункции

// Вернуть соединение !NOCLI
// Возвращает объект текущего HTTP соединения
//
// Параметры:
//  Принудительно - Булево -  Ложь > Вместо соединения будет возвращен объект обработки, если в ней были ошибки - force
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент, HTTPСоединение, Неопределено -  Соединение или этот же объект обработки
Функция ВернутьСоединение(Принудительно = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу() И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    Возврат Соединение;

КонецФункции

#КонецОбласти

#Область ПолучениеОтвета

// Вернуть ответ !NOCLI
// Возвращает объект текущего HTTP ответа
//
// Параметры:
//  Принудительно       - Булево - Ложь > Вместо ответа будет возвращен объект обработки, если в ней были ошибки - force
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки              - ex
//
// Возвращаемое значение:
//  ОбработкаОбъект.OPI_HTTPКлиент, HTTPОтвет, Неопределено -  Ответ или этот же объект обработки
Функция ВернутьОтвет(Знач Принудительно = Ложь, Знач ИсключениеПриОшибке = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    Возврат Ответ;

КонецФункции

// Вернуть ответ как JSON коллекцию !NOCLI
// Возвращает тело ответа как коллекцию, полученную из JSON
//
// Параметры:
//  ВСоответствие       - Булево -  Признак использования соответствия вместо структуры             - map
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки - ex
//
// Возвращаемое значение:
//  Произвольный -  Ответ или этот же объект обработки
Функция ВернутьОтветКакJSONКоллекцию(Знач ВСоответствие = Истина, Знач ИсключениеПриОшибке = Ложь) Экспорт

    Если ОстановитьРаботу(ИсключениеПриОшибке) Тогда Возврат ЭтотОбъект; КонецЕсли;

    Попытка

        OPI_ПреобразованиеТипов.ПолучитьБулево(ВСоответствие);
        ТелоОтвета = ПолучитьТелоОтвета();

        Попытка

            Если ТелоОтвета.Размер() > 0 Тогда
                JSON = OPI_Инструменты.JsonВСтруктуру(ТелоОтвета, ВСоответствие);
            Иначе
                JSON = Новый Соответствие;
            КонецЕсли;

        Исключение

            JSON = ТелоОтвета;

        КонецПопытки;

        Возврат JSON;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

// Вернуть ответ как двоичные данные !NOCLI
// Возвращает тело ответа как двоичные данные
//
// Параметры:
//  Принудительно       - Булево - Ложь > Вместо ответа будет возвращен объект обработки, если в ней были ошибки - force
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки - ex
//
// Возвращаемое значение:
//  Произвольный -  Ответ или этот же объект обработки
Функция ВернутьОтветКакДвоичныеДанные(Знач Принудительно = Ложь, Знач ИсключениеПриОшибке = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    ТелоСтрокой = ПолучитьТелоОтвета();

    Возврат ТелоСтрокой;

КонецФункции

// Вернуть ответ как строку !NOCLI
// Возвращает тело ответа как строку
//
// Параметры:
//  Принудительно       - Булево - Ложь > Вместо ответа будет возвращен объект обработки, если в ней были ошибки - force
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки - ex
//
// Возвращаемое значение:
//  Произвольный -  Ответ или этот же объект обработки
Функция ВернутьОтветКакСтроку(Знач Принудительно = Ложь, Знач ИсключениеПриОшибке = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    ТелоСтрокой = ПолучитьСтрокуИзДвоичныхДанных(ПолучитьТелоОтвета());

    Возврат ТелоСтрокой;

КонецФункции

// Вернуть имя файла тела ответа !NOCLI
// Возвращает путь к файлу тела ответа
//
// Параметры:
//  Принудительно       - Булево - Ложь > Вместо ответа будет возвращен объект обработки, если в ней были ошибки - force
//  ИсключениеПриОшибке - Булево - Вызывает исключение с логом, если во время обработки были ошибки - ex
//
// Возвращаемое значение:
//  Произвольный -  Ответ или этот же объект обработки
Функция ВернутьИмяФайлаТелаОтвета(Знач Принудительно = Ложь, Знач ИсключениеПриОшибке = Ложь) Экспорт

    OPI_ПреобразованиеТипов.ПолучитьБулево(Принудительно);

    Если ОстановитьРаботу(ИсключениеПриОшибке) И Не Принудительно Тогда Возврат ЭтотОбъект; КонецЕсли;

    ИмяФайлаТела = Ответ.ПолучитьИмяФайлаТела();

    Возврат ИмяФайлаТела;

КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область HTTP

Функция ПреобразоватьПараметрВСтроку(Знач Значение)

    КодироватьURL = ПолучитьНастройку("КодировкаURL");

    Если ТипЗнч(Значение) = Тип("Массив") Тогда

        Для Н = 0 По Значение.ВГраница() Цикл
            Значение[Н] = ПреобразоватьПараметрВСтроку(Значение[Н]);
        КонецЦикла;

        Значение = СтрСоединить(Значение, ",");

        Если КодироватьURL Тогда
            Значение = КодироватьСтроку(Значение, СпособКодированияСтроки.URLВКодировкеURL);
        КонецЕсли;

        Значение = "[" + Значение + "]";

    ИначеЕсли ТипЗнч(Значение) = Тип("Соответствие") Или ТипЗнч(Значение) = Тип("Структура") Тогда

        ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет, "");

        ЗаписьJSON = Новый ЗаписьJSON;
        ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);

        ЗаписатьJSON(ЗаписьJSON, Значение);
        Значение = ЗаписьJSON.Закрыть();

    ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда

        Значение = ?(Значение, "true", "false");

    Иначе

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);

        Если КодироватьURL Тогда
            Значение = КодироватьСтроку(Значение, СпособКодированияСтроки.КодировкаURL);
        КонецЕсли;

    КонецЕсли;

    Возврат Значение;

КонецФункции

Функция УстановитьТелоИзДвоичныхДанных(Знач Значение)

    OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Значение, Истина, Ложь);
    ЗапросТело = Значение;

    Возврат ЭтотОбъект;

КонецФункции

Функция УстановитьТелоИзСтроки(Знач Значение, Знач ЗаписатьBOM = Ложь)

    Если ТипЗнч(Значение) = Тип("ДвоичныеДанные") Тогда

        ЗапросТело = Значение;

    Иначе

        Кодировка = ПолучитьНастройку("КодировкаТелаЗапроса");

        OPI_ПреобразованиеТипов.ПолучитьСтроку(Значение);
        OPI_ПреобразованиеТипов.ПолучитьБулево(ЗаписатьBOM);

        ЗапросТело = ПолучитьДвоичныеДанныеИзСтроки(Значение, Кодировка, ЗаписатьBOM);

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция РазбитьURL()

    URL = ЗапросURL;

    ЗапросЗащищенное = Не СтрНачинаетсяС(ЗапросURL, "http://");

    URL = СтрЗаменить(URL, "https://", "");
    URL = СтрЗаменить(URL, "http://" , "");

    Секция = СтрНайти(URL, "#");

    Если Секция > 0 Тогда
        ЗапросСекция = Прав(URL, СтрДлина(URL) - Секция + 1);
        URL          = Лев(URL, Секция - 1);
    КонецЕсли;

    Если СтрНайти(URL, "/") = 0 Тогда
        ЗапросАдрес = "";
        ЗапросДомен = URL;
    Иначе
        ЗапросАдрес = Прав(URL, СтрДлина(URL) - СтрНайти(URL, "/", НаправлениеПоиска.СНачала) + 1);
        ЗапросДомен = Лев(URL, СтрНайти(URL, "/", НаправлениеПоиска.СНачала) - 1);
    КонецЕсли;

    Если СтрНайти(ЗапросДомен, ":") <> 0 Тогда

        ХостПорт    = СтрРазделить(ЗапросДомен, ":");
        ЗапросДомен = ХостПорт[0];
        ЗапросПорт  = ХостПорт[1];

        OPI_ПреобразованиеТипов.ПолучитьЧисло(ЗапросПорт);

    Иначе

        ЗапросПорт = ?(ЗапросЗащищенное, 443, 80);

    КонецЕсли;

    Если OPI_Инструменты.ЭтоOneScript() И ЗапросЗащищенное Тогда
        ЗапросСервер = "https://" + ЗапросДомен;
    Иначе
        ЗапросСервер = ЗапросДомен;
    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция СформироватьЗапрос()

    Если Не ЗначениеЗаполнено(ЗапросURL) Тогда
        Возврат Ошибка("Не установлен URL");
    КонецЕсли;

    ДобавитьЛог("СформироватьЗапрос: Добавление параметров");
    ДополнитьURLПараметрами();

    ДобавитьЛог("СформироватьЗапрос: Создание объекта запроса");
    СоздатьЗапрос();

    ДобавитьЛог("СформироватьЗапрос: Создание объекта соединения");
    СоздатьСоединение();

    Возврат ЭтотОбъект;

КонецФункции

Функция СоздатьЗапрос()

    Заголовки = ПолучитьСтандартныеЗаголовки();
    Запрос    = Новый HTTPЗапрос(ЗапросАдресПолный, Заголовки);

    Возврат ЭтотОбъект;

КонецФункции

Функция СоздатьСоединение()

    Если Не ЗначениеЗаполнено(ЗапросПорт) Тогда
        ЗапросПорт = ?(ЗапросЗащищенное, 443, 80);
    КонецЕсли;

    Если ЗапросЗащищенное Тогда

        Если OPI_Инструменты.ЭтоOneScript() Тогда

            Соединение = Новый HTTPСоединение(ЗапросСервер
                , ЗапросПорт
                , ЗапросПользователь
                , ЗапросПароль
                , ЗапросПрокси
                , ЗапросТаймаут);

        Иначе

            SSL        = Новый ЗащищенноеСоединениеOpenSSL;
            Соединение = Новый HTTPСоединение(ЗапросСервер
            , ЗапросПорт
            , ЗапросПользователь
            , ЗапросПароль
            , ЗапросПрокси
            , ЗапросТаймаут
            , SSL);

        КонецЕсли;

    Иначе

        Соединение = Новый HTTPСоединение(ЗапросСервер
            , ЗапросПорт
            , ЗапросПользователь
            , ЗапросПароль
            , ЗапросПрокси
            , ЗапросТаймаут);

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция ДополнитьURLПараметрами()

    Если СтрЗаканчиваетсяНа(ЗапросАдрес, "?") Или Не ЗначениеЗаполнено(ЗапросПараметрыURL) Тогда
        ЗнакНачала = "";
    ИначеЕсли СтрНайти(ЗапросАдрес, "?") <> 0 Тогда
        ЗнакНачала = "&";
    Иначе
        ЗнакНачала = "?";
    КонецЕсли;

    ЗапросАдресПолный = ЗапросАдрес + ЗнакНачала + ПараметрыЗапросаВСтроку(ЗапросПараметрыURL) + ЗапросСекция;

    Возврат ЭтотОбъект;

КонецФункции

Функция ПараметрыЗапросаВСтроку(Знач Параметры)

    Если Не ЗначениеЗаполнено(Параметры) Тогда
        Возврат "";
    КонецЕсли;

    ДобавитьЛог("ПараметрыЗапросаВСтроку: Получение коллекции КлючЗначение");
    OPI_ПреобразованиеТипов.ПолучитьКоллекциюКлючИЗначение(Параметры);

    СтрокаПараметров = "";

    ДобавитьЛог("ПараметрыЗапросаВСтроку: Добавление параметров");
    Для Каждого Параметр Из Параметры Цикл

        ТекущееЗначение = Параметр.Значение;
        ТекущийКлюч     = Параметр.Ключ;

        Если Не ТипЗнч(ТекущееЗначение) = Тип("Массив") Или Не ПолучитьНастройку("ОтдельныеЭлементыМассивов") Тогда

            ЗначениеПараметра = ПреобразоватьПараметрВСтроку(ТекущееЗначение);
            СтрокаПараметров = СтрокаПараметров + Параметр.Ключ + "=" + ЗначениеПараметра + "&";

        Иначе

            ЗначениеПараметра = РазделитьМассивНаПараметрыURL(ТекущийКлюч, ТекущееЗначение);
            СтрокаПараметров  = СтрокаПараметров + ЗначениеПараметра + "&";

        КонецЕсли;

    КонецЦикла;

    СтрокаПараметров = Лев(СтрокаПараметров, СтрДлина(СтрокаПараметров) - 1);

    Возврат СтрокаПараметров;

КонецФункции

Функция РазделитьМассивНаПараметрыURL(Знач Ключ, Знач Значение)

    КлючМассив = Ключ + "=";

    Для Н = 0 По Значение.ВГраница() Цикл

        ТекущееЗначение = Значение[Н];

        OPI_ПреобразованиеТипов.ПолучитьСтроку(ТекущееЗначение);

        Если ПолучитьНастройку("КодировкаURL") Тогда
            ТекущееЗначение = КодироватьСтроку(ТекущееЗначение, СпособКодированияСтроки.URLВКодировкеURL);
        КонецЕсли;

        Значение.Установить(Н, КлючМассив + ТекущееЗначение);

    КонецЦикла;

    ПараметрСтрокой = СтрСоединить(Значение, "&");

    Возврат ПараметрСтрокой;

КонецФункции

Функция ПолучитьСтандартныеЗаголовки()

    Заголовки = Новый Соответствие;

    Заголовки.Вставить("Accept"         , "*/*");
    Заголовки.Вставить("Connection"     , "keep-alive");
    Заголовки.Вставить("Accept-Charset" , "utf-8");

    Если ПолучитьНастройку("gzip") Тогда
        Заголовки.Вставить("Accept-Encoding", "gzip");
    КонецЕсли;

    Если ЗначениеЗаполнено(ЗапросТипДанных) Тогда
        Заголовки.Вставить("Content-Type", ЗапросТипДанных);
    КонецЕсли;

    Возврат Заголовки;

КонецФункции

Функция ДополнитьЗаголовки()

    Если Запрос.Заголовки.Получить("Content-Length") = Неопределено Тогда

        ДобавитьЛог("ДополнитьЗаголовки: установка Content-Length");

        Если ЗапросФайлТела = Неопределено Тогда

            Если ЗапросТело = Неопределено Тогда
                РазмерТела = 0;
            Иначе
                РазмерТела = ЗапросТело.Размер();
            КонецЕсли;

        Иначе

            ФайлТела   = Новый Файл(ЗапросФайлТела);
            РазмерТела = ФайлТела.Размер();

        КонецЕсли;

        OPI_ПреобразованиеТипов.ПолучитьСтроку(РазмерТела);
        Запрос.Заголовки.Вставить("Content-Length" , РазмерТела);

    КонецЕсли;

    Если AWS4Использовать Тогда
        ДобавитьЛог("ДополнитьЗаголовки: Формирование заголовка AWS4 авторизации");
        ДобавитьAWS4();
    КонецЕсли;

    Если ТипЗнч(ЗапросЗаголовки) = Тип("Соответствие") Тогда

        Для Каждого Заголовок Из ЗапросЗаголовки Цикл
            Запрос.Заголовки.Вставить(Заголовок.Ключ, Заголовок.Значение);
        КонецЦикла;

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция УстановитьТелоЗапроса()

    Если Multipart Тогда
        ЗвершитьЗаписьMultipart();
    КонецЕсли;

    Если ЗначениеЗаполнено(ЗапросФайлТела) Тогда
        Запрос.УстановитьИмяФайлаТела(ЗапросФайлТела);
    Иначе

        Если ТипЗнч(ЗапросТело) = Тип("ДвоичныеДанные") Тогда
            Запрос.УстановитьТелоИзДвоичныхДанных(ЗапросТело);
        КонецЕсли;

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция ВызватьМетод()

    Если ЗначениеЗаполнено(ЗапросВыходнойФайл) Тогда
        Ответ = Соединение.ВызватьHTTPМетод(ЗапросМетод, Запрос, ЗапросВыходнойФайл);
    Иначе
        Ответ = Соединение.ВызватьHTTPМетод(ЗапросМетод, Запрос);
    КонецЕсли;

    Если ЭтоПереадресация(Ответ) Тогда

        URL = Ответ.Заголовки["Location"];
        УстановитьURL(URL);

        ОбработатьЗапрос(ЗапросМетод);

    КонецЕсли;

    Возврат ЭтотОбъект;

КонецФункции

Функция ПолучитьТелоОтвета()

    НужнаРаспаковка = Ложь;

    Для Каждого ЗаголовокОтвета Из Ответ.Заголовки Цикл

        КлючЗаголовка     = ЗаголовокОтвета.Ключ;
        ЗначениеЗаголовка = ЗаголовокОтвета.Значение;

        Если нРег(КлючЗаголовка) = "content-encoding" Тогда
            Если нРег(ЗначениеЗаголовка) = "gzip" Тогда
                НужнаРаспаковка = Истина;
                Прервать;
            КонецЕсли;
        КонецЕсли;

    КонецЦикла;

    Если НужнаРаспаковка Тогда
        Данные = РаспаковатьОтвет(Ответ);
    Иначе
        Данные = ПолучитьТелоОтветаКакДвоичныеДанные();
    КонецЕсли;

    Данные = ?(ТипЗнч(Данные) = Тип("HTTPОтвет"), ПолучитьТелоОтветаКакДвоичныеДанные(), Данные);

    Если Не ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
        OPI_ПреобразованиеТипов.ПолучитьДвоичныеДанные(Данные);
    КонецЕсли;

    Возврат Данные;

КонецФункции

Функция ЭтоПереадресация(Знач Ответ)

    Переадресация = 300;
    ОшибкаЗапроса = 400;

    ЭтоПереадресация = Ответ.КодСостояния >= Переадресация И Ответ.КодСостояния < ОшибкаЗапроса И ЗначениеЗаполнено(
        Ответ.Заголовки["Location"]);

    Возврат ЭтоПереадресация;

КонецФункции

Функция ПолучитьТелоОтветаКакДвоичныеДанные()

    ПотокТела = Ответ.ПолучитьТелоКакПоток();

    Если ПотокТела = Неопределено Тогда
        Возврат ПолучитьДвоичныеДанныеИзСтроки("");
    КонецЕсли;

    ЧтениеДанных    = Новый ЧтениеДанных(ПотокТела);
    РезультатЧтения = ЧтениеДанных.Прочитать();
    Данные          = РезультатЧтения.ПолучитьДвоичныеДанные();

    ЧтениеДанных.Закрыть();
    ПотокТела.Закрыть();

    Возврат Данные;

КонецФункции

Функция ПолучитьТелоЗапросаКакДвоичныеДанные()

    Если ЗначениеЗаполнено(ЗапросФайлТела) Тогда
        Данные = Новый ДвоичныеДанные(ЗапросФайлТела);
    Иначе
        Данные = ЗапросТело;
    КонецЕсли;

    Если Данные = Неопределено Тогда
        Данные = ПолучитьДвоичныеДанныеИзСтроки("");
    КонецЕсли;

    Возврат Данные;

КонецФункции

Процедура ОтменитьЗаписьMultipart()

    Если Не Multipart Тогда
        Возврат;
    КонецЕсли;

    ДобавитьЛог("ОтменитьЗаписьMultipart: Удаление записанных данных");
    Multipart = Ложь;

    Попытка
        ЗапросЗаписьДанных.Закрыть();
    Исключение
        ДобавитьЛог("ОтменитьЗаписьMultipart: Не удалось закрыть запись. Возможно, она уже была закрыта");
    КонецПопытки;

    Если ЗначениеЗаполнено(ЗапросФайлТела) Тогда

        Попытка

            УдалитьФайлы(ЗапросФайлТела);
            ДобавитьЛог("ОтменитьЗаписьMultipart: Файл тела удален");

        Исключение
            ДобавитьЛог("ОтменитьЗаписьMultipart: Не удалось удалить файл тела. Возможно, он уже был удален");
        КонецПопытки;

    Иначе

        Если ТипЗнч(ЗапросПотокТела) = Тип("ПотокВПамяти") Тогда

            Попытка
                ЗапросПотокТела.Закрыть();
            Исключение
                ДобавитьЛог("ОтменитьЗаписьMultipart: Не удалось закрыть поток. Возможно, он уже был закрыт");
            КонецПопытки;

        КонецЕсли;

    КонецЕсли;

    ЗапросЗаписьДанных = Неопределено;
    ЗапросФайлТела     = Неопределено;

КонецПроцедуры

Процедура ЗаписатьДвоичныеДанные(ЗаписьДанных, Знач ДвоичныеДанные)

    РазмерЧасти    = 268435456;
    ПрочитанноБайт = 0;
    ТекущаяПозиция = 0;
    ОбщийРазмер    = ДвоичныеДанные.Размер();

    Пока ПрочитанноБайт < ОбщийРазмер Цикл

        ЧтениеДанных   = Новый ЧтениеДанных(ДвоичныеДанные);
        ПрочитанноБайт = ЧтениеДанных.Пропустить(ТекущаяПозиция);
        Результат      = ЧтениеДанных.Прочитать(РазмерЧасти);
        ТекущиеДанные  = Результат.ПолучитьДвоичныеДанные();
        РазмерТекущих  = ТекущиеДанные.Размер();

        Если Не ЗначениеЗаполнено(ТекущиеДанные) Тогда
            Прервать;
        КонецЕсли;

        ЗаписьДанных.Записать(ТекущиеДанные);

        ОсвободитьОбъект(ТекущиеДанные);
        ВыполнитьСборкуМусора();

        ТекущаяПозиция = ТекущаяПозиция + РазмерТекущих;

    КонецЦикла;

КонецПроцедуры

Процедура ЗвершитьЗаписьMultipart()

    Попытка
        ЗапросЗаписьДанных.ЗаписатьСтроку("--" + Boundary + "--" + РазделительСтрок);
        ЗапросЗаписьДанных.Закрыть();
    Исключение
        ДобавитьЛог("ЗвершитьЗаписьMultipart: Не удалось закрыть запись. Возможно, она уже была закрыта");
    КонецПопытки;

    Если ТипЗнч(ЗапросПотокТела) = Тип("ПотокВПамяти") Тогда
        ЗапросТело = ЗапросПотокТела.ЗакрытьИПолучитьДвоичныеДанные();
    КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область GZip

// Описание структур см. здесь https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
// Источник: https://github.com/vbondarevsky/Connector

// Коннектор: удобный HTTP-клиент для 1С:Предприятие 8
//
// Copyright 2017-2023 Vladimir Bondarevskiy
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//
// URL:    https://github.com/vbondarevsky/Connector
// e-mail: vbondarevsky@gmail.com
// Версия: 2.4.8
//
// Требования: платформа 1С версии 8.3.10 и выше

Функция РаспаковатьОтвет(Ответ)

    Попытка
        Возврат ПрочитатьGZip(ПолучитьТелоОтветаКакДвоичныеДанные());
    Исключение
        Возврат Ответ;
    КонецПопытки;

КонецФункции

Функция ПрочитатьGZip(СжатыеДанные) Экспорт

    РазмерПрефиксаGZip  = 10;
    РазмерПостфиксаGZip = 8;

    РазмерДД  = ZipРазмерDD();
    РазмерСДХ = ZipРазмерCDH();
    РазмерЕСД = ZipРазмерEOCD();
    РазмерЛФХ = ZipРазмерLFH();

    ЧтениеДанных       = Новый ЧтениеДанных(СжатыеДанные);
    ЧтениеДанных.Пропустить(РазмерПрефиксаGZip);
    РазмерСжатыхДанных = ЧтениеДанных.ИсходныйПоток().Размер() - РазмерПрефиксаGZip - РазмерПостфиксаGZip;

    ПотокZip = Новый ПотокВПамяти(РазмерЛФХ + РазмерСжатыхДанных + РазмерДД + РазмерСДХ + РазмерЕСД);

    ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipLFH());
    ЧтениеДанных.КопироватьВ(ЗаписьДанных, РазмерСжатыхДанных);

    ЗаписьДанных.Закрыть();
    ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);

    CRC32                = ЧтениеДанных.ПрочитатьЦелое32();
    РазмерНесжатыхДанных = ЧтениеДанных.ПрочитатьЦелое32();
    ЧтениеДанных.Закрыть();

    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipDD(CRC32 , РазмерСжатыхДанных, РазмерНесжатыхДанных));
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
    ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipEOCD(РазмерСжатыхДанных));
    ЗаписьДанных.Закрыть();

    Возврат ПрочитатьZip(ПотокZip);

КонецФункции

Функция ПрочитатьZip(СжатыеДанные, ТекстОшибки = Неопределено)

    Каталог         = ПолучитьИмяВременногоФайла();
    ЧтениеZip       = Новый ЧтениеZipФайла(СжатыеДанные);
    ИмяФайла        = ЧтениеZip.Элементы[0].Имя;
    Попытка
        ЧтениеZip.Извлечь(ЧтениеZip.Элементы[0], Каталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
    Исключение
        // Игнорируем проверку целостности архива, просто читаем результат
        ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
    КонецПопытки;
    ЧтениеZip.Закрыть();

    Результат = Новый ДвоичныеДанные(Каталог + ПолучитьРазделительПути() + ИмяФайла);
    УдалитьФайлы(Каталог);

    Возврат Результат;

КонецФункции

Функция ZipРазмерLFH()

    Возврат 34;

КонецФункции

Функция ZipРазмерDD()

    Возврат 16;

КонецФункции

Функция ZipРазмерCDH()

    Возврат 50;

КонецФункции

Функция ZipРазмерEOCD()

    Возврат 22;

КонецФункции

Функция ZipLFH()

    // Local file header
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерLFH());
    Буфер.ЗаписатьЦелое32(0, 67324752); // signature 0x04034b50
    Буфер.ЗаписатьЦелое16(4, 20);       // version
    Буфер.ЗаписатьЦелое16(6, 10);       // bit flags
    Буфер.ЗаписатьЦелое16(8, 8);        // compression method
    Буфер.ЗаписатьЦелое16(10, 0);       // time
    Буфер.ЗаписатьЦелое16(12, 0);       // date
    Буфер.ЗаписатьЦелое32(14, 0);       // crc-32
    Буфер.ЗаписатьЦелое32(18, 0);       // compressed size
    Буфер.ЗаписатьЦелое32(22, 0);       // uncompressed size
    Буфер.ЗаписатьЦелое16(26, 4);       // filename legth - "data"
    Буфер.ЗаписатьЦелое16(28, 0);       // extra field length
    Буфер.Записать(30, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));

    Возврат Буфер;

КонецФункции

Функция ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

    // Data descriptor
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерDD());
    Буфер.ЗаписатьЦелое32(0, 134695760);
    Буфер.ЗаписатьЦелое32(4, CRC32);
    Буфер.ЗаписатьЦелое32(8, РазмерСжатыхДанных);
    Буфер.ЗаписатьЦелое32(12, РазмерНесжатыхДанных);

    Возврат Буфер;

КонецФункции

Функция ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

    // Central directory header
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерCDH());
    Буфер.ЗаписатьЦелое32(0, 33639248);              // signature 0x02014b50
    Буфер.ЗаписатьЦелое16(4, 798);                   // version made by
    Буфер.ЗаписатьЦелое16(6, 20);                    // version needed to extract
    Буфер.ЗаписатьЦелое16(8, 10);                    // bit flags
    Буфер.ЗаписатьЦелое16(10, 8);                    // compression method
    Буфер.ЗаписатьЦелое16(12, 0);                    // time
    Буфер.ЗаписатьЦелое16(14, 0);                    // date
    Буфер.ЗаписатьЦелое32(16, CRC32);                // crc-32
    Буфер.ЗаписатьЦелое32(20, РазмерСжатыхДанных);   // compressed size
    Буфер.ЗаписатьЦелое32(24, РазмерНесжатыхДанных); // uncompressed size
    Буфер.ЗаписатьЦелое16(28, 4);                    // file name length
    Буфер.ЗаписатьЦелое16(30, 0);                    // extra field length
    Буфер.ЗаписатьЦелое16(32, 0);                    // file comment length
    Буфер.ЗаписатьЦелое16(34, 0);                    // disk number start
    Буфер.ЗаписатьЦелое16(36, 0);                    // internal file attributes
    Буфер.ЗаписатьЦелое32(38, 2176057344);           // external file attributes
    Буфер.ЗаписатьЦелое32(42, 0);                    // relative offset of local header
    Буфер.Записать(46, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));

    Возврат Буфер;

КонецФункции

Функция ZipEOCD(РазмерСжатыхДанных)

    // End of central directory
    РазмерCDH = 50;
    Буфер = Новый БуферДвоичныхДанных(ZipРазмерEOCD());
    Буфер.ЗаписатьЦелое32(0, 101010256); // signature 0x06054b50
    Буфер.ЗаписатьЦелое16(4, 0); // number of this disk
    Буфер.ЗаписатьЦелое16(6, 0); // number of the disk with the start of the central directory
    Буфер.ЗаписатьЦелое16(8, 1); // total number of entries in the central directory on this disk
    Буфер.ЗаписатьЦелое16(10, 1); // total number of entries in the central directory
    Буфер.ЗаписатьЦелое32(12, РазмерCDH); // size of the central directory
    // offset of start of central directory with respect to the starting disk number
    Буфер.ЗаписатьЦелое32(16, ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD());
    Буфер.ЗаписатьЦелое16(20, 0); // the starting disk number

    Возврат Буфер;

КонецФункции

#КонецОбласти

#Область AWS4

Функция ДобавитьAWS4()

    ЗаголовокАвторизации = СоздатьЗаголовокАвторизации();

    Запрос.Заголовки.Вставить("Authorization", ЗаголовокАвторизации);

    Возврат ЭтотОбъект;

КонецФункции

Функция СоздатьЗаголовокАвторизации()

    AccessKey   = AWS4Данные["AccessKey"];
    ТекущаяДата = ТекущаяУниверсальнаяДата();

    Запрос.Заголовки.Вставить("x-amz-date", OPI_Инструменты.ВременнаяМеткаISO(ТекущаяДата));
    Запрос.Заголовки.Вставить("Host"      , Соединение.Сервер);

    ОсновныеЧасти = ПолучитьОсновныеСоставляющиеПодписи(ТекущаяДата);

    Скоуп           = ОсновныеЧасти["Скоуп"];
    Сигнатура       = ОсновныеЧасти["Сигнатура"];
    КлючиЗаголовков = ОсновныеЧасти["КлючиЗаголовков"];

    ЗаголовокАвторизации = СформироватьЗаголовокАвторизации(AccessKey, Скоуп, Сигнатура, КлючиЗаголовков);

    Возврат ЗаголовокАвторизации;

КонецФункции

Функция ПолучитьОсновныеСоставляющиеПодписи(Знач ТекущаяДата)

    SecretKey = AWS4Данные["SecretKey"];
    Region    = AWS4Данные["Region"];
    Service   = AWS4Данные["Service"];

    КлючПодписи        = ПолучитьКлючПодписи(SecretKey, Region, Service, ТекущаяДата);
    КаноническийЗапрос = СоздатьКаноническийЗапрос();
    Скоуп              = СоздатьСкоуп(Region, Service, ТекущаяДата);
    СтрокаДляПодписи   = СоздатьСтрокуПодписи(КаноническийЗапрос, Скоуп, ТекущаяДата);

    Сигнатура = OPI_Криптография.HMACSHA256(КлючПодписи, СтрокаДляПодписи);
    Сигнатура = нРег(ПолучитьHexСтрокуИзДвоичныхДанных(Сигнатура));

    КлючиЗаголовков = ПолучитьСтрокуКлючейЗаголовков();

    СтруктураЧастей = Новый Структура;

    СтруктураЧастей.Вставить("Скоуп"          , Скоуп);
    СтруктураЧастей.Вставить("Сигнатура"      , Сигнатура);
    СтруктураЧастей.Вставить("КлючиЗаголовков", КлючиЗаголовков);

    Возврат СтруктураЧастей;

КонецФункции

Функция СформироватьЗаголовокАвторизации(Знач AccessKey, Знач Скоуп, Знач Сигнатура, Знач КлючиЗаголовков)

    ШаблонЗаголовка = "AWS4-HMAC-SHA256 "
        + "Credential=%1/%2, "
        + "SignedHeaders=%3, "
        + "Signature=%4";

    ЗаголовокАвторизации = СтрШаблон(ШаблонЗаголовка, AccessKey, Скоуп, КлючиЗаголовков, Сигнатура);

    Возврат ЗаголовокАвторизации;

КонецФункции

Функция ПолучитьКлючПодписи(Знач СекретныйКлюч, Знач Регион, Знач Сервис, Знач ТекущаяДата)

    СекретныйКлюч = ПолучитьДвоичныеДанныеИзСтроки("AWS4" + СекретныйКлюч);
    ДанныеДата    = ПолучитьДвоичныеДанныеИзСтроки(Формат(ТекущаяДата, "ДФ=yyyyMMdd;"));
    Регион        = ПолучитьДвоичныеДанныеИзСтроки(Регион);
    Сервис        = ПолучитьДвоичныеДанныеИзСтроки(Сервис);
    AWSЗапрос     = ПолучитьДвоичныеДанныеИзСтроки("aws4_request");

    КлючДанных  = OPI_Криптография.HMACSHA256(СекретныйКлюч, ДанныеДата);
    КлючРегиона = OPI_Криптография.HMACSHA256(КлючДанных, Регион);
    КлючСервиса = OPI_Криптография.HMACSHA256(КлючРегиона, Сервис);

    ФинальныйКлюч = OPI_Криптография.HMACSHA256(КлючСервиса, AWSЗапрос);

    Возврат ФинальныйКлюч;

КонецФункции

Функция СоздатьКаноническийЗапрос()

    ШаблонЗапроса = "";
    ТелоЗапроса   = ПолучитьТелоЗапросаКакДвоичныеДанные();
    ХешСумма      = OPI_Криптография.Хеш(ТелоЗапроса, ХешФункция.SHA256);
    ЧислоЧастей   = 6;

    Запрос.Заголовки.Вставить("x-amz-content-sha256", нРег(ПолучитьHexСтрокуИзДвоичныхДанных(ХешСумма)));

    Для Н = 1 По ЧислоЧастей Цикл

        ШаблонЗапроса = ШаблонЗапроса + "%" + Строка(Н) + ?(Н = ЧислоЧастей, "", Символы.ПС);

    КонецЦикла;

    Метод            = вРег(ЗапросМетод);
    СтрокаURI        = ПолучитьСтрокуURI();
    СтрокаПараметров = ПолучитьСтрокуПараметров();
    СтрокаЗаголовков = ПолучитьСтрокуЗаголовков();
    СтрокаКлючей     = ПолучитьСтрокуКлючейЗаголовков();

    СтрокаХэша = нРег(ПолучитьHexСтрокуИзДвоичныхДанных(ХешСумма));

    КаноническийЗапрос = СтрШаблон(ШаблонЗапроса
        , Метод
        , СтрокаURI
        , СтрокаПараметров
        , СтрокаЗаголовков
        , СтрокаКлючей
        , СтрокаХэша);

    Возврат КаноническийЗапрос;

КонецФункции

Функция СоздатьСкоуп(Знач Регион, Знач Сервис, Знач ТекущаяДата)

    ДатаОбычная = Формат(ТекущаяДата, "ДФ=yyyyMMdd;");

    Скоуп = Новый Массив;
    Скоуп.Добавить(ДатаОбычная);
    Скоуп.Добавить(Регион);
    Скоуп.Добавить(Сервис);
    Скоуп.Добавить("aws4_request");

    СкоупСтрокой = СтрСоединить(Скоуп, "/");

    Возврат СкоупСтрокой;

КонецФункции

Функция СоздатьСтрокуПодписи(Знач КаноническийЗапрос, Знач Скоуп, Знач ТекущаяДата)

    ШаблонСтроки = "";
    Алгоритм     = "AWS4-HMAC-SHA256";
    ДатаISO      = OPI_Инструменты.ВременнаяМеткаISO(ТекущаяДата);
    ЧислоЧастей  = 4;

    КаноническийЗапрос = ПолучитьДвоичныеДанныеИзСтроки(КаноническийЗапрос);
    КаноническийЗапрос = OPI_Криптография.Хеш(КаноническийЗапрос, ХешФункция.SHA256);
    КаноническийЗапрос = нРег(ПолучитьHexСтрокуИзДвоичныхДанных(КаноническийЗапрос));

    Для Н = 1 По ЧислоЧастей Цикл

        ШаблонСтроки = ШаблонСтроки + "%" + Строка(Н) + ?(Н = ЧислоЧастей, "", Символы.ПС);

    КонецЦикла;

    СтрокаПодписи = СтрШаблон(ШаблонСтроки, Алгоритм, ДатаISO, Скоуп, КаноническийЗапрос);
    СтрокаПодписи = ПолучитьДвоичныеДанныеИзСтроки(СтрокаПодписи);

    Возврат СтрокаПодписи;

КонецФункции

Функция ПолучитьСтрокуКлючейЗаголовков()

    СписокЗаголовков = Новый СписокЗначений;

    Для Каждого Заголовок Из Запрос.Заголовки Цикл

        ТекущийКлюч  = Заголовок.Ключ;
        ТекущийКлючН = нРег(ТекущийКлюч);

        Если Не СтрНачинаетсяС(ТекущийКлючН, "host") И Не СтрНачинаетсяС(ТекущийКлючН, "x-amz") Тогда
            Продолжить;
        КонецЕсли;

        СтрокаЗаголовка = нРег(ТекущийКлюч);
        СписокЗаголовков.Добавить(СтрокаЗаголовка);

    КонецЦикла;

    СписокЗаголовков.СортироватьПоЗначению();

    СтрокаЗаголовков = СтрСоединить(СписокЗаголовков.ВыгрузитьЗначения(), ";");

    Возврат СтрокаЗаголовков;

КонецФункции

Функция ПолучитьСтрокуURI()

    URI = Запрос.АдресРесурса;
    URI = ?(СтрНачинаетсяС(URI, "/"), URI, "/" + URI);

    НачалоПараметров = СтрНайти(URI, "?");

    Если НачалоПараметров <> 0 Тогда
        URI = Лев(URI, НачалоПараметров - 1);
    КонецЕсли;

    Возврат URI;

КонецФункции

Функция ПолучитьСтрокуПараметров()

    URI              = Запрос.АдресРесурса;
    НачалоПараметров = СтрНайти(URI, "?");

    Если НачалоПараметров = 0 Тогда

        СтрокаПараметров = "";

    Иначе

        ДлинаURI         = СтрДлина(URI);
        СтрокаПараметров = Прав(URI, ДлинаURI - НачалоПараметров);
        ОбработатьСтрокуПараметровЗапроса(СтрокаПараметров);

    КонецЕсли;

    Возврат СтрокаПараметров;

КонецФункции

Функция ПолучитьСтрокуЗаголовков()

    СписокЗаголовков = Новый СписокЗначений;

    Для Каждого Заголовок Из Запрос.Заголовки Цикл

        ТекущийКлюч  = Заголовок.Ключ;
        ТекущийКлючН = нРег(ТекущийКлюч);

        Если Не СтрНачинаетсяС(ТекущийКлючН, "host") И Не СтрНачинаетсяС(ТекущийКлючН, "x-amz") Тогда
            Продолжить;
        КонецЕсли;

        СтрокаЗаголовка = нРег(ТекущийКлюч) + ":" + Заголовок.Значение;
        СписокЗаголовков.Добавить(СтрокаЗаголовка);

    КонецЦикла;

    СписокЗаголовков.СортироватьПоЗначению();

    СтрокаЗаголовков = СтрСоединить(СписокЗаголовков.ВыгрузитьЗначения(), Символы.ПС);
    СтрокаЗаголовков = СтрокаЗаголовков + Символы.ПС;

    Возврат СтрокаЗаголовков;

КонецФункции

Процедура ОбработатьСтрокуПараметровЗапроса(СтрокаПараметров)

    МассивПараметров = СтрРазделить(СтрокаПараметров, "&");
    СписокПараметров = Новый СписокЗначений();
    СписокПараметров.ЗагрузитьЗначения(МассивПараметров);

    СписокПараметров.СортироватьПоЗначению();
    МассивПараметров = СписокПараметров.ВыгрузитьЗначения();

    Для Н = 0 По МассивПараметров.ВГраница() Цикл

        ПараметрЗапроса = МассивПараметров[Н];

        Если СтрНайти(ПараметрЗапроса, "=") = 0 Тогда
            МассивПараметров[Н] = ПараметрЗапроса + "=";
        КонецЕсли;

    КонецЦикла;

    СтрокаПараметров = СтрСоединить(МассивПараметров, "&");

КонецПроцедуры

#КонецОбласти

#Область Вспомогательные

Функция ОстановитьРаботу(Знач ИсключениеПриОшибке = Ложь)

    OPI_ПреобразованиеТипов.ПолучитьБулево(ИсключениеПриОшибке);

    ЕстьОшибка = ЗапросИнициализирован().Ошибка;

    Если ЕстьОшибка И ИсключениеПриОшибке Тогда
        ВызватьИсключение ПолучитьЛог(Истина);
    Иначе
        Возврат ЕстьОшибка;
    КонецЕсли;

КонецФункции

Функция ЗапросИнициализирован()

    Возврат ?(ЗначениеЗаполнено(Инициализирован)
        , ЭтотОбъект
        , Ошибка("Запрос не инициализирован. Необходимо вызвать функцию Инициализировать() перед началом работы"));

КонецФункции

Функция Ошибка(Знач ТекстОшибки)

    Ошибка = Истина;

    Если ФайлТелаВременный И ЗначениеЗаполнено(ЗапросФайлТела) Тогда

        Попытка
            УдалитьФайлы(ЗапросФайлТела);
            ЗапросФайлТела    = Неопределено;
            ФайлТелаВременный = Ложь;
        Исключение
            ДобавитьЛог("Ошибка: Не удалось удалить временный файл при исключении");
        КонецПопытки;

    КонецЕсли;

    Возврат ДобавитьЛог(ТекстОшибки);

КонецФункции

Функция ДобавитьЛог(Знач Текст)

    OPI_ПреобразованиеТипов.ПолучитьСтроку(Текст);

    Лог.Добавить(Текст);

    Возврат ЭтотОбъект;

КонецФункции

Функция ПолучитьНастройку(Знач КлючНастройки)
    Возврат Настройки[КлючНастройки];
КонецФункции

Процедура УстановитьНастройку(Знач КлючНастройки, Знач Значение)
    Настройки[КлючНастройки] = Значение;
КонецПроцедуры

Процедура УстановитьСтандартныеНастройки()

    Настройки = Новый Структура;
    Настройки.Вставить("gzip"                     , Истина);
    Настройки.Вставить("ОтдельныеЭлементыМассивов", Ложь);
    Настройки.Вставить("КодировкаURL"             , Истина);
    Настройки.Вставить("КодировкаТелаЗапроса"     , "UTF-8");

КонецПроцедуры

Процедура КодироватьURLВURL(URL) Экспорт

    Заглушка = СтрШаблон("@#%1#@", Строка(Новый УникальныйИдентификатор));

    URL = СтрЗаменить(URL, "&"     , Заглушка);
    URL = КодироватьСтроку(URL, СпособКодированияСтроки.URLВКодировкеURL);
    URL = СтрЗаменить(URL, Заглушка, "&");

КонецПроцедуры

Функция ШаблонФункции()

    Попытка

        Если ОстановитьРаботу() Тогда Возврат ЭтотОбъект; КонецЕсли;

    Исключение
        Возврат Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
    КонецПопытки;

КонецФункции

#КонецОбласти

#КонецОбласти

// #КонецЕсли
